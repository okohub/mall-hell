<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mall Hell - Unit Tests</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #1a1a2e;
            color: #fff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            padding: 20px;
            line-height: 1.6;
        }
        h1 {
            color: #e94560;
            margin-bottom: 10px;
            font-size: 32px;
        }
        .subtitle {
            color: #888;
            margin-bottom: 30px;
        }
        .summary {
            background: #2c3e50;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 30px;
            display: flex;
            gap: 30px;
            align-items: center;
        }
        .summary-item {
            text-align: center;
        }
        .summary-item .label {
            font-size: 12px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .summary-item .value {
            font-size: 36px;
            font-weight: bold;
        }
        .summary-item .value.passed { color: #2ecc71; }
        .summary-item .value.failed { color: #e74c3c; }
        .summary-item .value.total { color: #f1c40f; }

        .test-module {
            background: #16213e;
            border-radius: 10px;
            margin-bottom: 20px;
            overflow: hidden;
        }
        .module-header {
            background: #0f3460;
            padding: 15px 20px;
            font-size: 18px;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
        }
        .module-header:hover {
            background: #1a4a7a;
        }
        .module-status {
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 12px;
            text-transform: uppercase;
        }
        .module-status.all-passed {
            background: #27ae60;
        }
        .module-status.has-failures {
            background: #e74c3c;
        }
        .test-list {
            padding: 10px 20px 20px;
        }
        .test-item {
            padding: 12px 15px;
            margin: 8px 0;
            border-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .test-item.passed {
            background: rgba(46, 204, 113, 0.15);
            border-left: 4px solid #2ecc71;
        }
        .test-item.failed {
            background: rgba(231, 76, 60, 0.15);
            border-left: 4px solid #e74c3c;
        }
        .test-name {
            font-weight: 500;
        }
        .test-status {
            padding: 4px 12px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
        }
        .test-status.passed {
            background: #2ecc71;
            color: #fff;
        }
        .test-status.failed {
            background: #e74c3c;
            color: #fff;
        }
        .test-details {
            font-size: 12px;
            color: #888;
            margin-top: 5px;
        }
        .test-details.error {
            color: #e74c3c;
        }
        .progress-bar {
            width: 200px;
            height: 10px;
            background: #34495e;
            border-radius: 5px;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #2ecc71, #27ae60);
            transition: width 0.3s;
        }
        .run-btn {
            background: linear-gradient(135deg, #e94560, #c0392b);
            color: #fff;
            border: none;
            padding: 15px 40px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 8px;
            margin-bottom: 30px;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .run-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(233, 69, 96, 0.4);
        }
        .run-btn:disabled {
            background: #555;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
    </style>
</head>
<body>
    <h1>Mall Hell Unit Tests</h1>
    <p class="subtitle">Testing core game logic modules</p>

    <button class="run-btn" id="run-tests">Run All Tests</button>

    <div class="summary" id="summary" style="display: none;">
        <div class="summary-item">
            <div class="label">Total Tests</div>
            <div class="value total" id="total-count">0</div>
        </div>
        <div class="summary-item">
            <div class="label">Passed</div>
            <div class="value passed" id="passed-count">0</div>
        </div>
        <div class="summary-item">
            <div class="label">Failed</div>
            <div class="value failed" id="failed-count">0</div>
        </div>
        <div class="summary-item">
            <div class="label">Progress</div>
            <div class="progress-bar">
                <div class="progress-fill" id="progress-fill"></div>
            </div>
        </div>
    </div>

    <div id="test-results"></div>

    <script>
        // ============================================
        // SIMPLE CUSTOM TEST FRAMEWORK
        // ============================================

        class TestFramework {
            constructor() {
                this.modules = [];
                this.currentModule = null;
                this.results = {
                    total: 0,
                    passed: 0,
                    failed: 0
                };
            }

            describe(moduleName, testFn) {
                this.currentModule = {
                    name: moduleName,
                    tests: [],
                    beforeEach: null,
                    afterEach: null
                };
                testFn();
                this.modules.push(this.currentModule);
            }

            beforeEach(fn) {
                if (this.currentModule) {
                    this.currentModule.beforeEach = fn;
                }
            }

            afterEach(fn) {
                if (this.currentModule) {
                    this.currentModule.afterEach = fn;
                }
            }

            it(testName, testFn) {
                if (this.currentModule) {
                    this.currentModule.tests.push({
                        name: testName,
                        fn: testFn,
                        passed: null,
                        error: null
                    });
                }
            }

            assertEqual(actual, expected, message = '') {
                if (actual !== expected) {
                    throw new Error(`${message} Expected ${expected}, got ${actual}`);
                }
            }

            assertCloseTo(actual, expected, tolerance = 0.0001, message = '') {
                if (Math.abs(actual - expected) > tolerance) {
                    throw new Error(`${message} Expected ${expected} (Â±${tolerance}), got ${actual}`);
                }
            }

            assertTrue(value, message = '') {
                if (!value) {
                    throw new Error(`${message} Expected true, got ${value}`);
                }
            }

            assertFalse(value, message = '') {
                if (value) {
                    throw new Error(`${message} Expected false, got ${value}`);
                }
            }

            assertGreaterThan(actual, expected, message = '') {
                if (!(actual > expected)) {
                    throw new Error(`${message} Expected ${actual} to be greater than ${expected}`);
                }
            }

            assertLessThan(actual, expected, message = '') {
                if (!(actual < expected)) {
                    throw new Error(`${message} Expected ${actual} to be less than ${expected}`);
                }
            }

            assertInRange(value, min, max, message = '') {
                if (value < min || value > max) {
                    throw new Error(`${message} Expected ${value} to be between ${min} and ${max}`);
                }
            }

            assertThrows(fn, message = '') {
                let threw = false;
                try {
                    fn();
                } catch (e) {
                    threw = true;
                }
                if (!threw) {
                    throw new Error(`${message} Expected function to throw an error`);
                }
            }

            assertArrayEqual(actual, expected, message = '') {
                if (actual.length !== expected.length) {
                    throw new Error(`${message} Array lengths differ: ${actual.length} vs ${expected.length}`);
                }
                for (let i = 0; i < actual.length; i++) {
                    if (actual[i] !== expected[i]) {
                        throw new Error(`${message} Arrays differ at index ${i}: ${actual[i]} vs ${expected[i]}`);
                    }
                }
            }

            skip(reason = 'Skipped') {
                // Throw a special skip error to mark test as skipped (counts as passed)
                const err = new Error(reason);
                err.isSkip = true;
                throw err;
            }

            run() {
                this.results = { total: 0, passed: 0, failed: 0, skipped: 0 };

                for (const module of this.modules) {
                    for (const test of module.tests) {
                        this.results.total++;

                        try {
                            // Setup
                            if (module.beforeEach) {
                                module.beforeEach();
                            }

                            // Run test
                            test.fn();

                            // Teardown
                            if (module.afterEach) {
                                module.afterEach();
                            }

                            test.passed = true;
                            this.results.passed++;
                        } catch (e) {
                            if (e.isSkip) {
                                // Skipped tests count as passed
                                test.passed = true;
                                test.skipped = true;
                                test.error = e.message;
                                this.results.skipped++;
                                this.results.passed++;
                            } else {
                                test.passed = false;
                                test.error = e.message;
                                this.results.failed++;
                            }
                        }
                    }
                }

                return this.results;
            }

            getModules() {
                return this.modules;
            }
        }

        const test = new TestFramework();
        // Make TestFramework available globally for domain test files
        window.TestFramework = test;
    </script>

    <!-- Three.js for visual tests -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <!-- Domain Source Files -->
    <script src="../src/weapon/weapon.js"></script>
    <script src="../src/weapon/weapon-visual.js"></script>
    <script src="../src/weapon/weapon-system.js"></script>
    <script src="../src/projectile/projectile.js"></script>
    <script src="../src/projectile/projectile-visual.js"></script>
    <script src="../src/projectile/projectile-system.js"></script>
    <script src="../src/enemy/enemy.js"></script>
    <script src="../src/enemy/enemy-visual.js"></script>
    <script src="../src/enemy/enemy-system.js"></script>
    <script src="../src/environment/obstacle.js"></script>
    <script src="../src/environment/obstacle-visual.js"></script>
    <script src="../src/environment/shelf.js"></script>
    <script src="../src/environment/shelf-visual.js"></script>
    <script src="../src/environment/environment-system.js"></script>

    <!-- Domain Test Files -->
    <script src="../src/weapon/weapon.test.js"></script>
    <script src="../src/projectile/projectile.test.js"></script>
    <script src="../src/enemy/enemy.test.js"></script>
    <script src="../src/environment/environment.test.js"></script>

    <script>
        // ============================================
        // EXTRACTED GAME LOGIC FOR TESTING
        // (Standalone functions that mirror game logic)
        // ============================================

        // Game Constants (from index.html)
        const AISLE_LENGTH = 800;
        const CART_SPEED = 25;
        const SHOOT_COOLDOWN = 500;
        const PROJECTILE_SPEED = 120;
        const ENEMY_HEALTH = 3;

        // Valid game states
        const VALID_STATES = ['MENU', 'PLAYING', 'PAUSED', 'GAME_OVER'];

        // Valid state transitions
        const VALID_TRANSITIONS = {
            'MENU': ['PLAYING'],
            'PLAYING': ['PAUSED', 'GAME_OVER'],
            'PAUSED': ['PLAYING', 'MENU'],
            'GAME_OVER': ['MENU', 'PLAYING']
        };

        // ============================================
        // SCORING SYSTEM MODULE
        // ============================================

        const ScoringSystem = {
            calculateScore(baseScore, multiplier = 1) {
                return Math.floor(baseScore * multiplier);
            },

            getEnemyHitScore() {
                return 100;
            },

            getEnemyDestroyScore() {
                return 300;
            },

            getObstacleHitScore() {
                return 150;
            },

            getRating(score) {
                if (score > 10000) return 'LEGENDARY CHAOS!';
                if (score > 7000) return 'Total Mayhem!';
                if (score > 4000) return 'Chaos Master';
                if (score > 2000) return 'Troublemaker';
                if (score > 800) return 'Rowdy Kid';
                return 'Mild Mischief';
            },

            getRatingThresholds() {
                return [
                    { threshold: 10000, rating: 'LEGENDARY CHAOS!' },
                    { threshold: 7000, rating: 'Total Mayhem!' },
                    { threshold: 4000, rating: 'Chaos Master' },
                    { threshold: 2000, rating: 'Troublemaker' },
                    { threshold: 800, rating: 'Rowdy Kid' },
                    { threshold: 0, rating: 'Mild Mischief' }
                ];
            }
        };

        // ============================================
        // GAME STATE MACHINE MODULE
        // ============================================

        const GameStateMachine = {
            currentState: 'MENU',

            reset() {
                this.currentState = 'MENU';
            },

            getState() {
                return this.currentState;
            },

            isValidState(state) {
                return VALID_STATES.includes(state);
            },

            canTransitionTo(targetState) {
                const allowedTransitions = VALID_TRANSITIONS[this.currentState];
                return allowedTransitions && allowedTransitions.includes(targetState);
            },

            transitionTo(targetState) {
                if (!this.isValidState(targetState)) {
                    return false;
                }
                if (!this.canTransitionTo(targetState)) {
                    return false;
                }
                this.currentState = targetState;
                return true;
            },

            startGame() {
                return this.transitionTo('PLAYING');
            },

            pauseGame() {
                return this.transitionTo('PAUSED');
            },

            resumeGame() {
                return this.transitionTo('PLAYING');
            },

            endGame() {
                return this.transitionTo('GAME_OVER');
            },

            quitToMenu() {
                return this.transitionTo('MENU');
            }
        };

        // ============================================
        // COOLDOWN SYSTEM MODULE
        // ============================================

        const CooldownSystem = {
            lastShootTime: 0,
            cooldownDuration: SHOOT_COOLDOWN,

            reset() {
                this.lastShootTime = 0;
            },

            canShoot(currentTime) {
                return (currentTime - this.lastShootTime) >= this.cooldownDuration;
            },

            shoot(currentTime) {
                if (!this.canShoot(currentTime)) {
                    return false;
                }
                this.lastShootTime = currentTime;
                return true;
            },

            getCooldownProgress(currentTime) {
                const elapsed = currentTime - this.lastShootTime;
                return Math.min(elapsed / this.cooldownDuration, 1);
            },

            getRemainingCooldown(currentTime) {
                const elapsed = currentTime - this.lastShootTime;
                return Math.max(this.cooldownDuration - elapsed, 0);
            }
        };

        // ============================================
        // COLLISION DETECTION MODULE
        // ============================================

        const CollisionDetection = {
            distanceBetween(pos1, pos2) {
                const dx = pos2.x - pos1.x;
                const dy = pos2.y - pos1.y;
                const dz = pos2.z - pos1.z;
                return Math.sqrt(dx * dx + dy * dy + dz * dz);
            },

            checkHit(projectilePos, targetPos, hitRadius) {
                const dist = this.distanceBetween(projectilePos, targetPos);
                return dist < hitRadius;
            },

            isProjectileInBounds(projectilePos, cameraZ, bounds) {
                const { maxDistance, maxX, minY, maxY } = bounds;

                if (projectilePos.z < cameraZ - maxDistance) return false;
                if (Math.abs(projectilePos.x) > maxX) return false;
                if (projectilePos.y < minY || projectilePos.y > maxY) return false;

                return true;
            },

            getEnemyHitRadius() {
                return 2;
            },

            getObstacleHitRadius(obstacleWidth) {
                return obstacleWidth * 0.7;
            }
        };

        // ============================================
        // SPAWN SYSTEM MODULE
        // ============================================

        const SpawnSystem = {
            maxEnemies: 10,
            maxObstacles: 15,

            canSpawnEnemy(currentEnemyCount) {
                return currentEnemyCount < this.maxEnemies;
            },

            canSpawnObstacle(currentObstacleCount) {
                return currentObstacleCount < this.maxObstacles;
            },

            calculateSpawnX(rangeWidth) {
                return (Math.random() - 0.5) * rangeWidth;
            },

            calculateSpawnZ(cameraZ, spawnDistance) {
                return cameraZ - spawnDistance;
            },

            shouldSpawnEnemy(randomValue, spawnChance = 0.015) {
                return randomValue < spawnChance;
            },

            shouldSpawnObstacle(randomValue, spawnChance = 0.02) {
                return randomValue < spawnChance;
            },

            getRandomObstacleType() {
                const types = ['stack', 'barrel', 'display'];
                return types[Math.floor(Math.random() * types.length)];
            },

            validateSpawnPosition(x, z, minX, maxX, maxZ) {
                return x >= minX && x <= maxX && z >= maxZ;
            }
        };

        // ============================================
        // OBJECT CLEANUP MODULE
        // ============================================

        const ObjectCleanup = {
            isObjectBehindCamera(objectZ, cameraZ, buffer) {
                return objectZ > cameraZ + buffer;
            },

            isProjectileOutOfBounds(projectile, cameraZ, bounds) {
                return !CollisionDetection.isProjectileInBounds(
                    projectile.position,
                    cameraZ,
                    bounds
                );
            },

            isParticleDead(particle) {
                return particle.life <= 0;
            },

            filterActiveObjects(objects) {
                return objects.filter(obj => obj.active);
            },

            countActiveObjects(objects) {
                return objects.filter(obj => obj.active).length;
            },

            markForRemoval(object) {
                object.active = false;
                return object;
            }
        };

        // ============================================
        // HEALTH SYSTEM MODULE
        // ============================================

        const HealthSystem = {
            maxHealth: ENEMY_HEALTH,

            createEnemy() {
                return {
                    health: this.maxHealth,
                    active: true,
                    hitFlash: 0
                };
            },

            damageEnemy(enemy, damage = 1) {
                if (!enemy.active) return enemy;

                enemy.health -= damage;
                enemy.hitFlash = 1;

                if (enemy.health <= 0) {
                    enemy.health = 0;
                    enemy.active = false;
                }

                return enemy;
            },

            isEnemyAlive(enemy) {
                return enemy.active && enemy.health > 0;
            },

            isEnemyDestroyed(enemy) {
                return !enemy.active || enemy.health <= 0;
            },

            getHealthPercentage(enemy) {
                return enemy.health / this.maxHealth;
            },

            getHealthBarScale(enemy) {
                return enemy.health / this.maxHealth;
            }
        };

        // ============================================
        // PLAYER MOVEMENT SYSTEM MODULE
        // ============================================

        const PlayerMovementSystem = {
            lateralSpeed: 8, // units per second
            speedBoostMultiplier: 1.5,
            slowdownMultiplier: 0.5,
            minBound: -10,
            maxBound: 10,

            reset() {
                // Reset any state if needed
            },

            getLateralSpeed() {
                return this.lateralSpeed;
            },

            getSpeedWithBoost() {
                return this.lateralSpeed * this.speedBoostMultiplier;
            },

            getSpeedWithSlowdown() {
                return this.lateralSpeed * this.slowdownMultiplier;
            },

            clampPosition(position) {
                return Math.max(this.minBound, Math.min(this.maxBound, position));
            },

            canMove(gameState) {
                return gameState === 'PLAYING';
            },

            calculateVelocity(leftPressed, rightPressed) {
                let velocity = 0;
                if (leftPressed) velocity -= this.lateralSpeed;
                if (rightPressed) velocity += this.lateralSpeed;
                return velocity;
            }
        };

        // ============================================
        // PLAYER HEALTH SYSTEM MODULE
        // ============================================

        const PlayerHealthSystem = {
            health: 100,
            maxHealth: 100,
            invulnerabilityDuration: 1000, // 1 second in milliseconds
            lastDamageTime: -1000, // Start with no invulnerability

            reset() {
                this.health = 100;
                this.lastDamageTime = -1000;
            },

            getHealth() {
                return this.health;
            },

            getMaxHealth() {
                return this.maxHealth;
            },

            getInvulnerabilityDuration() {
                return this.invulnerabilityDuration;
            },

            isInvulnerable(currentTime) {
                return (currentTime - this.lastDamageTime) < this.invulnerabilityDuration;
            },

            applyDamage(amount, currentTime) {
                if (this.isInvulnerable(currentTime)) {
                    return false; // Damage blocked
                }

                this.health = Math.max(0, this.health - amount);
                this.lastDamageTime = currentTime;
                return true; // Damage applied
            },

            applyEnemyCollisionDamage() {
                this.health = Math.max(0, this.health - 20);
            },

            applyObstacleCollisionDamage() {
                this.health = Math.max(0, this.health - 10);
            },

            isDead() {
                return this.health <= 0;
            },

            getHealthPercentage() {
                return (this.health / this.maxHealth) * 100;
            }
        };

        // ============================================
        // TEST DEFINITIONS
        // ============================================

        // Scoring System Tests
        test.describe('Scoring System', () => {
            test.it('should return correct enemy hit score (100 points)', () => {
                test.assertEqual(ScoringSystem.getEnemyHitScore(), 100);
            });

            test.it('should return correct enemy destroy score (300 points)', () => {
                test.assertEqual(ScoringSystem.getEnemyDestroyScore(), 300);
            });

            test.it('should return correct obstacle hit score (150 points)', () => {
                test.assertEqual(ScoringSystem.getObstacleHitScore(), 150);
            });

            test.it('should apply multiplier correctly to base score', () => {
                test.assertEqual(ScoringSystem.calculateScore(100, 2), 200);
                test.assertEqual(ScoringSystem.calculateScore(150, 1.5), 225);
            });

            test.it('should return "Mild Mischief" rating for score <= 800', () => {
                test.assertEqual(ScoringSystem.getRating(0), 'Mild Mischief');
                test.assertEqual(ScoringSystem.getRating(500), 'Mild Mischief');
                test.assertEqual(ScoringSystem.getRating(800), 'Mild Mischief');
            });

            test.it('should return "Rowdy Kid" rating for score > 800 and <= 2000', () => {
                test.assertEqual(ScoringSystem.getRating(801), 'Rowdy Kid');
                test.assertEqual(ScoringSystem.getRating(1500), 'Rowdy Kid');
                test.assertEqual(ScoringSystem.getRating(2000), 'Rowdy Kid');
            });

            test.it('should return "LEGENDARY CHAOS!" rating for score > 10000', () => {
                test.assertEqual(ScoringSystem.getRating(10001), 'LEGENDARY CHAOS!');
                test.assertEqual(ScoringSystem.getRating(50000), 'LEGENDARY CHAOS!');
            });
        });

        // Game State Machine Tests
        test.describe('Game State Machine', () => {
            test.beforeEach(() => {
                GameStateMachine.reset();
            });

            test.it('should start in MENU state', () => {
                test.assertEqual(GameStateMachine.getState(), 'MENU');
            });

            test.it('should allow transition from MENU to PLAYING', () => {
                test.assertTrue(GameStateMachine.startGame());
                test.assertEqual(GameStateMachine.getState(), 'PLAYING');
            });

            test.it('should allow transition from PLAYING to PAUSED', () => {
                GameStateMachine.startGame();
                test.assertTrue(GameStateMachine.pauseGame());
                test.assertEqual(GameStateMachine.getState(), 'PAUSED');
            });

            test.it('should allow transition from PAUSED to PLAYING', () => {
                GameStateMachine.startGame();
                GameStateMachine.pauseGame();
                test.assertTrue(GameStateMachine.resumeGame());
                test.assertEqual(GameStateMachine.getState(), 'PLAYING');
            });

            test.it('should reject invalid state transition from MENU to PAUSED', () => {
                test.assertFalse(GameStateMachine.pauseGame());
                test.assertEqual(GameStateMachine.getState(), 'MENU');
            });

            test.it('should reject invalid state transition from MENU to GAME_OVER', () => {
                test.assertFalse(GameStateMachine.endGame());
                test.assertEqual(GameStateMachine.getState(), 'MENU');
            });

            test.it('should validate known game states', () => {
                test.assertTrue(GameStateMachine.isValidState('MENU'));
                test.assertTrue(GameStateMachine.isValidState('PLAYING'));
                test.assertTrue(GameStateMachine.isValidState('PAUSED'));
                test.assertTrue(GameStateMachine.isValidState('GAME_OVER'));
            });

            test.it('should reject unknown game states', () => {
                test.assertFalse(GameStateMachine.isValidState('INVALID'));
                test.assertFalse(GameStateMachine.isValidState(''));
                test.assertFalse(GameStateMachine.isValidState(null));
            });
        });

        // Cooldown System Tests
        test.describe('Cooldown System', () => {
            test.beforeEach(() => {
                CooldownSystem.reset();
            });

            test.it('should allow shooting when cooldown has elapsed', () => {
                test.assertTrue(CooldownSystem.canShoot(1000));
            });

            test.it('should prevent shooting during cooldown period', () => {
                CooldownSystem.shoot(1000);
                test.assertFalse(CooldownSystem.canShoot(1200)); // Only 200ms elapsed
                test.assertFalse(CooldownSystem.canShoot(1499)); // 499ms elapsed
            });

            test.it('should allow shooting after cooldown expires', () => {
                CooldownSystem.shoot(1000);
                test.assertTrue(CooldownSystem.canShoot(1500)); // Exactly 500ms
                test.assertTrue(CooldownSystem.canShoot(2000)); // 1000ms elapsed
            });

            test.it('should return correct cooldown progress', () => {
                CooldownSystem.shoot(1000);
                test.assertEqual(CooldownSystem.getCooldownProgress(1000), 0);
                test.assertEqual(CooldownSystem.getCooldownProgress(1250), 0.5);
                test.assertEqual(CooldownSystem.getCooldownProgress(1500), 1);
                test.assertEqual(CooldownSystem.getCooldownProgress(2000), 1); // Capped at 1
            });

            test.it('should return correct remaining cooldown time', () => {
                CooldownSystem.shoot(1000);
                test.assertEqual(CooldownSystem.getRemainingCooldown(1000), 500);
                test.assertEqual(CooldownSystem.getRemainingCooldown(1250), 250);
                test.assertEqual(CooldownSystem.getRemainingCooldown(1500), 0);
            });
        });

        // Collision Detection Tests
        test.describe('Collision Detection', () => {
            test.it('should calculate correct distance between two points', () => {
                const pos1 = { x: 0, y: 0, z: 0 };
                const pos2 = { x: 3, y: 4, z: 0 };
                test.assertEqual(CollisionDetection.distanceBetween(pos1, pos2), 5);
            });

            test.it('should detect hit when within radius', () => {
                const projectile = { x: 0, y: 0, z: 0 };
                const target = { x: 1, y: 0, z: 0 };
                test.assertTrue(CollisionDetection.checkHit(projectile, target, 2));
            });

            test.it('should not detect hit when outside radius', () => {
                const projectile = { x: 0, y: 0, z: 0 };
                const target = { x: 5, y: 0, z: 0 };
                test.assertFalse(CollisionDetection.checkHit(projectile, target, 2));
            });

            test.it('should return correct enemy hit radius (2 units)', () => {
                test.assertEqual(CollisionDetection.getEnemyHitRadius(), 2);
            });

            test.it('should calculate obstacle hit radius as 70% of width', () => {
                test.assertCloseTo(CollisionDetection.getObstacleHitRadius(3), 2.1);
                test.assertCloseTo(CollisionDetection.getObstacleHitRadius(1.5), 1.05);
            });

            test.it('should correctly determine if projectile is in bounds', () => {
                const bounds = { maxDistance: 200, maxX: 20, minY: 0, maxY: 15 };

                // In bounds
                const inBounds = { x: 5, y: 5, z: -50 };
                test.assertTrue(CollisionDetection.isProjectileInBounds(inBounds, 0, bounds));

                // Out of bounds (too far)
                const tooFar = { x: 0, y: 5, z: -250 };
                test.assertFalse(CollisionDetection.isProjectileInBounds(tooFar, 0, bounds));

                // Out of bounds (too wide)
                const tooWide = { x: 25, y: 5, z: -50 };
                test.assertFalse(CollisionDetection.isProjectileInBounds(tooWide, 0, bounds));
            });
        });

        // Spawn System Tests
        test.describe('Spawn System', () => {
            test.it('should allow enemy spawn when under limit', () => {
                test.assertTrue(SpawnSystem.canSpawnEnemy(5));
                test.assertTrue(SpawnSystem.canSpawnEnemy(9));
            });

            test.it('should prevent enemy spawn when at limit', () => {
                test.assertFalse(SpawnSystem.canSpawnEnemy(10));
                test.assertFalse(SpawnSystem.canSpawnEnemy(15));
            });

            test.it('should allow obstacle spawn when under limit', () => {
                test.assertTrue(SpawnSystem.canSpawnObstacle(10));
                test.assertTrue(SpawnSystem.canSpawnObstacle(14));
            });

            test.it('should prevent obstacle spawn when at limit', () => {
                test.assertFalse(SpawnSystem.canSpawnObstacle(15));
                test.assertFalse(SpawnSystem.canSpawnObstacle(20));
            });

            test.it('should calculate spawn X position within range', () => {
                // Run multiple times to test randomness bounds
                for (let i = 0; i < 100; i++) {
                    const x = SpawnSystem.calculateSpawnX(16);
                    test.assertInRange(x, -8, 8);
                }
            });

            test.it('should calculate correct spawn Z position', () => {
                test.assertEqual(SpawnSystem.calculateSpawnZ(0, 150), -150);
                test.assertEqual(SpawnSystem.calculateSpawnZ(-100, 150), -250);
            });

            test.it('should return valid obstacle type', () => {
                const validTypes = ['stack', 'barrel', 'display'];
                for (let i = 0; i < 50; i++) {
                    const type = SpawnSystem.getRandomObstacleType();
                    test.assertTrue(validTypes.includes(type), `Invalid type: ${type}`);
                }
            });
        });

        // Spawn Collision Validation Tests
        test.describe('Spawn Collision Validation', () => {
            const SpawnCollision = {
                ROOM_SIZE: 30,
                WALL_MARGIN: 4,
                CENTER_MARGIN: 4,
                DOOR_WIDTH: 8,

                isValidPosition(x, z, roomCenterX, roomCenterZ, doors = [], existingPositions = []) {
                    const roomMinX = roomCenterX - this.ROOM_SIZE / 2;
                    const roomMaxX = roomCenterX + this.ROOM_SIZE / 2;
                    const roomMinZ = roomCenterZ - this.ROOM_SIZE / 2;
                    const roomMaxZ = roomCenterZ + this.ROOM_SIZE / 2;

                    // Check center clearance
                    const centerDist = Math.sqrt(
                        Math.pow(x - roomCenterX, 2) + Math.pow(z - roomCenterZ, 2)
                    );
                    if (centerDist < this.CENTER_MARGIN) return false;

                    // Check wall clearance
                    if (x < roomMinX + this.WALL_MARGIN) return false;
                    if (x > roomMaxX - this.WALL_MARGIN) return false;
                    if (z < roomMinZ + this.WALL_MARGIN) return false;
                    if (z > roomMaxZ - this.WALL_MARGIN) return false;

                    // Check door clearance
                    const doorHalf = this.DOOR_WIDTH / 2 + 2;
                    if (doors.includes('north') && z < roomMinZ + 5 && Math.abs(x - roomCenterX) < doorHalf) return false;
                    if (doors.includes('south') && z > roomMaxZ - 5 && Math.abs(x - roomCenterX) < doorHalf) return false;

                    // Check existing positions
                    for (const pos of existingPositions) {
                        const dist = Math.sqrt(Math.pow(x - pos.x, 2) + Math.pow(z - pos.z, 2));
                        if (dist < 3) return false;
                    }

                    return true;
                }
            };

            test.it('should reject positions too close to room center', () => {
                test.assertFalse(SpawnCollision.isValidPosition(45, 75, 45, 75)); // Exact center
                test.assertFalse(SpawnCollision.isValidPosition(46, 75, 45, 75)); // 1 unit away
            });

            test.it('should reject positions too close to walls', () => {
                // Room center at (45, 75), room extends from (30, 60) to (60, 90)
                test.assertFalse(SpawnCollision.isValidPosition(32, 75, 45, 75)); // Near west wall
                test.assertFalse(SpawnCollision.isValidPosition(58, 75, 45, 75)); // Near east wall
                test.assertFalse(SpawnCollision.isValidPosition(45, 62, 45, 75)); // Near north wall
                test.assertFalse(SpawnCollision.isValidPosition(45, 88, 45, 75)); // Near south wall
            });

            test.it('should accept valid positions away from walls and center', () => {
                // Valid positions (not too close to walls or center)
                test.assertTrue(SpawnCollision.isValidPosition(38, 70, 45, 75)); // Southwest area
                test.assertTrue(SpawnCollision.isValidPosition(52, 80, 45, 75)); // Northeast area
            });

            test.it('should reject positions near doorways', () => {
                // Position near north door
                test.assertFalse(SpawnCollision.isValidPosition(45, 62, 45, 75, ['north']));
                // Position near south door
                test.assertFalse(SpawnCollision.isValidPosition(45, 88, 45, 75, ['south']));
            });

            test.it('should reject positions overlapping existing spawns', () => {
                const existing = [{ x: 40, z: 70 }];
                test.assertFalse(SpawnCollision.isValidPosition(41, 70, 45, 75, [], existing)); // Too close
                test.assertTrue(SpawnCollision.isValidPosition(50, 80, 45, 75, [], existing));  // Far enough
            });
        });

        // Adjacent Room Pre-Spawning Tests
        test.describe('Adjacent Room Pre-Spawning', () => {
            // Simulated room structure for testing getAdjacentRooms logic
            const RoomConnectivity = {
                // Simulates door-based room connectivity
                getAdjacentRooms(room, allRooms) {
                    const adjacent = [];
                    const doors = room.doors || [];

                    if (doors.includes('north')) {
                        const adj = allRooms.find(r => r.gridX === room.gridX && r.gridZ === room.gridZ - 1);
                        if (adj) adjacent.push(adj);
                    }
                    if (doors.includes('south')) {
                        const adj = allRooms.find(r => r.gridX === room.gridX && r.gridZ === room.gridZ + 1);
                        if (adj) adjacent.push(adj);
                    }
                    if (doors.includes('west')) {
                        const adj = allRooms.find(r => r.gridX - 1 === room.gridX && r.gridZ === room.gridZ);
                        if (adj) adjacent.push(adj);
                    }
                    if (doors.includes('east')) {
                        const adj = allRooms.find(r => r.gridX + 1 === room.gridX && r.gridZ === room.gridZ);
                        if (adj) adjacent.push(adj);
                    }

                    return adjacent;
                }
            };

            test.it('should find adjacent room to the north', () => {
                const rooms = [
                    { gridX: 1, gridZ: 1, doors: ['north'] },
                    { gridX: 1, gridZ: 0, doors: ['south'] }
                ];
                const adjacent = RoomConnectivity.getAdjacentRooms(rooms[0], rooms);
                test.assertEqual(adjacent.length, 1);
                test.assertEqual(adjacent[0].gridZ, 0);
            });

            test.it('should find multiple adjacent rooms', () => {
                const rooms = [
                    { gridX: 1, gridZ: 1, doors: ['north', 'south'] },
                    { gridX: 1, gridZ: 0, doors: ['south'] },
                    { gridX: 1, gridZ: 2, doors: ['north'] }
                ];
                const adjacent = RoomConnectivity.getAdjacentRooms(rooms[0], rooms);
                test.assertEqual(adjacent.length, 2);
            });

            test.it('should return empty array for room with no doors', () => {
                const rooms = [
                    { gridX: 1, gridZ: 1, doors: [] }
                ];
                const adjacent = RoomConnectivity.getAdjacentRooms(rooms[0], rooms);
                test.assertEqual(adjacent.length, 0);
            });

            test.it('should not find room if door has no connected room', () => {
                const rooms = [
                    { gridX: 1, gridZ: 1, doors: ['north'] }
                    // No room at gridZ: 0
                ];
                const adjacent = RoomConnectivity.getAdjacentRooms(rooms[0], rooms);
                test.assertEqual(adjacent.length, 0);
            });
        });

        // Skeleton Enemy Model Tests
        test.describe('Skeleton Enemy Model Structure', () => {
            // Tests for skeleton enemy model creation expectations
            const SkeletonModelSpec = {
                requiredParts: ['skull', 'eyes', 'spine', 'ribcage', 'arms', 'legs', 'cart'],

                hasRequiredGeometry(enemyGroup) {
                    if (!enemyGroup || !enemyGroup.children) return false;
                    // Should have multiple child groups (cart basket + skeleton)
                    return enemyGroup.children.length >= 2;
                },

                hasEnemyUserData(enemyGroup) {
                    if (!enemyGroup || !enemyGroup.userData) return false;
                    const ud = enemyGroup.userData;
                    return typeof ud.health === 'number' &&
                           typeof ud.active === 'boolean' &&
                           typeof ud.driftSpeed === 'number';
                }
            };

            test.it('should require minimum child groups for skeleton model', () => {
                const mockEnemy = { children: [{}, {}] };  // Cart + Skeleton groups
                test.assertTrue(SkeletonModelSpec.hasRequiredGeometry(mockEnemy));
            });

            test.it('should reject enemy with insufficient structure', () => {
                const mockEnemy = { children: [{}] };  // Only one group
                test.assertFalse(SkeletonModelSpec.hasRequiredGeometry(mockEnemy));
            });

            test.it('should validate enemy userData structure', () => {
                const validEnemy = {
                    userData: { health: 3, active: true, driftSpeed: 0.5, driftTimer: 0 }
                };
                test.assertTrue(SkeletonModelSpec.hasEnemyUserData(validEnemy));
            });

            test.it('should reject enemy without proper userData', () => {
                const invalidEnemy = { userData: { health: 3 } };  // Missing active
                test.assertFalse(SkeletonModelSpec.hasEnemyUserData(invalidEnemy));
            });
        });

        // Shelf Design Tests
        test.describe('Shelf Design Structure', () => {
            const ShelfSpec = {
                SHELF_LEVELS: 4,
                PRODUCTS_PER_SHELF: 5,

                // Validate shelf has proper structure
                hasValidStructure(shelfGroup) {
                    if (!shelfGroup || !shelfGroup.children) return false;
                    // Should have frame, shelves, and products
                    return shelfGroup.children.length >= 5;  // Frame pieces + shelf boards
                },

                // Validate shelf has products
                hasProducts(shelfGroup) {
                    if (!shelfGroup || !shelfGroup.children) return false;
                    // Count children that are small enough to be products
                    let productCount = 0;
                    for (const child of shelfGroup.children) {
                        if (child.scale && child.scale.x < 0.5) productCount++;
                    }
                    return productCount > 0;
                }
            };

            test.it('should have 4 shelf levels defined', () => {
                test.assertEqual(ShelfSpec.SHELF_LEVELS, 4);
            });

            test.it('should have products per shelf defined', () => {
                test.assertTrue(ShelfSpec.PRODUCTS_PER_SHELF >= 3);
            });

            test.it('should validate shelf has minimum structure', () => {
                const mockShelf = {
                    children: [{}, {}, {}, {}, {}, {}]  // Frame + shelves + products
                };
                test.assertTrue(ShelfSpec.hasValidStructure(mockShelf));
            });

            test.it('should reject shelf with insufficient structure', () => {
                const mockShelf = { children: [{}, {}] };
                test.assertFalse(ShelfSpec.hasValidStructure(mockShelf));
            });
        });

        // Safe Room Tests
        test.describe('Safe Starting Room', () => {
            const SAFE_ROOM = { gridX: 1, gridZ: 2 };

            function isRoomSafe(room) {
                return room.gridX === SAFE_ROOM.gridX && room.gridZ === SAFE_ROOM.gridZ;
            }

            test.it('should identify starting room (1,2) as safe', () => {
                test.assertTrue(isRoomSafe({ gridX: 1, gridZ: 2 }));
            });

            test.it('should not mark other rooms as safe', () => {
                test.assertFalse(isRoomSafe({ gridX: 0, gridZ: 2 }));
                test.assertFalse(isRoomSafe({ gridX: 1, gridZ: 1 }));
                test.assertFalse(isRoomSafe({ gridX: 2, gridZ: 2 }));
            });
        });

        // Line of Sight Tests
        test.describe('Enemy Line of Sight', () => {
            // Simulated line of sight logic
            function canSeePlayer(enemyRoom, playerRoom) {
                if (!enemyRoom || !playerRoom) return false;

                // Same room = clear LOS
                if (enemyRoom.gridX === playerRoom.gridX && enemyRoom.gridZ === playerRoom.gridZ) {
                    return true;
                }

                // Check if adjacent and has door
                const dx = playerRoom.gridX - enemyRoom.gridX;
                const dz = playerRoom.gridZ - enemyRoom.gridZ;

                if (Math.abs(dx) + Math.abs(dz) !== 1) return false;

                const doors = enemyRoom.doors || [];
                if (dx === 1 && doors.includes('east')) return true;
                if (dx === -1 && doors.includes('west')) return true;
                if (dz === 1 && doors.includes('south')) return true;
                if (dz === -1 && doors.includes('north')) return true;

                return false;
            }

            test.it('should have LOS in same room', () => {
                const room = { gridX: 1, gridZ: 1, doors: [] };
                test.assertTrue(canSeePlayer(room, room));
            });

            test.it('should have LOS through door to adjacent room', () => {
                const enemyRoom = { gridX: 1, gridZ: 1, doors: ['east'] };
                const playerRoom = { gridX: 2, gridZ: 1, doors: ['west'] };
                test.assertTrue(canSeePlayer(enemyRoom, playerRoom));
            });

            test.it('should NOT have LOS without door', () => {
                const enemyRoom = { gridX: 1, gridZ: 1, doors: [] };
                const playerRoom = { gridX: 2, gridZ: 1, doors: ['west'] };
                test.assertFalse(canSeePlayer(enemyRoom, playerRoom));
            });

            test.it('should NOT have LOS to non-adjacent room', () => {
                const enemyRoom = { gridX: 1, gridZ: 1, doors: ['east', 'west', 'north', 'south'] };
                const playerRoom = { gridX: 3, gridZ: 1, doors: [] };
                test.assertFalse(canSeePlayer(enemyRoom, playerRoom));
            });
        });

        // Collision Push-back Tests
        test.describe('Collision Push-back System', () => {
            function calculatePushBack(playerPos, obstaclePos, playerRadius, obstacleRadius) {
                const dx = playerPos.x - obstaclePos.x;
                const dz = playerPos.z - obstaclePos.z;
                const dist = Math.sqrt(dx * dx + dz * dz);
                const minDist = playerRadius + obstacleRadius;

                if (dist >= minDist || dist === 0) {
                    return { x: 0, z: 0, collided: false };
                }

                const pushX = (dx / dist) * (minDist - dist);
                const pushZ = (dz / dist) * (minDist - dist);
                return { x: pushX, z: pushZ, collided: true };
            }

            test.it('should push player away when overlapping enemy', () => {
                const playerPos = { x: 5, z: 5 };
                const enemyPos = { x: 5.5, z: 5 };
                const result = calculatePushBack(playerPos, enemyPos, 1.8, 2.0);
                test.assertTrue(result.collided);
                test.assertTrue(result.x < 0); // Push left (away from enemy)
            });

            test.it('should not push when distance is sufficient', () => {
                const playerPos = { x: 0, z: 0 };
                const enemyPos = { x: 10, z: 0 };
                const result = calculatePushBack(playerPos, enemyPos, 1.8, 2.0);
                test.assertFalse(result.collided);
            });

            test.it('should calculate correct push direction', () => {
                const playerPos = { x: 0, z: 0 };
                const obstaclePos = { x: 1, z: 0 };
                const result = calculatePushBack(playerPos, obstaclePos, 1.5, 1.5);
                test.assertTrue(result.collided);
                test.assertTrue(result.x < 0); // Push in -X direction
                test.assertTrue(Math.abs(result.z) < 0.01); // No Z push
            });
        });

        // Object Cleanup Tests
        test.describe('Object Cleanup', () => {
            test.it('should detect object behind camera', () => {
                test.assertTrue(ObjectCleanup.isObjectBehindCamera(30, 0, 20));
                test.assertTrue(ObjectCleanup.isObjectBehindCamera(25, 0, 20));
            });

            test.it('should not flag object ahead of camera', () => {
                test.assertFalse(ObjectCleanup.isObjectBehindCamera(-50, 0, 20));
                test.assertFalse(ObjectCleanup.isObjectBehindCamera(10, 0, 20));
            });

            test.it('should detect dead particles (life <= 0)', () => {
                test.assertTrue(ObjectCleanup.isParticleDead({ life: 0 }));
                test.assertTrue(ObjectCleanup.isParticleDead({ life: -0.5 }));
            });

            test.it('should not flag living particles', () => {
                test.assertFalse(ObjectCleanup.isParticleDead({ life: 0.5 }));
                test.assertFalse(ObjectCleanup.isParticleDead({ life: 1 }));
            });

            test.it('should filter to only active objects', () => {
                const objects = [
                    { id: 1, active: true },
                    { id: 2, active: false },
                    { id: 3, active: true },
                    { id: 4, active: false }
                ];
                const active = ObjectCleanup.filterActiveObjects(objects);
                test.assertEqual(active.length, 2);
                test.assertEqual(active[0].id, 1);
                test.assertEqual(active[1].id, 3);
            });

            test.it('should count active objects correctly', () => {
                const objects = [
                    { active: true },
                    { active: false },
                    { active: true },
                    { active: true }
                ];
                test.assertEqual(ObjectCleanup.countActiveObjects(objects), 3);
            });

            test.it('should mark object for removal by setting active to false', () => {
                const obj = { active: true, data: 'test' };
                ObjectCleanup.markForRemoval(obj);
                test.assertFalse(obj.active);
            });
        });

        // Health System Tests
        test.describe('Health System', () => {
            test.it('should create enemy with full health', () => {
                const enemy = HealthSystem.createEnemy();
                test.assertEqual(enemy.health, 3);
                test.assertTrue(enemy.active);
            });

            test.it('should reduce enemy health on damage', () => {
                const enemy = HealthSystem.createEnemy();
                HealthSystem.damageEnemy(enemy, 1);
                test.assertEqual(enemy.health, 2);
            });

            test.it('should trigger hit flash on damage', () => {
                const enemy = HealthSystem.createEnemy();
                HealthSystem.damageEnemy(enemy, 1);
                test.assertEqual(enemy.hitFlash, 1);
            });

            test.it('should destroy enemy at 0 health', () => {
                const enemy = HealthSystem.createEnemy();
                HealthSystem.damageEnemy(enemy, 3);
                test.assertEqual(enemy.health, 0);
                test.assertFalse(enemy.active);
            });

            test.it('should correctly report enemy alive status', () => {
                const enemy = HealthSystem.createEnemy();
                test.assertTrue(HealthSystem.isEnemyAlive(enemy));

                HealthSystem.damageEnemy(enemy, 3);
                test.assertFalse(HealthSystem.isEnemyAlive(enemy));
            });

            test.it('should calculate correct health percentage', () => {
                const enemy = HealthSystem.createEnemy();
                test.assertEqual(HealthSystem.getHealthPercentage(enemy), 1);

                HealthSystem.damageEnemy(enemy, 1);
                test.assertInRange(HealthSystem.getHealthPercentage(enemy), 0.66, 0.67);

                HealthSystem.damageEnemy(enemy, 1);
                test.assertInRange(HealthSystem.getHealthPercentage(enemy), 0.33, 0.34);
            });

            test.it('should not damage inactive enemies', () => {
                const enemy = HealthSystem.createEnemy();
                enemy.active = false;
                enemy.health = 3;

                HealthSystem.damageEnemy(enemy, 1);
                test.assertEqual(enemy.health, 3); // Health unchanged
            });
        });

        // Player Movement System Tests
        test.describe('Player Movement System', () => {
            test.beforeEach(() => {
                PlayerMovementSystem.reset();
            });

            test.it('should calculate lateral movement speed as 8 units/sec', () => {
                test.assertEqual(PlayerMovementSystem.getLateralSpeed(), 8);
            });

            test.it('should apply speed boost multiplier (1.5x)', () => {
                const baseSpeed = PlayerMovementSystem.getLateralSpeed();
                const boostedSpeed = PlayerMovementSystem.getSpeedWithBoost();
                test.assertEqual(boostedSpeed, baseSpeed * 1.5);
                test.assertEqual(boostedSpeed, 12);
            });

            test.it('should apply slow down multiplier (0.5x)', () => {
                const baseSpeed = PlayerMovementSystem.getLateralSpeed();
                const slowedSpeed = PlayerMovementSystem.getSpeedWithSlowdown();
                test.assertEqual(slowedSpeed, baseSpeed * 0.5);
                test.assertEqual(slowedSpeed, 4);
            });

            test.it('should clamp movement within bounds (+-10 units)', () => {
                // Test left bound
                test.assertEqual(PlayerMovementSystem.clampPosition(-15), -10);
                test.assertEqual(PlayerMovementSystem.clampPosition(-10), -10);

                // Test right bound
                test.assertEqual(PlayerMovementSystem.clampPosition(15), 10);
                test.assertEqual(PlayerMovementSystem.clampPosition(10), 10);

                // Test within bounds
                test.assertEqual(PlayerMovementSystem.clampPosition(5), 5);
                test.assertEqual(PlayerMovementSystem.clampPosition(-5), -5);
                test.assertEqual(PlayerMovementSystem.clampPosition(0), 0);
            });

            test.it('should only allow movement in PLAYING state', () => {
                test.assertTrue(PlayerMovementSystem.canMove('PLAYING'));
                test.assertFalse(PlayerMovementSystem.canMove('MENU'));
                test.assertFalse(PlayerMovementSystem.canMove('PAUSED'));
                test.assertFalse(PlayerMovementSystem.canMove('GAME_OVER'));
            });

            test.it('should stop movement when not pressing keys', () => {
                const velocity = PlayerMovementSystem.calculateVelocity(false, false);
                test.assertEqual(velocity, 0);
            });

            test.it('should move left when pressing left key', () => {
                const velocity = PlayerMovementSystem.calculateVelocity(true, false);
                test.assertEqual(velocity, -8);
            });

            test.it('should move right when pressing right key', () => {
                const velocity = PlayerMovementSystem.calculateVelocity(false, true);
                test.assertEqual(velocity, 8);
            });

            test.it('should cancel out movement when pressing both keys', () => {
                const velocity = PlayerMovementSystem.calculateVelocity(true, true);
                test.assertEqual(velocity, 0);
            });
        });

        // Player Health System Tests
        test.describe('Player Health System', () => {
            test.beforeEach(() => {
                PlayerHealthSystem.reset();
            });

            test.it('should have initial health of 100', () => {
                test.assertEqual(PlayerHealthSystem.getHealth(), 100);
            });

            test.it('should apply enemy collision damage (20 HP)', () => {
                PlayerHealthSystem.applyEnemyCollisionDamage();
                test.assertEqual(PlayerHealthSystem.getHealth(), 80);
            });

            test.it('should apply obstacle collision damage (10 HP)', () => {
                PlayerHealthSystem.applyObstacleCollisionDamage();
                test.assertEqual(PlayerHealthSystem.getHealth(), 90);
            });

            test.it('should not allow health to go below 0', () => {
                // Apply enough damage to potentially go negative
                for (let i = 0; i < 10; i++) {
                    PlayerHealthSystem.applyEnemyCollisionDamage();
                }
                test.assertEqual(PlayerHealthSystem.getHealth(), 0);
                test.assertFalse(PlayerHealthSystem.getHealth() < 0);
            });

            test.it('should activate invulnerability timer (1 second) after taking damage', () => {
                const currentTime = 1000;
                PlayerHealthSystem.applyDamage(20, currentTime);
                test.assertTrue(PlayerHealthSystem.isInvulnerable(currentTime + 500));
                test.assertEqual(PlayerHealthSystem.getInvulnerabilityDuration(), 1000);
            });

            test.it('should block damage during invulnerability', () => {
                const currentTime = 1000;
                PlayerHealthSystem.applyDamage(20, currentTime);
                test.assertEqual(PlayerHealthSystem.getHealth(), 80);

                // Try to apply damage during invulnerability
                PlayerHealthSystem.applyDamage(20, currentTime + 500);
                test.assertEqual(PlayerHealthSystem.getHealth(), 80); // Health unchanged
            });

            test.it('should expire invulnerability after 1 second', () => {
                const currentTime = 1000;
                PlayerHealthSystem.applyDamage(20, currentTime);

                // Check invulnerable during the window
                test.assertTrue(PlayerHealthSystem.isInvulnerable(currentTime + 500));
                test.assertTrue(PlayerHealthSystem.isInvulnerable(currentTime + 999));

                // Check no longer invulnerable after 1 second
                test.assertFalse(PlayerHealthSystem.isInvulnerable(currentTime + 1000));
                test.assertFalse(PlayerHealthSystem.isInvulnerable(currentTime + 1500));
            });

            test.it('should trigger death condition when health <= 0', () => {
                test.assertFalse(PlayerHealthSystem.isDead());

                // Reduce health to 0
                for (let i = 0; i < 5; i++) {
                    PlayerHealthSystem.health -= 20;
                }
                PlayerHealthSystem.health = Math.max(0, PlayerHealthSystem.health);

                test.assertTrue(PlayerHealthSystem.isDead());
            });

            test.it('should calculate health percentage correctly', () => {
                test.assertEqual(PlayerHealthSystem.getHealthPercentage(), 100);

                PlayerHealthSystem.health = 50;
                test.assertEqual(PlayerHealthSystem.getHealthPercentage(), 50);

                PlayerHealthSystem.health = 25;
                test.assertEqual(PlayerHealthSystem.getHealthPercentage(), 25);

                PlayerHealthSystem.health = 0;
                test.assertEqual(PlayerHealthSystem.getHealthPercentage(), 0);
            });
        });

        // Camera Mode System Tests
        test.describe('Camera Mode System', () => {
            const CameraModeSystem = {
                currentMode: 'hybrid-fps',
                validModes: ['hybrid-fps', 'third-person'],

                setMode(mode) {
                    if (this.validModes.includes(mode)) {
                        this.currentMode = mode;
                        return true;
                    }
                    return false;
                },

                getMode() {
                    return this.currentMode;
                },

                isFPS() {
                    return this.currentMode === 'hybrid-fps';
                },

                isThirdPerson() {
                    return this.currentMode === 'third-person';
                },

                reset() {
                    this.currentMode = 'hybrid-fps';
                }
            };

            test.beforeEach(() => {
                CameraModeSystem.reset();
            });

            test.it('should default to FPS mode', () => {
                test.assertEqual(CameraModeSystem.getMode(), 'hybrid-fps');
                test.assertTrue(CameraModeSystem.isFPS());
            });

            test.it('should switch to third-person mode', () => {
                CameraModeSystem.setMode('third-person');
                test.assertEqual(CameraModeSystem.getMode(), 'third-person');
                test.assertTrue(CameraModeSystem.isThirdPerson());
                test.assertFalse(CameraModeSystem.isFPS());
            });

            test.it('should switch back to FPS mode', () => {
                CameraModeSystem.setMode('third-person');
                CameraModeSystem.setMode('hybrid-fps');
                test.assertTrue(CameraModeSystem.isFPS());
            });

            test.it('should reject invalid camera modes', () => {
                const result = CameraModeSystem.setMode('invalid-mode');
                test.assertFalse(result);
                test.assertEqual(CameraModeSystem.getMode(), 'hybrid-fps');
            });
        });

        // FPS Weapon System Tests
        test.describe('FPS Weapon System', () => {
            const FPSWeaponSystem = {
                visible: false,
                fireAnimProgress: 0,
                FIRE_ANIM_DURATION: 1.0,
                FIRE_ANIM_SPEED: 4,

                show() {
                    this.visible = true;
                },

                hide() {
                    this.visible = false;
                },

                isVisible() {
                    return this.visible;
                },

                startFireAnimation() {
                    this.fireAnimProgress = this.FIRE_ANIM_DURATION;
                },

                updateAnimation(dt) {
                    if (this.fireAnimProgress > 0) {
                        this.fireAnimProgress -= dt * this.FIRE_ANIM_SPEED;
                        if (this.fireAnimProgress < 0) {
                            this.fireAnimProgress = 0;
                        }
                    }
                },

                isAnimating() {
                    return this.fireAnimProgress > 0;
                },

                getAnimProgress() {
                    return this.fireAnimProgress;
                },

                // Calculate pull-back amount for rubber bands
                getPullBack() {
                    if (this.fireAnimProgress <= 0) return 0;
                    // Pull back peaks at 0.5, then releases
                    return this.fireAnimProgress > 0.5
                        ? (1 - this.fireAnimProgress) * 2
                        : this.fireAnimProgress * 2;
                },

                reset() {
                    this.visible = false;
                    this.fireAnimProgress = 0;
                }
            };

            test.beforeEach(() => {
                FPSWeaponSystem.reset();
            });

            test.it('should be hidden by default', () => {
                test.assertFalse(FPSWeaponSystem.isVisible());
            });

            test.it('should show weapon when show() is called', () => {
                FPSWeaponSystem.show();
                test.assertTrue(FPSWeaponSystem.isVisible());
            });

            test.it('should hide weapon when hide() is called', () => {
                FPSWeaponSystem.show();
                FPSWeaponSystem.hide();
                test.assertFalse(FPSWeaponSystem.isVisible());
            });

            test.it('should start fire animation at full progress', () => {
                FPSWeaponSystem.startFireAnimation();
                test.assertEqual(FPSWeaponSystem.getAnimProgress(), 1.0);
                test.assertTrue(FPSWeaponSystem.isAnimating());
            });

            test.it('should decrease animation progress over time', () => {
                FPSWeaponSystem.startFireAnimation();
                FPSWeaponSystem.updateAnimation(0.1); // 0.1 seconds
                test.assertTrue(FPSWeaponSystem.getAnimProgress() < 1.0);
                test.assertTrue(FPSWeaponSystem.isAnimating());
            });

            test.it('should complete animation and stop', () => {
                FPSWeaponSystem.startFireAnimation();
                // Run enough updates to complete animation
                for (let i = 0; i < 10; i++) {
                    FPSWeaponSystem.updateAnimation(0.1);
                }
                test.assertEqual(FPSWeaponSystem.getAnimProgress(), 0);
                test.assertFalse(FPSWeaponSystem.isAnimating());
            });

            test.it('should calculate pull-back correctly during animation', () => {
                FPSWeaponSystem.startFireAnimation();
                // At progress 1.0, pull-back should be 0 (just started)
                test.assertEqual(FPSWeaponSystem.getPullBack(), 0);

                // At progress 0.5, pull-back should be at maximum (1.0)
                FPSWeaponSystem.fireAnimProgress = 0.5;
                test.assertEqual(FPSWeaponSystem.getPullBack(), 1.0);

                // At progress 0.25, pull-back should be 0.5 (releasing)
                FPSWeaponSystem.fireAnimProgress = 0.25;
                test.assertEqual(FPSWeaponSystem.getPullBack(), 0.5);
            });
        });

        // FPS Weapon Visibility Integration Tests
        test.describe('FPS Weapon Visibility', () => {
            const FPSWeaponVisibility = {
                cameraMode: 'hybrid-fps',
                weaponVisible: false,
                cameraHasWeaponChild: false,
                chargingTension: 0,
                bandStretch: 1.0,
                handPullBack: 0,
                stoneVisible: true,

                // Simulate what happens in game's update loop
                updateVisibility() {
                    if (this.cameraMode === 'hybrid-fps') {
                        this.weaponVisible = true;
                    } else {
                        this.weaponVisible = false;
                    }
                },

                // Simulate camera.add(fpsWeapon) setup
                setupCameraChild() {
                    this.cameraHasWeaponChild = true;
                },

                // Simulate charging animation
                updateChargingAnimation(tension) {
                    this.chargingTension = tension;
                    if (tension > 0) {
                        // Band stretches from 1.0 to 2.2 at max tension
                        this.bandStretch = 1 + tension * 1.2;
                        // Hand pulls back from 0 to 0.25 at max tension
                        this.handPullBack = tension * 0.25;
                        this.stoneVisible = true;
                    } else {
                        this.bandStretch = 1.0;
                        this.handPullBack = 0;
                        this.stoneVisible = true;
                    }
                },

                setCameraMode(mode) {
                    this.cameraMode = mode;
                    this.updateVisibility();
                },

                reset() {
                    this.cameraMode = 'hybrid-fps';
                    this.weaponVisible = false;
                    this.cameraHasWeaponChild = false;
                    this.chargingTension = 0;
                    this.bandStretch = 1.0;
                    this.handPullBack = 0;
                    this.stoneVisible = true;
                }
            };

            test.beforeEach(() => {
                FPSWeaponVisibility.reset();
            });

            test.it('should show weapon in FPS mode', () => {
                FPSWeaponVisibility.setCameraMode('hybrid-fps');
                test.assertTrue(FPSWeaponVisibility.weaponVisible, 'Weapon should be visible in FPS mode');
            });

            test.it('should hide weapon in third-person mode', () => {
                FPSWeaponVisibility.setCameraMode('third-person');
                test.assertFalse(FPSWeaponVisibility.weaponVisible, 'Weapon should be hidden in TPS mode');
            });

            test.it('should switch visibility when changing camera modes', () => {
                FPSWeaponVisibility.setCameraMode('hybrid-fps');
                test.assertTrue(FPSWeaponVisibility.weaponVisible);

                FPSWeaponVisibility.setCameraMode('third-person');
                test.assertFalse(FPSWeaponVisibility.weaponVisible);

                FPSWeaponVisibility.setCameraMode('hybrid-fps');
                test.assertTrue(FPSWeaponVisibility.weaponVisible);
            });

            test.it('should have weapon as camera child for rendering', () => {
                FPSWeaponVisibility.setupCameraChild();
                test.assertTrue(FPSWeaponVisibility.cameraHasWeaponChild, 'Weapon must be camera child to render');
            });

            test.it('should stretch bands during charging', () => {
                FPSWeaponVisibility.updateChargingAnimation(0);
                test.assertEqual(FPSWeaponVisibility.bandStretch, 1.0, 'No stretch at zero tension');

                FPSWeaponVisibility.updateChargingAnimation(0.5);
                test.assertEqual(FPSWeaponVisibility.bandStretch, 1.6, 'Half stretch at half tension');

                FPSWeaponVisibility.updateChargingAnimation(1.0);
                test.assertEqual(FPSWeaponVisibility.bandStretch, 2.2, 'Full stretch at max tension');
            });

            test.it('should pull hand back during charging', () => {
                FPSWeaponVisibility.updateChargingAnimation(0);
                test.assertEqual(FPSWeaponVisibility.handPullBack, 0, 'No pull at zero tension');

                FPSWeaponVisibility.updateChargingAnimation(0.5);
                test.assertCloseTo(FPSWeaponVisibility.handPullBack, 0.125, 0.01, 'Half pull at half tension');

                FPSWeaponVisibility.updateChargingAnimation(1.0);
                test.assertEqual(FPSWeaponVisibility.handPullBack, 0.25, 'Full pull at max tension');
            });

            test.it('should show stone during charging', () => {
                FPSWeaponVisibility.updateChargingAnimation(0.5);
                test.assertTrue(FPSWeaponVisibility.stoneVisible, 'Stone should be visible while charging');
            });

            test.it('should reset animations when not charging', () => {
                // First charge up
                FPSWeaponVisibility.updateChargingAnimation(1.0);
                test.assertEqual(FPSWeaponVisibility.bandStretch, 2.2);
                test.assertEqual(FPSWeaponVisibility.handPullBack, 0.25);

                // Then reset to zero
                FPSWeaponVisibility.updateChargingAnimation(0);
                test.assertEqual(FPSWeaponVisibility.bandStretch, 1.0, 'Bands should reset');
                test.assertEqual(FPSWeaponVisibility.handPullBack, 0, 'Hand should reset');
            });
        });

        // Weapon System Tests
        test.describe('Weapon System', () => {
            // Simulated weapon system matching game implementation
            const WeaponSystem = {
                WEAPONS: {
                    nerf: {
                        name: 'NERF Gun',
                        fireMode: 'auto',
                        cooldown: 120,
                        projectileSpeed: 200,  // Faster for deeper 3D feel
                    },
                    slingshot: {
                        name: 'Slingshot',
                        fireMode: 'charge',
                        cooldown: 300,
                        projectileSpeed: { min: 60, max: 180 },
                        chargeRate: 1.2,
                        minCharge: 0.2,
                        maxCharge: 1.0,
                    }
                },
                weapon: {
                    type: 'nerf',
                    isFiring: false,
                    charge: 0,
                    lastFireTime: 0,
                },

                getConfig() {
                    return this.WEAPONS[this.weapon.type];
                },

                startFiring() {
                    this.weapon.isFiring = true;
                },

                stopFiring() {
                    this.weapon.isFiring = false;
                },

                reset() {
                    this.weapon.isFiring = false;
                    this.weapon.charge = 0;
                    this.weapon.lastFireTime = 0;
                    this.weapon.type = 'nerf';
                }
            };

            test.beforeEach(() => {
                WeaponSystem.reset();
            });

            test.it('should default to NERF gun', () => {
                test.assertEqual(WeaponSystem.weapon.type, 'nerf');
                test.assertEqual(WeaponSystem.getConfig().fireMode, 'auto');
            });

            test.it('should not be firing initially', () => {
                test.assertFalse(WeaponSystem.weapon.isFiring);
            });

            test.it('should set isFiring true when startFiring called', () => {
                WeaponSystem.startFiring();
                test.assertTrue(WeaponSystem.weapon.isFiring);
            });

            test.it('should set isFiring false when stopFiring called', () => {
                WeaponSystem.startFiring();
                WeaponSystem.stopFiring();
                test.assertFalse(WeaponSystem.weapon.isFiring);
            });

            test.it('should have fixed projectile speed for NERF gun (200)', () => {
                test.assertEqual(WeaponSystem.getConfig().projectileSpeed, 200);
            });

            test.it('should have auto fire mode for NERF gun', () => {
                test.assertEqual(WeaponSystem.getConfig().fireMode, 'auto');
            });

            test.it('should have fast cooldown for NERF gun (120ms)', () => {
                test.assertEqual(WeaponSystem.getConfig().cooldown, 120);
            });

            test.it('should support slingshot config for future use', () => {
                WeaponSystem.weapon.type = 'slingshot';
                const config = WeaponSystem.getConfig();
                test.assertEqual(config.fireMode, 'charge');
                test.assertEqual(config.projectileSpeed.min, 60);
                test.assertEqual(config.projectileSpeed.max, 180);
            });

            test.it('should reset weapon state correctly', () => {
                WeaponSystem.weapon.isFiring = true;
                WeaponSystem.weapon.charge = 0.5;
                WeaponSystem.weapon.lastFireTime = 1000;
                WeaponSystem.reset();
                test.assertFalse(WeaponSystem.weapon.isFiring);
                test.assertEqual(WeaponSystem.weapon.charge, 0);
                test.assertEqual(WeaponSystem.weapon.lastFireTime, 0);
            });

            test.it('should have increased projectile speed (200 units/sec)', () => {
                test.assertEqual(WeaponSystem.getConfig().projectileSpeed, 200);
            });
        });

        // ============================================
        // PROJECTILE DIRECTION TESTS
        // ============================================

        test.describe('Projectile Direction', () => {
            test.it('should calculate forward direction from player rotation', () => {
                // When player faces forward (rotation = 0), direction should be (0, y, -1)
                const playerRotation = 0;
                const direction = {
                    x: Math.sin(playerRotation),
                    y: -0.05,
                    z: -Math.cos(playerRotation)
                };
                test.assertEqual(direction.x, 0);
                test.assertTrue(direction.z < 0); // Forward is negative Z
            });

            test.it('should calculate angled direction when player rotates', () => {
                // Player rotated 45 degrees right
                const playerRotation = Math.PI / 4;
                const direction = {
                    x: Math.sin(playerRotation),
                    y: -0.05,
                    z: -Math.cos(playerRotation)
                };
                test.assertTrue(direction.x > 0); // Moving right
                test.assertTrue(direction.z < 0); // Still forward
            });

            test.it('should normalize direction vector', () => {
                const direction = { x: 0.707, y: -0.05, z: -0.707 };
                const length = Math.sqrt(direction.x*direction.x + direction.y*direction.y + direction.z*direction.z);
                test.assertTrue(Math.abs(length - 1) < 0.1); // Should be ~1
            });
        });

        // ============================================
        // ENEMY SPAWNING TESTS
        // ============================================

        test.describe('Enemy Spawning System', () => {
            const SpawnSystem = {
                MIN_ENEMIES: 3,
                MAX_ENEMIES: 8,
                enemies: [],

                getActiveCount() {
                    return this.enemies.filter(e => e.active).length;
                },

                shouldSpawn() {
                    return this.getActiveCount() < this.MIN_ENEMIES;
                },

                canSpawn() {
                    return this.getActiveCount() < this.MAX_ENEMIES;
                },

                spawnEnemy() {
                    if (this.canSpawn()) {
                        this.enemies.push({ active: true });
                        return true;
                    }
                    return false;
                },

                destroyEnemy(index) {
                    if (this.enemies[index]) {
                        this.enemies[index].active = false;
                    }
                },

                reset() {
                    this.enemies = [];
                }
            };

            test.beforeEach(() => {
                SpawnSystem.reset();
            });

            test.it('should indicate spawn needed when below minimum', () => {
                test.assertTrue(SpawnSystem.shouldSpawn());

                // Add enemies up to minimum
                for (let i = 0; i < 3; i++) {
                    SpawnSystem.spawnEnemy();
                }
                test.assertFalse(SpawnSystem.shouldSpawn());
            });

            test.it('should allow spawning up to maximum', () => {
                for (let i = 0; i < 8; i++) {
                    test.assertTrue(SpawnSystem.spawnEnemy());
                }
                test.assertFalse(SpawnSystem.spawnEnemy()); // Should fail at max
            });

            test.it('should trigger respawn after destroying enemies', () => {
                // Spawn initial enemies
                for (let i = 0; i < 5; i++) {
                    SpawnSystem.spawnEnemy();
                }
                test.assertFalse(SpawnSystem.shouldSpawn());

                // Destroy until below minimum
                SpawnSystem.destroyEnemy(0);
                SpawnSystem.destroyEnemy(1);
                SpawnSystem.destroyEnemy(2);

                test.assertEqual(SpawnSystem.getActiveCount(), 2);
                test.assertTrue(SpawnSystem.shouldSpawn()); // Should trigger respawn
            });
        });

        // ============================================
        // SHELF ANGLING TESTS
        // ============================================

        test.describe('Shelf Angling System', () => {
            const INWARD_ANGLE = 0.35; // ~20 degrees

            test.it('should angle west wall shelves inward (positive rotation)', () => {
                const facingLeft = false;
                const rotation = facingLeft ? Math.PI - INWARD_ANGLE : INWARD_ANGLE;
                test.assertEqual(rotation, INWARD_ANGLE);
                test.assertTrue(rotation > 0);
            });

            test.it('should angle east wall shelves inward (negative from PI)', () => {
                const facingLeft = true;
                const rotation = facingLeft ? Math.PI - INWARD_ANGLE : INWARD_ANGLE;
                test.assertTrue(rotation < Math.PI);
                test.assertTrue(rotation > Math.PI / 2);
            });

            test.it('should angle north wall shelves toward center', () => {
                // Left shelf on north wall faces right-center
                const leftShelfRotation = INWARD_ANGLE;
                // Right shelf on north wall faces left-center
                const rightShelfRotation = -INWARD_ANGLE;

                test.assertTrue(leftShelfRotation > 0);
                test.assertTrue(rightShelfRotation < 0);
            });

            test.it('should angle south wall shelves toward center', () => {
                // Left shelf on south wall
                const leftShelfRotation = Math.PI - INWARD_ANGLE;
                // Right shelf on south wall
                const rightShelfRotation = Math.PI + INWARD_ANGLE;

                test.assertTrue(leftShelfRotation < Math.PI);
                test.assertTrue(rightShelfRotation > Math.PI);
            });

            test.it('should use consistent inward angle (~20 degrees)', () => {
                // 20 degrees in radians is approximately 0.35
                const twentyDegreesRad = 20 * (Math.PI / 180);
                test.assertTrue(Math.abs(INWARD_ANGLE - twentyDegreesRad) < 0.02);
            });
        });

        // ============================================
        // PROJECTILE SYSTEM TESTS
        // ============================================

        test.describe('Projectile System', () => {
            // Simulated projectile for testing
            const ProjectileSystem = {
                projectiles: [],
                cameraPosition: { x: 45, y: 2.2, z: 75 },

                createProjectile(direction, speed) {
                    const proj = {
                        position: { ...this.cameraPosition },
                        velocity: {
                            x: direction.x * speed,
                            y: direction.y * speed,
                            z: direction.z * speed
                        },
                        active: true,
                        power: speed / 180 // Normalized 0-1
                    };
                    this.projectiles.push(proj);
                    return proj;
                },

                updateProjectile(proj, dt) {
                    if (!proj.active) return;
                    proj.position.x += proj.velocity.x * dt;
                    proj.position.y += proj.velocity.y * dt;
                    proj.position.z += proj.velocity.z * dt;
                },

                isOutOfBounds(proj) {
                    const dx = proj.position.x - this.cameraPosition.x;
                    const dy = proj.position.y - this.cameraPosition.y;
                    const dz = proj.position.z - this.cameraPosition.z;
                    const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                    // Extended range (250) for deeper 3D experience
                    return dist > 250 || proj.position.y < 0 || proj.position.y > 15;
                },

                checkHit(proj, target, hitRadius) {
                    const dx = proj.position.x - target.x;
                    const dy = proj.position.y - target.y;
                    const dz = proj.position.z - target.z;
                    const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                    return dist < hitRadius;
                },

                reset() {
                    this.projectiles = [];
                    this.cameraPosition = { x: 45, y: 2.2, z: 75 };
                }
            };

            test.beforeEach(() => {
                ProjectileSystem.reset();
            });

            test.it('should create projectile with correct properties', () => {
                const direction = { x: 0, y: 0, z: -1 };
                const proj = ProjectileSystem.createProjectile(direction, 120);

                test.assertTrue(proj.active);
                test.assertEqual(proj.velocity.z, -120);
                test.assertInRange(proj.power, 0, 1);
            });

            test.it('should move projectile based on velocity', () => {
                const direction = { x: 0, y: 0, z: -1 };
                const proj = ProjectileSystem.createProjectile(direction, 100);
                const initialZ = proj.position.z;

                ProjectileSystem.updateProjectile(proj, 0.1);

                test.assertEqual(proj.position.z, initialZ - 10); // 100 * 0.1
            });

            test.it('should detect out of bounds (distance at 250 units)', () => {
                const direction = { x: 0, y: 0, z: -1 };
                const proj = ProjectileSystem.createProjectile(direction, 100);

                test.assertFalse(ProjectileSystem.isOutOfBounds(proj));

                proj.position.z = -200; // 275 units from camera at z=75 (exceeds 250 limit)
                test.assertTrue(ProjectileSystem.isOutOfBounds(proj));
            });

            test.it('should detect out of bounds (height)', () => {
                const direction = { x: 0, y: 1, z: 0 };
                const proj = ProjectileSystem.createProjectile(direction, 100);

                proj.position.y = 20;
                test.assertTrue(ProjectileSystem.isOutOfBounds(proj));

                proj.position.y = -1;
                test.assertTrue(ProjectileSystem.isOutOfBounds(proj));
            });

            test.it('should detect hit on target within radius', () => {
                const direction = { x: 0, y: 0, z: -1 };
                const proj = ProjectileSystem.createProjectile(direction, 100);

                const target = { x: 45, y: 2.2, z: 70 };
                proj.position.z = 71;

                test.assertTrue(ProjectileSystem.checkHit(proj, target, 2.5));
            });

            test.it('should not detect hit on target outside radius', () => {
                const direction = { x: 0, y: 0, z: -1 };
                const proj = ProjectileSystem.createProjectile(direction, 100);

                const target = { x: 55, y: 2.2, z: 70 }; // 10 units away on X
                proj.position.z = 70;

                test.assertFalse(ProjectileSystem.checkHit(proj, target, 2.5));
            });

            test.it('should scale power based on speed', () => {
                const direction = { x: 0, y: 0, z: -1 };

                const slowProj = ProjectileSystem.createProjectile(direction, 60);
                const fastProj = ProjectileSystem.createProjectile(direction, 180);

                test.assertTrue(fastProj.power > slowProj.power);
                test.assertInRange(slowProj.power, 0, 0.5);
                test.assertInRange(fastProj.power, 0.9, 1.1);
            });
        });

        // ============================================
        // WALL BUMP EFFECT TESTS
        // ============================================

        test.describe('Wall Bump Effect', () => {
            // Simulated wall bump system
            const WallBumpSystem = {
                intensity: 0,
                direction: { x: 0, z: 0 },
                DECAY_RATE: 0.85,
                MIN_SPEED_FOR_BUMP: 1,
                MAX_SPEED: 10,

                triggerBump(speed, velocityX, velocityZ, blockedX, blockedZ) {
                    if (speed > this.MIN_SPEED_FOR_BUMP) {
                        this.intensity = Math.min(1, speed / this.MAX_SPEED);
                        this.direction = {
                            x: blockedX ? -Math.sign(velocityX) : 0,
                            z: blockedZ ? -Math.sign(velocityZ) : 0
                        };
                        return true;
                    }
                    return false;
                },

                update() {
                    this.intensity *= this.DECAY_RATE;
                    if (this.intensity < 0.01) this.intensity = 0;
                },

                getCameraOffset() {
                    return {
                        x: this.direction.x * this.intensity * 0.3,
                        z: this.direction.z * this.intensity * 0.3,
                        shake: this.intensity * (Math.random() - 0.5) * 0.1
                    };
                },

                reset() {
                    this.intensity = 0;
                    this.direction = { x: 0, z: 0 };
                }
            };

            test.beforeEach(() => {
                WallBumpSystem.reset();
            });

            test.it('should trigger bump on wall collision at speed', () => {
                const triggered = WallBumpSystem.triggerBump(5, 1, 0, true, false);
                test.assertTrue(triggered);
                test.assertTrue(WallBumpSystem.intensity > 0);
            });

            test.it('should not trigger bump at low speed', () => {
                const triggered = WallBumpSystem.triggerBump(0.5, 1, 0, true, false);
                test.assertFalse(triggered);
                test.assertEqual(WallBumpSystem.intensity, 0);
            });

            test.it('should set correct bump direction on X collision', () => {
                WallBumpSystem.triggerBump(5, 1, 0, true, false); // Moving +X, blocked X
                test.assertEqual(WallBumpSystem.direction.x, -1); // Push back
                test.assertEqual(WallBumpSystem.direction.z, 0);
            });

            test.it('should set correct bump direction on Z collision', () => {
                WallBumpSystem.triggerBump(5, 0, -1, false, true); // Moving -Z, blocked Z
                test.assertEqual(WallBumpSystem.direction.x, 0);
                test.assertEqual(WallBumpSystem.direction.z, 1); // Push back
            });

            test.it('should decay bump intensity over time', () => {
                WallBumpSystem.triggerBump(10, 1, 0, true, false);
                const initialIntensity = WallBumpSystem.intensity;

                WallBumpSystem.update();
                test.assertTrue(WallBumpSystem.intensity < initialIntensity);

                // Multiple updates should decay further
                for (let i = 0; i < 10; i++) WallBumpSystem.update();
                test.assertTrue(WallBumpSystem.intensity < 0.5);
            });

            test.it('should provide camera offset during bump', () => {
                WallBumpSystem.triggerBump(10, 1, 0, true, false);
                const offset = WallBumpSystem.getCameraOffset();

                test.assertTrue(offset.x !== 0); // Should have X offset
                test.assertEqual(offset.z, 0);   // No Z offset (not blocked)
            });

            test.it('should scale intensity based on speed', () => {
                WallBumpSystem.triggerBump(2, 1, 0, true, false);
                const lowSpeedIntensity = WallBumpSystem.intensity;

                WallBumpSystem.reset();
                WallBumpSystem.triggerBump(10, 1, 0, true, false);
                const highSpeedIntensity = WallBumpSystem.intensity;

                test.assertTrue(highSpeedIntensity > lowSpeedIntensity);
            });
        });

        // ============================================
        // CODE QUALITY TESTS
        // ============================================

        test.describe('Code Quality - No Duplicate Definitions', () => {
            // This test catches bugs like defining the same property twice
            // which causes errors in strict mode

            test.it('should not have duplicate Object.defineProperty calls', async () => {
                // Fetch the game source code
                const response = await fetch('../index.html');
                const sourceCode = await response.text();

                // Find all Object.defineProperty calls for window
                const definePropertyPattern = /Object\.defineProperty\s*\(\s*window\s*,\s*['"](\w+)['"]/g;
                const properties = {};
                let match;

                while ((match = definePropertyPattern.exec(sourceCode)) !== null) {
                    const propName = match[1];
                    if (properties[propName]) {
                        properties[propName].count++;
                        properties[propName].lines.push(match.index);
                    } else {
                        properties[propName] = { count: 1, lines: [match.index] };
                    }
                }

                // Check for duplicates
                const duplicates = Object.entries(properties)
                    .filter(([name, info]) => info.count > 1)
                    .map(([name, info]) => `${name} (defined ${info.count} times)`);

                if (duplicates.length > 0) {
                    throw new Error(`Duplicate Object.defineProperty calls found: ${duplicates.join(', ')}`);
                }
            });

            test.it('should not have duplicate window property assignments', async () => {
                const response = await fetch('../index.html');
                const sourceCode = await response.text();

                // Find all window.X = assignments (excluding those inside functions that reassign)
                // This is a simplified check - looks for window.X = at top level
                const assignmentPattern = /^\s*window\.(\w+)\s*=/gm;
                const properties = {};
                let match;

                while ((match = assignmentPattern.exec(sourceCode)) !== null) {
                    const propName = match[1];
                    if (properties[propName]) {
                        properties[propName]++;
                    } else {
                        properties[propName] = 1;
                    }
                }

                // Only flag if same property assigned more than twice
                // (some reassignments are intentional)
                const duplicates = Object.entries(properties)
                    .filter(([name, count]) => count > 2)
                    .map(([name, count]) => `${name} (assigned ${count} times)`);

                if (duplicates.length > 0) {
                    throw new Error(`Excessive window property assignments: ${duplicates.join(', ')}`);
                }
            });

            test.it('should expose all required properties for testing', async () => {
                // Verify the source code exposes all required properties
                const response = await fetch('../index.html');
                const sourceCode = await response.text();

                // Properties that should be exposed via Object.defineProperty or window.X =
                const requiredProperties = [
                    'gameState',
                    'score',
                    'distance',
                    'camera',
                    'scene',
                    'renderer',
                    'projectiles',
                    'enemies',
                    'obstacles',
                    'resetGame',
                    'startGame',
                    'pauseGame',
                    'resumeGame',
                    'startFiring',
                    'stopFiring',
                    'weapon',
                    'isFiring'
                ];

                const missing = requiredProperties.filter(prop => {
                    // Check for Object.defineProperty(window, 'propName'
                    const definePattern = new RegExp(`Object\\.defineProperty\\s*\\(\\s*window\\s*,\\s*['"]${prop}['"]`);
                    // Check for window.propName =
                    const assignPattern = new RegExp(`window\\.${prop}\\s*=`);
                    return !definePattern.test(sourceCode) && !assignPattern.test(sourceCode);
                });

                if (missing.length > 0) {
                    throw new Error(`Properties not exposed to window: ${missing.join(', ')}`);
                }
            });

            test.it('should not have duplicate CSS selectors', async () => {
                const response = await fetch('../index.html');
                const sourceCode = await response.text();

                // Extract all CSS selectors from style tags
                const styleMatch = sourceCode.match(/<style[^>]*>([\s\S]*?)<\/style>/gi);
                if (!styleMatch) {
                    throw new Error('No style tags found');
                }

                const cssContent = styleMatch.join('\n');

                // Find all selector blocks (simplified: looks for patterns like ".class {" or "#id {")
                const selectorRegex = /^\s*([\.\#][\w\-\:\.\#\[\]\=\"\'\s\,\>\+\~]+)\s*\{/gm;
                const selectors = {};
                let match;

                while ((match = selectorRegex.exec(cssContent)) !== null) {
                    const selector = match[1].trim();
                    // Skip pseudo-elements and complex selectors
                    if (selector.includes('::') || selector.includes(':hover') ||
                        selector.includes(':active') || selector.includes(':before') ||
                        selector.includes(':after') || selector.includes(':focus')) {
                        continue;
                    }
                    selectors[selector] = (selectors[selector] || 0) + 1;
                }

                const duplicates = Object.entries(selectors)
                    .filter(([selector, count]) => count > 1)
                    .map(([selector, count]) => `${selector} (${count} times)`);

                if (duplicates.length > 0) {
                    throw new Error(`Duplicate CSS selectors found: ${duplicates.join(', ')}`);
                }
            });
        });

        // ============================================
        // TARGETING SYSTEM TESTS
        // ============================================

        test.describe('Targeting System', () => {
            // Mock Three.js-like objects for testing
            const createMockCamera = (posX, posY, posZ, rotY = 0) => {
                // Create a quaternion-like object for rotation
                const quat = {
                    // For rotation around Y axis (yaw), quaternion values
                    x: 0,
                    y: Math.sin(rotY / 2),
                    z: 0,
                    w: Math.cos(rotY / 2)
                };
                return {
                    position: { x: posX, y: posY, z: posZ },
                    quaternion: quat
                };
            };

            const createMockTarget = (x, y, z, type = 'enemy', active = true, hit = false) => ({
                position: { x, y, z, clone: () => ({ x, y, z, project: () => {} }) },
                userData: { type, active, hit, height: 2 }
            });

            // Mock TargetingSystem for unit testing (simplified)
            const TargetingSystemMock = {
                MIN_DISTANCE: 1,
                MAX_DISTANCE: 60,
                MAX_ANGLE: 1.0, // ~57 degrees

                // Get forward direction from player rotation
                getForwardDirection(playerRot) {
                    return {
                        x: Math.sin(playerRot),
                        z: -Math.cos(playerRot)
                    };
                },

                // Simplified isValidTarget for testing angle logic
                isValidAngle(targetX, targetZ, playerX, playerZ, playerRot) {
                    const dx = targetX - playerX;
                    const dz = targetZ - playerZ;
                    const dist = Math.sqrt(dx * dx + dz * dz);

                    if (dist < this.MIN_DISTANCE || dist > this.MAX_DISTANCE) return false;

                    // Calculate forward direction from player rotation
                    const forward = this.getForwardDirection(playerRot);

                    // Normalize direction to target
                    const toTargetX = dx / dist;
                    const toTargetZ = dz / dist;

                    // Dot product for angle
                    const dot = forward.x * toTargetX + forward.z * toTargetZ;

                    // If behind player, reject immediately
                    if (dot < 0) return false;

                    const angle = Math.acos(Math.max(-1, Math.min(1, dot)));

                    return angle <= this.MAX_ANGLE;
                },

                // Simplified scoring (no type bonus - priority handles that)
                scoreTarget(targetX, targetZ, playerX, playerZ, playerRot) {
                    const dx = targetX - playerX;
                    const dz = targetZ - playerZ;
                    const dist = Math.sqrt(dx * dx + dz * dz);

                    const forward = this.getForwardDirection(playerRot);
                    const toTargetX = dx / dist;
                    const toTargetZ = dz / dist;
                    const dot = forward.x * toTargetX + forward.z * toTargetZ;

                    // Score formula: angle weight 60%, distance weight 40%
                    let score = dot * 600;
                    score += (1 - dist / this.MAX_DISTANCE) * 400;

                    return score;
                },

                // Find best target - enemies have priority over obstacles
                findBestTarget(enemies, obstacles, playerX, playerZ, playerRot) {
                    // First, try to find best enemy
                    let bestEnemy = null;
                    let bestEnemyScore = -Infinity;

                    enemies.forEach(e => {
                        if (!this.isValidAngle(e.x, e.z, playerX, playerZ, playerRot)) return;
                        const score = this.scoreTarget(e.x, e.z, playerX, playerZ, playerRot);
                        if (score > bestEnemyScore) {
                            bestEnemyScore = score;
                            bestEnemy = e;
                        }
                    });

                    // If enemy found, return it (priority)
                    if (bestEnemy) return { target: bestEnemy, type: 'enemy' };

                    // Otherwise, find best obstacle
                    let bestObstacle = null;
                    let bestObstacleScore = -Infinity;

                    obstacles.forEach(o => {
                        if (!this.isValidAngle(o.x, o.z, playerX, playerZ, playerRot)) return;
                        const score = this.scoreTarget(o.x, o.z, playerX, playerZ, playerRot);
                        if (score > bestObstacleScore) {
                            bestObstacleScore = score;
                            bestObstacle = o;
                        }
                    });

                    if (bestObstacle) return { target: bestObstacle, type: 'obstacle' };

                    return null;
                }
            };

            test.it('should validate target directly in front of player', () => {
                // Player at origin, facing -Z (rotation = 0)
                // Target at (0, 0, -10) - directly ahead
                const result = TargetingSystemMock.isValidAngle(0, -10, 0, 0, 0);
                test.assertTrue(result);
            });

            test.it('should reject target behind player', () => {
                // Player at origin, facing -Z (rotation = 0)
                // Target at (0, 0, 10) - behind
                const result = TargetingSystemMock.isValidAngle(0, 10, 0, 0, 0);
                test.assertFalse(result);
            });

            test.it('should reject target outside 57 degree cone', () => {
                // Player at origin, facing -Z
                // Target at (20, 0, -5) - roughly 76 degrees to the right (outside 57 degree cone)
                const result = TargetingSystemMock.isValidAngle(20, -5, 0, 0, 0);
                test.assertFalse(result);
            });

            test.it('should accept target within 57 degree cone', () => {
                // Player at origin, facing -Z
                // Target at (10, 0, -15) - roughly 34 degrees to the right (inside 57 degree cone)
                const result = TargetingSystemMock.isValidAngle(10, -15, 0, 0, 0);
                test.assertTrue(result);
            });

            test.it('should reject target too close (< 1 unit)', () => {
                const result = TargetingSystemMock.isValidAngle(0, -0.5, 0, 0, 0);
                test.assertFalse(result);
            });

            test.it('should reject target too far (> 60 units)', () => {
                const result = TargetingSystemMock.isValidAngle(0, -70, 0, 0, 0);
                test.assertFalse(result);
            });

            test.it('should score centered targets higher than off-center targets', () => {
                // Both at same distance (10 units)
                // Target A: directly ahead
                const scoreA = TargetingSystemMock.scoreTarget(0, -10, 0, 0, 0);
                // Target B: 30 degrees to the right
                const scoreB = TargetingSystemMock.scoreTarget(5, -8.66, 0, 0, 0);

                test.assertTrue(scoreA > scoreB);
            });

            test.it('should prefer closer targets when angles are similar', () => {
                // Both directly ahead
                const scoreClose = TargetingSystemMock.scoreTarget(0, -10, 0, 0, 0);
                const scoreFar = TargetingSystemMock.scoreTarget(0, -40, 0, 0, 0);

                test.assertTrue(scoreClose > scoreFar);
            });

            test.it('should prioritize enemies over obstacles at same position', () => {
                // Enemy and obstacle at same position
                const enemies = [{ x: 0, z: -10 }];
                const obstacles = [{ x: 0, z: -10 }];

                const result = TargetingSystemMock.findBestTarget(enemies, obstacles, 0, 0, 0);

                test.assertTrue(result !== null, 'Result should not be null');
                test.assertEqual(result.type, 'enemy');
            });

            test.it('should prioritize far enemy over close obstacle', () => {
                // Enemy far, obstacle close - enemy still wins
                const enemies = [{ x: 0, z: -40 }];
                const obstacles = [{ x: 0, z: -5 }];

                const result = TargetingSystemMock.findBestTarget(enemies, obstacles, 0, 0, 0);

                test.assertTrue(result !== null, 'Result should not be null');
                test.assertEqual(result.type, 'enemy');
            });

            test.it('should target obstacle only when no valid enemy exists', () => {
                // Enemy behind player (invalid), obstacle in front (valid)
                const enemies = [{ x: 0, z: 10 }]; // Behind
                const obstacles = [{ x: 0, z: -10 }]; // In front

                const result = TargetingSystemMock.findBestTarget(enemies, obstacles, 0, 0, 0);

                test.assertTrue(result !== null, 'Result should not be null');
                test.assertEqual(result.type, 'obstacle');
            });

            test.it('should work with rotated player (facing +X)', () => {
                // Player facing +X (rotation = PI/2)
                // Target at (10, 0, 0) - directly ahead relative to player
                const result = TargetingSystemMock.isValidAngle(10, 0, 0, 0, Math.PI / 2);
                test.assertTrue(result);
            });

            test.it('should reject when player turned away from target', () => {
                // Player facing +X (rotation = PI/2)
                // Target at (0, 0, -10) - now to the left of player
                const result = TargetingSystemMock.isValidAngle(0, -10, 0, 0, Math.PI / 2);
                test.assertFalse(result);
            });

            test.it('should handle edge case at exact MAX_ANGLE boundary', () => {
                // Player at origin, facing -Z
                // Target at angle exactly at MAX_ANGLE (1.0 radians = ~57 degrees)
                const angle = 1.0;
                const dist = 20;
                const x = Math.sin(angle) * dist;
                const z = -Math.cos(angle) * dist;
                const result = TargetingSystemMock.isValidAngle(x, z, 0, 0, 0);
                test.assertTrue(result);
            });
        });

        // ============================================
        // PROJECTILE-WALL COLLISION TESTS
        // ============================================

        test.describe('Projectile Wall Collision', () => {
            // Mock line-of-sight system for testing
            const LineOfSightMock = {
                ROOM_SIZE: 30,
                walls: [], // Array of wall segments: { x1, z1, x2, z2 }

                // Add a wall segment
                addWall(x1, z1, x2, z2) {
                    this.walls.push({ x1, z1, x2, z2 });
                },

                // Clear all walls
                clearWalls() {
                    this.walls = [];
                },

                // Check if line from A to B intersects any wall
                hasLineOfSight(fromX, fromZ, toX, toZ) {
                    for (const wall of this.walls) {
                        if (this.lineIntersectsLine(
                            fromX, fromZ, toX, toZ,
                            wall.x1, wall.z1, wall.x2, wall.z2
                        )) {
                            return false;
                        }
                    }
                    return true;
                },

                // Line-line intersection test
                lineIntersectsLine(x1, y1, x2, y2, x3, y3, x4, y4) {
                    const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
                    if (Math.abs(denom) < 0.0001) return false; // Parallel lines

                    const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
                    const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;

                    return t >= 0 && t <= 1 && u >= 0 && u <= 1;
                }
            };

            test.beforeEach(() => {
                LineOfSightMock.clearWalls();
            });

            test.it('should allow projectile when no wall between points', () => {
                const result = LineOfSightMock.hasLineOfSight(0, 0, 10, 0);
                test.assertTrue(result);
            });

            test.it('should block projectile when wall intersects path', () => {
                // Add vertical wall at x=5
                LineOfSightMock.addWall(5, -10, 5, 10);

                // Projectile path crosses the wall
                const result = LineOfSightMock.hasLineOfSight(0, 0, 10, 0);
                test.assertFalse(result);
            });

            test.it('should allow projectile when wall is beside path', () => {
                // Add vertical wall at x=5, but only from z=5 to z=10
                LineOfSightMock.addWall(5, 5, 5, 10);

                // Projectile path at z=0 doesn't cross the wall
                const result = LineOfSightMock.hasLineOfSight(0, 0, 10, 0);
                test.assertTrue(result);
            });

            test.it('should block diagonal projectile crossing wall', () => {
                // Add horizontal wall at z=5
                LineOfSightMock.addWall(-10, 5, 10, 5);

                // Diagonal path crosses the wall
                const result = LineOfSightMock.hasLineOfSight(0, 0, 5, 10);
                test.assertFalse(result);
            });

            test.it('should handle projectile path along wall edge', () => {
                // Wall at z=5
                LineOfSightMock.addWall(0, 5, 10, 5);

                // Path ending exactly at wall
                const result = LineOfSightMock.hasLineOfSight(0, 0, 5, 5);
                // Should intersect at the endpoint
                test.assertFalse(result);
            });
        });

        // ============================================
        // PLAYER COLLISION TESTS
        // ============================================

        test.describe('Player Collision', () => {
            // Mock collision system
            const CollisionMock = {
                PLAYER_RADIUS: 1.8,
                ENEMY_RADIUS: 2.0,

                // Calculate push-back when player overlaps with object
                calculatePushBack(playerX, playerZ, objX, objZ, objRadius) {
                    const dx = playerX - objX;
                    const dz = playerZ - objZ;
                    const dist = Math.sqrt(dx * dx + dz * dz);
                    const minDist = this.PLAYER_RADIUS + objRadius;

                    if (dist >= minDist || dist === 0) {
                        return { collided: false, pushX: 0, pushZ: 0 };
                    }

                    // Push player away
                    const pushX = (dx / dist) * (minDist - dist);
                    const pushZ = (dz / dist) * (minDist - dist);

                    return { collided: true, pushX, pushZ };
                },

                // Check wall collision
                checkWallCollision(x, z, roomMinX, roomMaxX, roomMinZ, roomMaxZ, margin) {
                    return {
                        blockedX: x < roomMinX + margin || x > roomMaxX - margin,
                        blockedZ: z < roomMinZ + margin || z > roomMaxZ - margin
                    };
                }
            };

            test.it('should push player away from enemy when overlapping', () => {
                const result = CollisionMock.calculatePushBack(5, 5, 6, 5, CollisionMock.ENEMY_RADIUS);
                test.assertTrue(result.collided);
                test.assertTrue(result.pushX < 0); // Pushed left (away from enemy at x=6)
            });

            test.it('should not push when far from enemy', () => {
                const result = CollisionMock.calculatePushBack(0, 0, 10, 0, CollisionMock.ENEMY_RADIUS);
                test.assertFalse(result.collided);
            });

            test.it('should block at west wall', () => {
                const result = CollisionMock.checkWallCollision(1, 15, 0, 30, 0, 30, 1.5);
                test.assertTrue(result.blockedX);
                test.assertFalse(result.blockedZ);
            });

            test.it('should block at east wall', () => {
                const result = CollisionMock.checkWallCollision(29, 15, 0, 30, 0, 30, 1.5);
                test.assertTrue(result.blockedX);
                test.assertFalse(result.blockedZ);
            });

            test.it('should block at north wall', () => {
                const result = CollisionMock.checkWallCollision(15, 1, 0, 30, 0, 30, 1.5);
                test.assertFalse(result.blockedX);
                test.assertTrue(result.blockedZ);
            });

            test.it('should allow movement in room center', () => {
                const result = CollisionMock.checkWallCollision(15, 15, 0, 30, 0, 30, 1.5);
                test.assertFalse(result.blockedX);
                test.assertFalse(result.blockedZ);
            });
        });

        // ============================================
        // NOTE: Domain-specific tests (Weapon, Projectile, Enemy, Environment)
        // are now loaded from separate files in src/<domain>/<domain>.test.js
        // ============================================

        // ============================================
        // UI RENDERING
        // ============================================

        function renderResults(modules, results) {
            const resultsContainer = document.getElementById('test-results');
            const summary = document.getElementById('summary');

            // Show summary
            summary.style.display = 'flex';
            document.getElementById('total-count').textContent = results.total;
            document.getElementById('passed-count').textContent = results.passed;
            document.getElementById('failed-count').textContent = results.failed;
            document.getElementById('progress-fill').style.width =
                (results.passed / results.total * 100) + '%';

            // Clear previous results
            resultsContainer.innerHTML = '';

            // Render each module
            modules.forEach(module => {
                const moduleDiv = document.createElement('div');
                moduleDiv.className = 'test-module';

                const passedInModule = module.tests.filter(t => t.passed).length;
                const allPassed = passedInModule === module.tests.length;

                moduleDiv.innerHTML = `
                    <div class="module-header">
                        <span>${module.name}</span>
                        <span class="module-status ${allPassed ? 'all-passed' : 'has-failures'}">
                            ${passedInModule}/${module.tests.length} Passed
                        </span>
                    </div>
                    <div class="test-list">
                        ${module.tests.map(t => `
                            <div class="test-item ${t.passed ? 'passed' : 'failed'}">
                                <div>
                                    <div class="test-name">${t.name}</div>
                                    ${t.error ? `<div class="test-details error">${t.error}</div>` : ''}
                                </div>
                                <span class="test-status ${t.passed ? 'passed' : 'failed'}">
                                    ${t.passed ? 'PASS' : 'FAIL'}
                                </span>
                            </div>
                        `).join('')}
                    </div>
                `;

                resultsContainer.appendChild(moduleDiv);
            });
        }

        // Run tests on button click
        document.getElementById('run-tests').addEventListener('click', function() {
            this.disabled = true;
            this.textContent = 'Running...';

            // Small delay for visual feedback
            setTimeout(() => {
                const results = test.run();
                renderResults(test.getModules(), results);

                this.disabled = false;
                this.textContent = 'Run All Tests';
            }, 100);
        });

        // Auto-run tests on page load
        window.addEventListener('load', () => {
            setTimeout(() => {
                document.getElementById('run-tests').click();
            }, 300);
        });
    </script>
</body>
</html>
