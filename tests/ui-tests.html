<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mall Hell - UI/Integration Tests</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a2e;
            color: #fff;
            min-height: 100vh;
        }
        .container {
            display: flex;
            height: 100vh;
        }
        .test-panel {
            width: 450px;
            background: #16213e;
            padding: 20px;
            overflow-y: auto;
            border-right: 2px solid #e94560;
        }
        .game-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        .game-frame-container {
            flex: 1;
            position: relative;
            background: #0a0a0f;
        }
        #game-frame {
            width: 100%;
            height: 100%;
            border: none;
        }
        .controls-bar {
            background: #0f3460;
            padding: 15px;
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }
        h1 {
            color: #e94560;
            font-size: 24px;
            margin-bottom: 5px;
        }
        .subtitle {
            color: #888;
            font-size: 12px;
            margin-bottom: 20px;
        }
        .btn {
            background: linear-gradient(135deg, #e94560, #c0392b);
            color: #fff;
            border: none;
            padding: 10px 20px;
            font-size: 14px;
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.2s;
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(233, 69, 96, 0.4);
        }
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        .btn-secondary {
            background: linear-gradient(135deg, #34495e, #2c3e50);
        }
        .btn-small {
            padding: 5px 10px;
            font-size: 12px;
        }
        .summary {
            background: #0f3460;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        .summary-stats {
            display: flex;
            gap: 20px;
            margin-top: 10px;
        }
        .stat {
            text-align: center;
        }
        .stat-value {
            font-size: 28px;
            font-weight: bold;
        }
        .stat-label {
            font-size: 11px;
            color: #888;
            text-transform: uppercase;
        }
        .stat-pass { color: #2ecc71; }
        .stat-fail { color: #e74c3c; }
        .stat-pending { color: #f39c12; }
        .stat-total { color: #3498db; }
        .progress-bar {
            width: 100%;
            height: 8px;
            background: #1a1a2e;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 15px;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #2ecc71, #27ae60);
            transition: width 0.3s;
        }
        .test-group {
            margin-bottom: 20px;
        }
        .group-header {
            background: #0f3460;
            padding: 10px 15px;
            border-radius: 5px;
            margin-bottom: 10px;
            font-weight: bold;
            color: #e94560;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .group-count {
            font-size: 12px;
            color: #888;
        }
        .test-item {
            background: #1a1a2e;
            padding: 12px 15px;
            border-radius: 5px;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 12px;
            transition: all 0.2s;
        }
        .test-item:hover {
            background: #232741;
        }
        .test-status {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            flex-shrink: 0;
        }
        .status-pending {
            background: #34495e;
            color: #888;
        }
        .status-running {
            background: #f39c12;
            color: #fff;
            animation: pulse 1s infinite;
        }
        .status-pass {
            background: #2ecc71;
            color: #fff;
        }
        .status-fail {
            background: #e74c3c;
            color: #fff;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .test-info {
            flex: 1;
        }
        .test-name {
            font-size: 14px;
            margin-bottom: 2px;
        }
        .test-desc {
            font-size: 11px;
            color: #666;
        }
        .test-time {
            font-size: 11px;
            color: #888;
        }
        .test-error {
            background: rgba(231, 76, 60, 0.1);
            border: 1px solid #e74c3c;
            border-radius: 4px;
            padding: 8px;
            margin-top: 8px;
            font-size: 11px;
            color: #e74c3c;
            font-family: monospace;
            word-break: break-word;
        }
        .log-panel {
            background: #0a0a0f;
            padding: 10px;
            max-height: 150px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 11px;
            border-radius: 5px;
            margin-top: 15px;
        }
        .log-entry {
            padding: 2px 0;
            border-bottom: 1px solid #1a1a2e;
        }
        .log-info { color: #3498db; }
        .log-success { color: #2ecc71; }
        .log-error { color: #e74c3c; }
        .log-warn { color: #f39c12; }
        .state-capture {
            background: #0f3460;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
        }
        .state-capture h3 {
            font-size: 14px;
            margin-bottom: 10px;
            color: #e94560;
        }
        .state-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            font-size: 12px;
        }
        .state-item {
            background: #1a1a2e;
            padding: 8px;
            border-radius: 4px;
        }
        .state-label {
            color: #888;
            font-size: 10px;
            text-transform: uppercase;
        }
        .state-value {
            color: #fff;
            font-family: monospace;
            margin-top: 3px;
        }
        .timing-control {
            display: flex;
            align-items: center;
            gap: 10px;
            color: #888;
            font-size: 12px;
        }
        .timing-control input {
            width: 60px;
            padding: 5px;
            background: #1a1a2e;
            border: 1px solid #34495e;
            color: #fff;
            border-radius: 3px;
        }
        .screenshot-btn {
            background: #9b59b6;
        }
        .screenshot-btn:hover {
            box-shadow: 0 5px 15px rgba(155, 89, 182, 0.4);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="test-panel">
            <h1>Mall Hell UI Tests</h1>
            <p class="subtitle">Integration & UI Testing Suite</p>

            <div class="summary">
                <div class="summary-stats">
                    <div class="stat">
                        <div class="stat-value stat-pass" id="pass-count">0</div>
                        <div class="stat-label">Passed</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value stat-fail" id="fail-count">0</div>
                        <div class="stat-label">Failed</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value stat-pending" id="pending-count">0</div>
                        <div class="stat-label">Pending</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value stat-total" id="total-count">0</div>
                        <div class="stat-label">Total</div>
                    </div>
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" id="test-progress"></div>
                </div>
            </div>

            <div id="test-list"></div>

            <div class="state-capture">
                <h3>Current Game State</h3>
                <div class="state-grid">
                    <div class="state-item">
                        <div class="state-label">Game State</div>
                        <div class="state-value" id="current-state">-</div>
                    </div>
                    <div class="state-item">
                        <div class="state-label">Score</div>
                        <div class="state-value" id="current-score">-</div>
                    </div>
                    <div class="state-item">
                        <div class="state-label">Progress</div>
                        <div class="state-value" id="current-progress">-</div>
                    </div>
                    <div class="state-item">
                        <div class="state-label">HUD Visible</div>
                        <div class="state-value" id="hud-visible">-</div>
                    </div>
                </div>
            </div>

            <div class="log-panel" id="log-panel"></div>
        </div>

        <div class="game-panel">
            <div class="controls-bar">
                <button class="btn" id="run-all-btn">Run All Tests</button>
                <button class="btn btn-secondary" id="run-selected-btn">Run Selected</button>
                <button class="btn btn-secondary" id="reset-btn">Reset</button>
                <button class="btn btn-secondary screenshot-btn" id="capture-btn">Capture State</button>
                <div class="timing-control">
                    <label>Delay (ms):</label>
                    <input type="number" id="test-delay" value="500" min="100" max="5000" step="100">
                </div>
            </div>
            <div class="game-frame-container">
                <iframe id="game-frame" src="../index.html"></iframe>
            </div>
        </div>
    </div>

    <script>
        // Test Framework
        class UITestRunner {
            constructor() {
                this.tests = [];
                this.results = { pass: 0, fail: 0, pending: 0 };
                this.gameWindow = null;
                this.gameDocument = null;
                this.isRunning = false;
                this.delay = 500;
                this.currentTest = null;
            }

            async init() {
                const frame = document.getElementById('game-frame');
                this.gameWindow = frame.contentWindow;
                this.gameDocument = frame.contentDocument;
                this.log('Game loaded successfully', 'success');
                this.setupTests();
                this.renderTests();
                this.startStateMonitor();
            }

            log(message, type = 'info') {
                const panel = document.getElementById('log-panel');
                const entry = document.createElement('div');
                entry.className = `log-entry log-${type}`;
                entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
                panel.appendChild(entry);
                panel.scrollTop = panel.scrollHeight;
            }

            async wait(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            getElement(selector) {
                return this.gameDocument.querySelector(selector);
            }

            getElements(selector) {
                return this.gameDocument.querySelectorAll(selector);
            }

            isVisible(element) {
                if (!element) return false;
                const style = this.gameWindow.getComputedStyle(element);
                return style.display !== 'none' && style.visibility !== 'hidden' && style.opacity !== '0';
            }

            getGameState() {
                return this.gameWindow.gameState;
            }

            getScore() {
                return this.gameWindow.score;
            }

            getDistance() {
                return this.gameWindow.distance;
            }

            simulateClick(element) {
                if (!element) throw new Error('Element not found for click');
                const event = new MouseEvent('click', {
                    bubbles: true,
                    cancelable: true,
                    view: this.gameWindow
                });
                element.dispatchEvent(event);
            }

            simulateMouseMove(x, y) {
                const event = new MouseEvent('mousemove', {
                    bubbles: true,
                    cancelable: true,
                    view: this.gameWindow,
                    clientX: x,
                    clientY: y
                });
                this.gameDocument.dispatchEvent(event);
            }

            simulateKeyDown(key) {
                const event = new KeyboardEvent('keydown', {
                    bubbles: true,
                    cancelable: true,
                    key: key
                });
                this.gameDocument.dispatchEvent(event);
            }

            simulateKeyUp(key) {
                const event = new KeyboardEvent('keyup', {
                    bubbles: true,
                    cancelable: true,
                    key: key
                });
                this.gameDocument.dispatchEvent(event);
            }

            simulateHover(element) {
                if (!element) throw new Error('Element not found for hover');
                const enterEvent = new MouseEvent('mouseenter', {
                    bubbles: true,
                    cancelable: true,
                    view: this.gameWindow
                });
                element.dispatchEvent(enterEvent);

                const overEvent = new MouseEvent('mouseover', {
                    bubbles: true,
                    cancelable: true,
                    view: this.gameWindow
                });
                element.dispatchEvent(overEvent);
            }

            simulateHoverEnd(element) {
                if (!element) throw new Error('Element not found for hover end');
                const leaveEvent = new MouseEvent('mouseleave', {
                    bubbles: true,
                    cancelable: true,
                    view: this.gameWindow
                });
                element.dispatchEvent(leaveEvent);
            }

            resetGame() {
                // Call game's resetGame if available
                if (this.gameWindow.resetGame) {
                    this.gameWindow.resetGame();
                }

                const menuScreen = this.getElement('#menu-screen');
                const gameoverScreen = this.getElement('#gameover-screen');
                const pauseScreen = this.getElement('#pause-screen');
                const hud = this.getElement('#hud');

                if (menuScreen) menuScreen.style.display = 'flex';
                if (gameoverScreen) gameoverScreen.style.display = 'none';
                if (pauseScreen) pauseScreen.style.display = 'none';
                if (hud) hud.style.display = 'none';

                this.gameWindow.gameState = 'MENU';
                this.gameWindow.score = 0;
                this.gameWindow.distance = 0;

                const scoreEl = this.getElement('#score');
                if (scoreEl) scoreEl.textContent = '0';

                const progressFill = this.getElement('#progress-fill');
                if (progressFill) progressFill.style.width = '0%';
            }

            startStateMonitor() {
                setInterval(() => {
                    document.getElementById('current-state').textContent = this.getGameState() || '-';
                    document.getElementById('current-score').textContent = this.getScore() || '0';
                    const progress = this.getDistance() ?
                        ((this.getDistance() / 800) * 100).toFixed(1) + '%' : '0%';
                    document.getElementById('current-progress').textContent = progress;
                    const hud = this.getElement('#hud');
                    document.getElementById('hud-visible').textContent =
                        hud ? (this.isVisible(hud) ? 'Yes' : 'No') : '-';
                }, 200);
            }

            setupTests() {
                // Menu Screen Tests
                this.addTest('menu-title', 'Menu Screen', 'Title is visible',
                    'Verifies the game title "MALL HELL" is displayed',
                    async () => {
                        this.resetGame();
                        await this.wait(100);
                        const title = this.getElement('.title');
                        if (!title || !this.isVisible(title)) {
                            throw new Error('Title element not found or not visible');
                        }
                        if (!title.textContent.includes('MALL HELL')) {
                            throw new Error(`Expected title to contain "MALL HELL", got "${title.textContent}"`);
                        }
                    }
                );

                this.addTest('menu-start-btn', 'Menu Screen', 'Start button exists and works',
                    'Verifies the start button is visible and clickable',
                    async () => {
                        this.resetGame();
                        await this.wait(100);
                        const startBtn = this.getElement('#start-btn');
                        if (!startBtn || !this.isVisible(startBtn)) {
                            throw new Error('Start button not found or not visible');
                        }
                        if (!startBtn.textContent.includes('START')) {
                            throw new Error('Start button text incorrect');
                        }
                    }
                );

                this.addTest('menu-instructions', 'Menu Screen', 'Instructions are displayed',
                    'Verifies game instructions are visible on menu',
                    async () => {
                        this.resetGame();
                        await this.wait(100);
                        const instructions = this.getElement('.instructions');
                        if (!instructions || !this.isVisible(instructions)) {
                            throw new Error('Instructions not found or not visible');
                        }
                        const text = instructions.textContent.toLowerCase();
                        // Classic mode shows mouse/click, arcade shows space/fire
                        if (!text.includes('fire') && !text.includes('click')) {
                            throw new Error('Instructions missing fire controls info');
                        }
                    }
                );

                // Camera mode selector removed in v3.0 - now FPS only
                this.addTest('menu-version', 'Menu Screen', 'Version shows v3.3',
                    'Verifies menu shows correct version',
                    async () => {
                        this.resetGame();
                        await this.wait(100);
                        const version = this.getElement('.version');
                        if (!version || !version.textContent.includes('3.3')) {
                            throw new Error('Version should show v3.3');
                        }
                    }
                );

                this.addTest('menu-instructions', 'Menu Screen', 'Instructions show WASD controls',
                    'Verifies instructions display WASD for driving and space for fire',
                    async () => {
                        this.resetGame();
                        await this.wait(100);
                        const instructions = this.getElement('.instructions');
                        if (!instructions) {
                            throw new Error('Instructions not found');
                        }
                        const text = instructions.textContent.toLowerCase();
                        // Should mention WASD for driving and space for fire
                        if (!text.includes('forward') && !text.includes('w')) {
                            throw new Error('Instructions should mention forward/W');
                        }
                        if (!text.includes('space')) {
                            throw new Error('Instructions should mention space for fire');
                        }
                    }
                );

                // How to Play Modal Tests
                this.addTest('how-to-play-btn-exists', 'How to Play', 'How to Play button exists',
                    'Verifies How to Play button is visible in menu',
                    async () => {
                        this.resetGame();
                        await this.wait(100);
                        const btn = this.getElement('#how-to-play-btn');
                        if (!btn) {
                            throw new Error('How to Play button not found');
                        }
                        if (!this.isVisible(btn)) {
                            throw new Error('How to Play button not visible');
                        }
                    }
                );

                this.addTest('how-to-play-modal-opens', 'How to Play', 'Modal opens on button click',
                    'Verifies clicking How to Play button opens the modal',
                    async () => {
                        this.resetGame();
                        await this.wait(100);
                        const btn = this.getElement('#how-to-play-btn');
                        const modal = this.getElement('#how-to-play-modal');

                        // Modal should be hidden initially
                        if (modal.classList.contains('visible')) {
                            throw new Error('Modal should be hidden initially');
                        }

                        // Click the button
                        this.simulateClick(btn);
                        await this.wait(100);

                        // Modal should now be visible
                        if (!modal.classList.contains('visible')) {
                            throw new Error('Modal should be visible after clicking button');
                        }
                    }
                );

                this.addTest('how-to-play-modal-closes', 'How to Play', 'Modal closes on GOT IT click',
                    'Verifies clicking GOT IT button closes the modal',
                    async () => {
                        this.resetGame();
                        await this.wait(100);
                        const btn = this.getElement('#how-to-play-btn');
                        const modal = this.getElement('#how-to-play-modal');
                        const closeBtn = this.getElement('#modal-close');

                        // Open the modal first
                        this.simulateClick(btn);
                        await this.wait(100);

                        if (!modal.classList.contains('visible')) {
                            throw new Error('Modal should be visible after opening');
                        }

                        // Click close button
                        this.simulateClick(closeBtn);
                        await this.wait(100);

                        // Modal should be hidden
                        if (modal.classList.contains('visible')) {
                            throw new Error('Modal should be hidden after clicking GOT IT');
                        }
                    }
                );

                this.addTest('how-to-play-modal-content', 'How to Play', 'Modal has correct content',
                    'Verifies modal contains help information',
                    async () => {
                        this.resetGame();
                        await this.wait(100);
                        const modal = this.getElement('#how-to-play-modal');
                        const content = modal.querySelector('.modal-content');

                        if (!content) {
                            throw new Error('Modal content not found');
                        }

                        const text = content.textContent.toLowerCase();

                        // Should have controls info
                        if (!text.includes('w') || !text.includes('s')) {
                            throw new Error('Modal should explain W/S controls');
                        }
                        if (!text.includes('a') || !text.includes('d')) {
                            throw new Error('Modal should explain A/D controls');
                        }
                        if (!text.includes('space')) {
                            throw new Error('Modal should explain SPACE control');
                        }

                        // Should have scoring info
                        if (!text.includes('100') || !text.includes('300')) {
                            throw new Error('Modal should explain scoring');
                        }
                    }
                );

                this.addTest('how-to-play-modal-clickable', 'How to Play', 'Modal elements are clickable',
                    'Verifies modal has pointer-events enabled for clicking',
                    async () => {
                        this.resetGame();
                        await this.wait(100);

                        const modal = this.getElement('#how-to-play-modal');
                        const content = modal.querySelector('.modal-content');
                        const closeBtn = this.getElement('#modal-close');

                        // Check that modal has pointer-events: auto (not inherited 'none' from ui-layer)
                        const modalStyle = window.getComputedStyle(modal);
                        const contentStyle = window.getComputedStyle(content);
                        const btnStyle = window.getComputedStyle(closeBtn);

                        if (modalStyle.pointerEvents === 'none') {
                            throw new Error('Modal should have pointer-events: auto, got none');
                        }
                        if (contentStyle.pointerEvents === 'none') {
                            throw new Error('Modal content should have pointer-events: auto, got none');
                        }
                        if (btnStyle.pointerEvents === 'none') {
                            throw new Error('Close button should have pointer-events: auto, got none');
                        }
                    }
                );

                // Game Start Tests
                this.addTest('game-start-hud', 'Game Start', 'HUD appears on game start',
                    'Verifies HUD is displayed when game starts',
                    async () => {
                        this.resetGame();
                        await this.wait(100);
                        const startBtn = this.getElement('#start-btn');
                        this.simulateClick(startBtn);
                        await this.wait(200);
                        const hud = this.getElement('#hud');
                        if (!this.isVisible(hud)) {
                            throw new Error('HUD not visible after game start');
                        }
                    }
                );

                this.addTest('game-start-score', 'Game Start', 'Score starts at 0',
                    'Verifies score is 0 when game starts',
                    async () => {
                        this.resetGame();
                        await this.wait(100);
                        // Check score is 0 BEFORE starting game
                        const preScore = this.getScore();
                        if (preScore !== 0) {
                            throw new Error(`Expected pre-start score 0, got ${preScore}`);
                        }
                        const startBtn = this.getElement('#start-btn');
                        this.simulateClick(startBtn);
                        await this.wait(50); // Shorter wait to check immediately after start
                        const score = this.getScore();
                        if (score !== 0) {
                            throw new Error(`Expected score 0, got ${score}`);
                        }
                        const scoreEl = this.getElement('#score');
                        if (scoreEl.textContent !== '0') {
                            throw new Error(`Score display shows "${scoreEl.textContent}" instead of "0"`);
                        }
                    }
                );

                this.addTest('game-start-timer', 'Game Start', 'Timer shows 3:00 at start',
                    'Verifies timer starts at 3 minutes',
                    async () => {
                        this.resetGame();
                        await this.wait(100);
                        const startBtn = this.getElement('#start-btn');
                        this.simulateClick(startBtn);
                        await this.wait(200);
                        const timerDisplay = this.getElement('#timer-display');
                        if (!timerDisplay) {
                            throw new Error('Timer display not found');
                        }
                        const timerText = timerDisplay.textContent;
                        if (!timerText.includes('3:00') && !timerText.includes('2:5')) {
                            throw new Error(`Timer should start at 3:00, got ${timerText}`);
                        }
                    }
                );

                // Pause Menu Tests
                this.addTest('pause-esc-shows', 'Pause Menu', 'ESC shows pause screen',
                    'Verifies pressing ESC during gameplay shows pause menu',
                    async () => {
                        this.resetGame();
                        await this.wait(100);
                        const startBtn = this.getElement('#start-btn');
                        this.simulateClick(startBtn);
                        await this.wait(300);
                        this.simulateKeyDown('Escape');
                        await this.wait(200);
                        const pauseScreen = this.getElement('#pause-screen');
                        if (!this.isVisible(pauseScreen)) {
                            throw new Error('Pause screen not visible after ESC');
                        }
                        if (this.getGameState() !== 'PAUSED') {
                            throw new Error(`Expected PAUSED state, got ${this.getGameState()}`);
                        }
                    }
                );

                this.addTest('pause-resume', 'Pause Menu', 'Resume button works',
                    'Verifies clicking resume returns to gameplay',
                    async () => {
                        this.resetGame();
                        await this.wait(100);
                        const startBtn = this.getElement('#start-btn');
                        this.simulateClick(startBtn);
                        await this.wait(200);
                        this.simulateKeyDown('Escape');
                        await this.wait(200);
                        const resumeBtn = this.getElement('#resume-btn');
                        this.simulateClick(resumeBtn);
                        await this.wait(200);
                        const pauseScreen = this.getElement('#pause-screen');
                        if (this.isVisible(pauseScreen)) {
                            throw new Error('Pause screen still visible after resume');
                        }
                        if (this.getGameState() !== 'PLAYING') {
                            throw new Error(`Expected PLAYING state, got ${this.getGameState()}`);
                        }
                    }
                );

                this.addTest('pause-quit', 'Pause Menu', 'Quit to menu works',
                    'Verifies quit button returns to main menu',
                    async () => {
                        this.resetGame();
                        await this.wait(100);
                        const startBtn = this.getElement('#start-btn');
                        this.simulateClick(startBtn);
                        await this.wait(200);
                        this.simulateKeyDown('Escape');
                        await this.wait(200);
                        const quitBtn = this.getElement('#quit-btn');
                        this.simulateClick(quitBtn);
                        await this.wait(200);
                        const menuScreen = this.getElement('#menu-screen');
                        if (!this.isVisible(menuScreen)) {
                            throw new Error('Menu screen not visible after quit');
                        }
                        if (this.getGameState() !== 'MENU') {
                            throw new Error(`Expected MENU state, got ${this.getGameState()}`);
                        }
                    }
                );

                // Pause Button Functionality Tests
                this.addTest('pause-resume-clickable', 'Pause Menu', 'Resume button is clickable',
                    'Verifies resume button has pointer-events and responds to clicks',
                    async () => {
                        this.resetGame();
                        await this.wait(100);
                        const startBtn = this.getElement('#start-btn');
                        this.simulateClick(startBtn);
                        await this.wait(300);
                        this.simulateKeyDown('Escape');
                        await this.wait(300);

                        const pauseScreen = this.getElement('#pause-screen');
                        const resumeBtn = this.getElement('#resume-btn');

                        // Check pause screen is visible
                        if (!this.isVisible(pauseScreen)) {
                            throw new Error('Pause screen not visible');
                        }

                        // Check button has pointer-events
                        const computedStyle = this.gameWindow.getComputedStyle(pauseScreen);
                        if (computedStyle.pointerEvents === 'none') {
                            throw new Error('Pause screen has pointer-events: none');
                        }

                        // Click resume
                        this.simulateClick(resumeBtn);
                        await this.wait(300);

                        if (this.getGameState() !== 'PLAYING') {
                            throw new Error(`Resume failed - state is ${this.getGameState()}, expected PLAYING`);
                        }
                    }
                );

                this.addTest('pause-quit-clickable', 'Pause Menu', 'Quit button is clickable',
                    'Verifies quit button has pointer-events and responds to clicks',
                    async () => {
                        this.resetGame();
                        await this.wait(100);
                        const startBtn = this.getElement('#start-btn');
                        this.simulateClick(startBtn);
                        await this.wait(300);
                        this.simulateKeyDown('Escape');
                        await this.wait(300);

                        const pauseScreen = this.getElement('#pause-screen');
                        const quitBtn = this.getElement('#quit-btn');

                        // Check pause screen is visible
                        if (!this.isVisible(pauseScreen)) {
                            throw new Error('Pause screen not visible');
                        }

                        // Click quit
                        this.simulateClick(quitBtn);
                        await this.wait(300);

                        if (this.getGameState() !== 'MENU') {
                            throw new Error(`Quit failed - state is ${this.getGameState()}, expected MENU`);
                        }

                        const menuScreen = this.getElement('#menu-screen');
                        if (!this.isVisible(menuScreen)) {
                            throw new Error('Menu screen not visible after quit');
                        }
                    }
                );

                // Game Over Tests
                this.addTest('gameover-shows', 'Game Over', 'Game over screen appears',
                    'Verifies game over screen shows when game ends',
                    async () => {
                        this.resetGame();
                        await this.wait(100);
                        // Manually trigger game over
                        this.gameWindow.gameState = 'PLAYING';
                        this.gameWindow.score = 1500;
                        this.gameWindow.endGame();
                        await this.wait(200);
                        const gameoverScreen = this.getElement('#gameover-screen');
                        if (!this.isVisible(gameoverScreen)) {
                            throw new Error('Game over screen not visible');
                        }
                    }
                );

                this.addTest('gameover-score', 'Game Over', 'Final score is displayed',
                    'Verifies score is shown on game over screen',
                    async () => {
                        this.resetGame();
                        await this.wait(100);
                        this.gameWindow.gameState = 'PLAYING';
                        this.gameWindow.score = 2500;
                        this.gameWindow.endGame();
                        await this.wait(200);
                        const finalScore = this.getElement('#final-score');
                        if (!finalScore || finalScore.textContent !== '2500') {
                            throw new Error(`Expected final score 2500, got ${finalScore?.textContent}`);
                        }
                    }
                );

                this.addTest('gameover-play-again', 'Game Over', 'Play again button works',
                    'Verifies play again restarts the game',
                    async () => {
                        this.resetGame();
                        await this.wait(100);
                        this.gameWindow.gameState = 'PLAYING';
                        this.gameWindow.score = 1000;
                        this.getElement('#score').textContent = '1000';
                        this.gameWindow.endGame();
                        await this.wait(300);

                        // Verify we're in game over state
                        if (this.getGameState() !== 'GAME_OVER') {
                            throw new Error('Expected GAME_OVER state');
                        }

                        const restartBtn = this.getElement('#restart-btn');
                        this.simulateClick(restartBtn);
                        await this.wait(100);

                        // Verify game restarted to PLAYING state
                        if (this.getGameState() !== 'PLAYING') {
                            throw new Error(`Expected PLAYING state, got ${this.getGameState()}`);
                        }

                        // Verify score element shows 0 (the display, which is set synchronously in resetGame)
                        const scoreEl = this.getElement('#score');
                        if (scoreEl.textContent !== '0') {
                            throw new Error(`Score display not reset, shows ${scoreEl.textContent}`);
                        }
                    }
                );

                // HUD Update Tests
                this.addTest('hud-score-update', 'HUD Updates', 'Score updates on events',
                    'Verifies score display updates when score changes',
                    async () => {
                        this.resetGame();
                        await this.wait(100);
                        const startBtn = this.getElement('#start-btn');
                        this.simulateClick(startBtn);
                        await this.wait(200);
                        // Mock score update
                        this.gameWindow.score = 500;
                        this.getElement('#score').textContent = '500';
                        await this.wait(100);
                        const scoreEl = this.getElement('#score');
                        if (scoreEl.textContent !== '500') {
                            throw new Error(`Score display not updated, shows ${scoreEl.textContent}`);
                        }
                    }
                );

                this.addTest('hud-timer-update', 'HUD Updates', 'Timer counts down',
                    'Verifies timer decreases over time',
                    async () => {
                        this.resetGame();
                        await this.wait(100);
                        const startBtn = this.getElement('#start-btn');
                        this.simulateClick(startBtn);
                        await this.wait(300);

                        const timerDisplay = this.getElement('#timer-display');
                        if (!timerDisplay) {
                            throw new Error('Timer display element not found');
                        }

                        // Get initial timer value
                        const initialTime = this.gameWindow.gameTimer || 180;

                        // Let the game run a bit
                        await this.wait(1500);

                        // Get new timer value
                        const newTime = this.gameWindow.gameTimer || 180;

                        // Verify timer is counting down
                        if (newTime >= initialTime - 0.5) {
                            throw new Error(`Timer not counting down. Initial: ${initialTime}, Current: ${newTime}`);
                        }
                    }
                );

                // Button Hover Tests
                this.addTest('btn-hover-start', 'Button Hover', 'Start button responds to hover',
                    'Verifies start button has hover styles',
                    async () => {
                        this.resetGame();
                        await this.wait(100);
                        const startBtn = this.getElement('#start-btn');
                        const initialTransform = this.gameWindow.getComputedStyle(startBtn).transform;
                        // Check that button has transition property set
                        const transition = this.gameWindow.getComputedStyle(startBtn).transition;
                        if (!transition || transition === 'none') {
                            throw new Error('Button missing transition property for hover effect');
                        }
                    }
                );

                // Crosshair Tests
                this.addTest('crosshair-gameplay', 'Crosshair', 'Visible during gameplay',
                    'Verifies crosshair is visible when playing',
                    async () => {
                        this.resetGame();
                        await this.wait(100);
                        const startBtn = this.getElement('#start-btn');
                        this.simulateClick(startBtn);
                        await this.wait(200);
                        const crosshair = this.getElement('#crosshair');
                        if (!crosshair) {
                            throw new Error('Crosshair element not found');
                        }
                        // Crosshair should exist in UI layer during gameplay
                        const style = this.gameWindow.getComputedStyle(crosshair);
                        if (style.display === 'none') {
                            throw new Error('Crosshair hidden during gameplay');
                        }
                    }
                );

                this.addTest('crosshair-menu', 'Crosshair', 'Game state is MENU on load',
                    'Verifies game starts in MENU state with menu visible',
                    async () => {
                        this.resetGame();
                        await this.wait(100);
                        const menuScreen = this.getElement('#menu-screen');
                        if (!this.isVisible(menuScreen)) {
                            throw new Error('Menu screen not visible');
                        }
                        const gameState = this.getGameState();
                        if (gameState !== 'MENU') {
                            throw new Error(`Expected MENU state, got ${gameState}`);
                        }
                    }
                );

                // State Transition Tests
                this.addTest('transition-menu-to-playing', 'State Transitions', 'Menu to Playing',
                    'Verifies state changes correctly from menu to playing',
                    async () => {
                        this.resetGame();
                        await this.wait(100);
                        if (this.getGameState() !== 'MENU') {
                            throw new Error('Initial state not MENU');
                        }
                        const startBtn = this.getElement('#start-btn');
                        this.simulateClick(startBtn);
                        await this.wait(200);
                        if (this.getGameState() !== 'PLAYING') {
                            throw new Error(`Expected PLAYING, got ${this.getGameState()}`);
                        }
                    }
                );

                this.addTest('transition-playing-to-paused', 'State Transitions', 'Playing to Paused',
                    'Verifies state changes correctly when pausing',
                    async () => {
                        this.resetGame();
                        await this.wait(100);
                        const startBtn = this.getElement('#start-btn');
                        this.simulateClick(startBtn);
                        await this.wait(200);
                        this.simulateKeyDown('Escape');
                        await this.wait(200);
                        if (this.getGameState() !== 'PAUSED') {
                            throw new Error(`Expected PAUSED, got ${this.getGameState()}`);
                        }
                    }
                );

                this.addTest('transition-paused-to-playing', 'State Transitions', 'Paused to Playing',
                    'Verifies state changes correctly when resuming',
                    async () => {
                        this.resetGame();
                        await this.wait(100);
                        const startBtn = this.getElement('#start-btn');
                        this.simulateClick(startBtn);
                        await this.wait(200);
                        this.simulateKeyDown('Escape');
                        await this.wait(200);
                        this.simulateKeyDown('Escape');
                        await this.wait(200);
                        if (this.getGameState() !== 'PLAYING') {
                            throw new Error(`Expected PLAYING after resume, got ${this.getGameState()}`);
                        }
                    }
                );

                this.addTest('transition-ui-sync', 'State Transitions', 'UI updates with state',
                    'Verifies UI elements sync with game state changes',
                    async () => {
                        this.resetGame();
                        await this.wait(100);

                        // Check menu state UI
                        let menuVisible = this.isVisible(this.getElement('#menu-screen'));
                        let hudVisible = this.isVisible(this.getElement('#hud'));
                        if (!menuVisible || hudVisible) {
                            throw new Error('Menu state UI incorrect');
                        }

                        // Start game
                        this.simulateClick(this.getElement('#start-btn'));
                        await this.wait(200);

                        // Check playing state UI
                        menuVisible = this.isVisible(this.getElement('#menu-screen'));
                        hudVisible = this.isVisible(this.getElement('#hud'));
                        if (menuVisible || !hudVisible) {
                            throw new Error('Playing state UI incorrect');
                        }

                        // Pause
                        this.simulateKeyDown('Escape');
                        await this.wait(200);

                        // Check paused state UI
                        const pauseVisible = this.isVisible(this.getElement('#pause-screen'));
                        if (!pauseVisible) {
                            throw new Error('Paused state UI incorrect');
                        }
                    }
                );

                // Player Movement Controls Tests (WASD Driving - v3.0)
                this.addTest('movement-wasd-forward', 'Player Movement', 'W key drives cart forward',
                    'Verifies pressing W moves the cart forward',
                    async () => {
                        this.resetGame();
                        await this.wait(100);

                        const startBtn = this.getElement('#start-btn');
                        this.simulateClick(startBtn);
                        await this.wait(200);
                        const initialZ = this.gameWindow.playerPosition?.z || 0;
                        this.simulateKeyDown('KeyW');
                        await this.wait(300);
                        const newZ = this.gameWindow.playerPosition?.z || 0;
                        this.simulateKeyUp('KeyW');
                        // Forward movement decreases Z in our coordinate system
                        if (Math.abs(newZ - initialZ) < 0.1) {
                            throw new Error(`Cart did not move. Initial Z: ${initialZ}, New Z: ${newZ}`);
                        }
                    }
                );

                this.addTest('movement-wasd-turn', 'Player Movement', 'A/D keys turn cart',
                    'Verifies pressing A/D rotates the cart',
                    async () => {
                        this.resetGame();
                        await this.wait(100);

                        const startBtn = this.getElement('#start-btn');
                        this.simulateClick(startBtn);
                        await this.wait(200);
                        const initialRot = this.gameWindow.playerRotation || 0;
                        this.simulateKeyDown('KeyA');
                        await this.wait(300);
                        const newRot = this.gameWindow.playerRotation || 0;
                        this.simulateKeyUp('KeyA');
                        if (Math.abs(newRot - initialRot) < 0.01) {
                            throw new Error(`Cart did not turn. Initial: ${initialRot}, New: ${newRot}`);
                        }
                    }
                );

                this.addTest('wasd-keys', 'Keyboard Controls', 'WASD keys control driving',
                    'Verifies WASD keys set movement keys for driving',
                    async () => {
                        this.resetGame();
                        await this.wait(100);
                        const startBtn = this.getElement('#start-btn');
                        this.simulateClick(startBtn);
                        await this.wait(200);

                        // W should set forward
                        this.simulateKeyDown('KeyW');
                        await this.wait(50);
                        if (!this.gameWindow.keys.forward) {
                            throw new Error('W did not set keys.forward');
                        }
                        this.simulateKeyUp('KeyW');

                        // A should set turnLeft
                        this.simulateKeyDown('KeyA');
                        await this.wait(50);
                        if (!this.gameWindow.keys.turnLeft) {
                            throw new Error('A did not set keys.turnLeft');
                        }
                        this.simulateKeyUp('KeyA');
                    }
                );

                // Smart Auto-Aim Test
                this.addTest('smart-auto-aim', 'Auto-Aim', 'Crosshair automatically tracks targets',
                    'Verifies crosshair moves to track enemies/obstacles',
                    async () => {
                        this.resetGame();
                        await this.wait(100);
                        const startBtn = this.getElement('#start-btn');
                        this.simulateClick(startBtn);
                        await this.wait(500); // Wait for enemies to spawn

                        // Check if there are any enemies or obstacles
                        const enemies = this.gameWindow.enemies?.filter(e => e.userData?.active) || [];
                        const obstacles = this.gameWindow.obstacles?.filter(o => o.userData?.active && !o.userData?.hit) || [];

                        if (enemies.length === 0 && obstacles.length === 0) {
                            // No targets, test passes
                            return;
                        }

                        // Crosshair should be visible and positioned
                        const crosshair = this.getElement('#crosshair');
                        if (!crosshair) {
                            throw new Error('Crosshair element not found');
                        }

                        // Auto-aim should have moved crosshair from center
                        // (it tracks targets automatically)
                        const style = crosshair.style;
                        if (!style.left || !style.top) {
                            throw new Error('Crosshair position not set');
                        }
                    }
                );

                this.addTest('movement-bounds-check', 'Player Movement', 'Cart stays within bounds',
                    'Verifies cart cannot move outside game boundaries',
                    async () => {
                        this.resetGame();
                        await this.wait(100);

                        const startBtn = this.getElement('#start-btn');
                        this.simulateClick(startBtn);
                        await this.wait(200);

                        // Game uses MOVEMENT_BOUND = 10, so valid range is [-10, 10]
                        const MOVEMENT_BOUND = 10;

                        // Move far left using Arrow Left
                        this.simulateKeyDown('ArrowLeft');
                        await this.wait(400);
                        this.simulateKeyUp('ArrowLeft');
                        await this.wait(100);

                        const leftX = this.gameWindow.playerX || 0;
                        if (leftX < -MOVEMENT_BOUND - 0.5) {
                            throw new Error(`Cart moved outside left boundary. X position: ${leftX}, Min allowed: ${-MOVEMENT_BOUND}`);
                        }

                        // Move far right using Arrow Right
                        this.simulateKeyDown('ArrowRight');
                        await this.wait(800);
                        this.simulateKeyUp('ArrowRight');
                        await this.wait(100);

                        const rightX = this.gameWindow.playerX || 0;
                        if (rightX > MOVEMENT_BOUND + 0.5) {
                            throw new Error(`Cart moved outside right boundary. X position: ${rightX}, Max allowed: ${MOVEMENT_BOUND}`);
                        }
                    }
                );

                this.addTest('movement-disabled-when-paused', 'Player Movement', 'Controls disabled when paused',
                    'Verifies movement controls do not work when game is paused',
                    async () => {
                        this.resetGame();
                        await this.wait(100);

                        const startBtn = this.getElement('#start-btn');
                        this.simulateClick(startBtn);
                        await this.wait(200);

                        // Pause the game
                        this.simulateKeyDown('Escape');
                        await this.wait(200);

                        if (this.getGameState() !== 'PAUSED') {
                            throw new Error('Game not paused');
                        }

                        const initialX = this.gameWindow.playerX || 0;

                        // Try to move while paused using Arrow keys
                        this.simulateKeyDown('ArrowLeft');
                        this.simulateKeyDown('ArrowRight');
                        await this.wait(100);

                        const newX = this.gameWindow.playerX || 0;
                        if (newX !== initialX) {
                            throw new Error(`Cart moved while paused. Initial: ${initialX}, New: ${newX}`);
                        }
                    }
                );

                // Player Health UI Tests
                this.addTest('health-bar-visible', 'Player Health UI', 'Health bar visible in HUD',
                    'Verifies health bar is visible in HUD during gameplay',
                    async () => {
                        this.resetGame();
                        await this.wait(100);
                        const startBtn = this.getElement('#start-btn');
                        this.simulateClick(startBtn);
                        await this.wait(200);

                        const healthBar = this.getElement('#health-bar') || this.getElement('.health-bar') || this.getElement('[class*="health"]');
                        if (!healthBar) {
                            throw new Error('Health bar element not found in HUD');
                        }
                        if (!this.isVisible(healthBar)) {
                            throw new Error('Health bar is not visible');
                        }
                    }
                );

                this.addTest('health-bar-100-at-start', 'Player Health UI', 'Health bar shows 100% at start',
                    'Verifies health bar shows full health at game start',
                    async () => {
                        this.resetGame();
                        await this.wait(100);
                        const startBtn = this.getElement('#start-btn');
                        this.simulateClick(startBtn);
                        await this.wait(200);

                        const health = this.gameWindow.health || this.gameWindow.cart?.health || this.gameWindow.playerHealth || 100;
                        const maxHealth = this.gameWindow.maxHealth || this.gameWindow.cart?.maxHealth || 100;

                        if (health !== maxHealth) {
                            throw new Error(`Health not at max on start. Current: ${health}, Max: ${maxHealth}`);
                        }

                        const healthFill = this.getElement('#health-fill') || this.getElement('.health-fill') || this.getElement('[class*="health-fill"]');
                        if (healthFill) {
                            const width = parseFloat(this.gameWindow.getComputedStyle(healthFill).width);
                            const parentWidth = parseFloat(this.gameWindow.getComputedStyle(healthFill.parentElement).width);
                            const percentage = (width / parentWidth) * 100;
                            if (percentage < 95) {
                                throw new Error(`Health bar not showing 100%. Showing approximately ${percentage.toFixed(1)}%`);
                            }
                        }
                    }
                );

                this.addTest('health-bar-element-id', 'Player Health UI', 'Health bar element exists with correct ID',
                    'Verifies health bar element has correct ID attribute',
                    async () => {
                        this.resetGame();
                        await this.wait(100);
                        const startBtn = this.getElement('#start-btn');
                        this.simulateClick(startBtn);
                        await this.wait(200);

                        const healthBar = this.getElement('#health-bar');
                        if (!healthBar) {
                            const altHealthBar = this.getElement('.health-bar') || this.getElement('[class*="health"]');
                            if (altHealthBar) {
                                throw new Error('Health bar exists but does not have id="health-bar"');
                            }
                            throw new Error('Health bar element with id="health-bar" not found');
                        }
                    }
                );

                this.addTest('damage-overlay-flash', 'Player Health UI', 'Damage overlay flashes on hit',
                    'Verifies damage overlay flashes when player takes damage',
                    async () => {
                        this.resetGame();
                        await this.wait(100);
                        const startBtn = this.getElement('#start-btn');
                        this.simulateClick(startBtn);
                        await this.wait(300);

                        const damageOverlay = this.getElement('#damage-overlay');
                        if (!damageOverlay) {
                            throw new Error('Damage overlay element not found');
                        }

                        // Verify we're in PLAYING state and not invulnerable
                        if (this.getGameState() !== 'PLAYING') {
                            throw new Error(`Not in PLAYING state, got ${this.getGameState()}`);
                        }

                        // Check initial state - should not have flash class
                        const hadFlashBefore = damageOverlay.classList.contains('flash');

                        // Call damagePlayer directly (it adds 'flash' class)
                        if (this.gameWindow.damagePlayer) {
                            this.gameWindow.damagePlayer(10);
                        }

                        // Check immediately after - should have flash class
                        const hasFlashAfter = damageOverlay.classList.contains('flash');

                        if (!hasFlashAfter && !hadFlashBefore) {
                            // Check if opacity changed as fallback
                            const opacity = parseFloat(this.gameWindow.getComputedStyle(damageOverlay).opacity) || 0;
                            if (opacity <= 0) {
                                throw new Error('Damage overlay did not flash (no flash class and opacity is 0)');
                            }
                        }

                        // Verify the flash class was added (even if briefly)
                        if (!hasFlashAfter && hadFlashBefore) {
                            throw new Error('Flash class was already present before damage');
                        }
                    }
                );

                this.addTest('gameover-wrecked-message', 'Player Health UI', 'Game over shows "WRECKED!" on death',
                    'Verifies game over screen displays "WRECKED!" message when player dies',
                    async () => {
                        this.resetGame();
                        await this.wait(100);

                        // Set health to 0 to simulate death
                        this.gameWindow.gameState = 'PLAYING';
                        this.gameWindow.health = 0;
                        if (this.gameWindow.cart) {
                            this.gameWindow.cart.health = 0;
                        }

                        // Trigger game over with died=true to get "WRECKED!" message
                        if (this.gameWindow.endGame) {
                            this.gameWindow.endGame(true); // Pass true for death
                        } else if (this.gameWindow.gameOver) {
                            this.gameWindow.gameOver(true);
                        }

                        await this.wait(200);

                        const gameoverScreen = this.getElement('#gameover-screen');
                        if (!this.isVisible(gameoverScreen)) {
                            throw new Error('Game over screen not visible');
                        }

                        const gameoverText = gameoverScreen.textContent || gameoverScreen.innerText;
                        if (!gameoverText.toUpperCase().includes('WRECKED')) {
                            throw new Error(`Game over screen does not contain "WRECKED!" message. Content: "${gameoverText.substring(0, 100)}..."`);
                        }
                    }
                );

                // Health Container Position Tests
                this.addTest('health-container-hidden-in-menu', 'Player Health UI', 'Health hidden in menu',
                    'Verifies health container is hidden when in menu state',
                    async () => {
                        this.resetGame();
                        await this.wait(200);

                        const healthContainer = this.getElement('#health-container');
                        if (!healthContainer) {
                            throw new Error('Health container element not found');
                        }

                        const computedStyle = this.gameWindow.getComputedStyle(healthContainer);
                        if (computedStyle.display !== 'none') {
                            throw new Error(`Health container should be hidden in menu, but display is: ${computedStyle.display}`);
                        }
                    }
                );

                this.addTest('health-container-visible-in-game', 'Player Health UI', 'Health visible during gameplay',
                    'Verifies health container is visible when playing',
                    async () => {
                        this.resetGame();
                        await this.wait(100);
                        const startBtn = this.getElement('#start-btn');
                        this.simulateClick(startBtn);
                        await this.wait(300);

                        const healthContainer = this.getElement('#health-container');
                        if (!healthContainer) {
                            throw new Error('Health container element not found');
                        }

                        const computedStyle = this.gameWindow.getComputedStyle(healthContainer);
                        if (computedStyle.display === 'none') {
                            throw new Error('Health container should be visible during gameplay');
                        }
                    }
                );

                this.addTest('health-container-hidden-when-paused', 'Player Health UI', 'Health hidden when paused',
                    'Verifies health container is hidden when game is paused',
                    async () => {
                        this.resetGame();
                        await this.wait(100);
                        const startBtn = this.getElement('#start-btn');
                        this.simulateClick(startBtn);
                        await this.wait(300);
                        this.simulateKeyDown('Escape');
                        await this.wait(300);

                        const healthContainer = this.getElement('#health-container');
                        const computedStyle = this.gameWindow.getComputedStyle(healthContainer);
                        if (computedStyle.display !== 'none') {
                            throw new Error(`Health container should be hidden when paused, but display is: ${computedStyle.display}`);
                        }
                    }
                );

                this.addTest('health-container-bottom-left-position', 'Player Health UI', 'Health bar at bottom-left',
                    'Verifies health container is positioned at bottom-left corner',
                    async () => {
                        this.resetGame();
                        await this.wait(100);
                        const startBtn = this.getElement('#start-btn');
                        this.simulateClick(startBtn);
                        await this.wait(300);

                        const healthContainer = this.getElement('#health-container');
                        const rect = healthContainer.getBoundingClientRect();
                        const windowHeight = this.gameWindow.innerHeight;

                        // Should be in bottom half and left side
                        if (rect.top < windowHeight / 2) {
                            throw new Error(`Health container is in top half (top: ${rect.top}px), expected bottom-left`);
                        }
                        if (rect.left > 200) {
                            throw new Error(`Health container is not on left side (left: ${rect.left}px), expected left side`);
                        }
                    }
                );

                this.addTest('health-no-overlap-with-score', 'Player Health UI', 'Health does not overlap score',
                    'Verifies health container does not overlap with score container',
                    async () => {
                        this.resetGame();
                        await this.wait(100);
                        const startBtn = this.getElement('#start-btn');
                        this.simulateClick(startBtn);
                        await this.wait(300);

                        const healthContainer = this.getElement('#health-container');
                        const scoreContainer = this.getElement('#score-container');

                        if (!healthContainer || !scoreContainer) {
                            throw new Error('Could not find health or score containers');
                        }

                        const healthRect = healthContainer.getBoundingClientRect();
                        const scoreRect = scoreContainer.getBoundingClientRect();

                        // Check for overlap
                        const overlaps = !(healthRect.right < scoreRect.left ||
                                          healthRect.left > scoreRect.right ||
                                          healthRect.bottom < scoreRect.top ||
                                          healthRect.top > scoreRect.bottom);

                        if (overlaps) {
                            throw new Error(`Health container overlaps with score container. Health: top=${healthRect.top}, Score: bottom=${scoreRect.bottom}`);
                        }
                    }
                );

                // FPS Weapon System Tests
                this.addTest('fps-weapon-visible-in-fps-mode', 'FPS Weapon', 'Slingshot visible in FPS mode',
                    'Verifies the FPS weapon (hands with slingshot) is visible during FPS gameplay',
                    async () => {
                        this.resetGame();
                        await this.wait(100);

                        // Ensure FPS mode is selected
                        const fpsBtn = this.getElement('#fps-btn');
                        if (fpsBtn) this.simulateClick(fpsBtn);
                        await this.wait(50);

                        const startBtn = this.getElement('#start-btn');
                        this.simulateClick(startBtn);
                        await this.wait(500);

                        // Check if fpsWeapon exists and is visible (v3.0 FPS only)
                        const fpsWeaponVisible = this.gameWindow.fpsWeapon?.visible;

                        if (!fpsWeaponVisible) {
                            throw new Error('FPS weapon should be visible');
                        }
                    }
                );

                // v3.0 - Third-person mode removed, FPS only
                this.addTest('fps-only-mode', 'FPS Mode', 'Game is FPS only in v3.0',
                    'Verifies the game runs in FPS mode only (no third-person)',
                    async () => {
                        this.resetGame();
                        await this.wait(100);

                        const startBtn = this.getElement('#start-btn');
                        this.simulateClick(startBtn);
                        await this.wait(500);

                        // FPS weapon should always be visible in v3.0
                        const fpsWeaponVisible = this.gameWindow.fpsWeapon?.visible;
                        if (!fpsWeaponVisible) {
                            throw new Error('FPS weapon should be visible in v3.0');
                        }

                        // Child model should be hidden (we ARE the child in FPS)
                        const childVisible = this.gameWindow.playerChild?.visible;
                        if (childVisible === true) {
                            throw new Error('Child model should be hidden in FPS mode');
                        }
                    }
                );

                this.addTest('child-hidden-in-fps', 'FPS Mode', 'Child model hidden in FPS mode',
                    'Verifies the child character is hidden when in FPS mode (camera is the child)',
                    async () => {
                        this.resetGame();
                        await this.wait(100);

                        const startBtn = this.getElement('#start-btn');
                        this.simulateClick(startBtn);
                        await this.wait(500);

                        const childVisible = this.gameWindow.playerChild?.visible;
                        if (childVisible === true) {
                            throw new Error('Child model should be hidden in FPS mode');
                        }
                    }
                );

                this.addTest('camera-follows-player', 'FPS Mode', 'Camera follows player position',
                    'Verifies camera position matches player position',
                    async () => {
                        this.resetGame();
                        await this.wait(100);

                        const startBtn = this.getElement('#start-btn');
                        this.simulateClick(startBtn);
                        await this.wait(500);

                        const camera = this.gameWindow.camera;
                        const playerPos = this.gameWindow.playerPosition;
                        if (!camera || !playerPos) {
                            throw new Error('Camera or player position not found');
                        }

                        // Camera should be at player position
                        const xDiff = Math.abs(camera.position.x - playerPos.x);
                        const zDiff = Math.abs(camera.position.z - playerPos.z);
                        if (xDiff > 1 || zDiff > 1) {
                            throw new Error(`Camera not following player. Diff X: ${xDiff}, Z: ${zDiff}`);
                        }
                    }
                );

                // FPS Weapon State Tests (NERF Gun Auto-Fire)
                this.addTest('fps-charging-starts', 'FPS Charging', 'Firing state activates on button press',
                    'Verifies that firing state activates when player presses fire button',
                    async () => {
                        this.resetGame();
                        await this.wait(100);

                        // v3.0 is FPS only, no mode selection needed
                        const startBtn = this.getElement('#start-btn');
                        this.simulateClick(startBtn);
                        await this.wait(500);

                        // Simulate starting fire
                        this.gameWindow.startFiring();
                        await this.wait(50);

                        const isFiring = this.gameWindow.isFiring;
                        if (!isFiring) {
                            throw new Error('isFiring should be true when startFiring() is called');
                        }

                        // Clean up
                        this.gameWindow.stopFiring();
                    }
                );

                this.addTest('fps-tension-builds', 'FPS Charging', 'Slingshot tension builds while charging',
                    'Verifies that holding fire builds slingshot tension over time',
                    async () => {
                        this.resetGame();
                        await this.wait(100);

                        // v3.0 is FPS only, no mode selection needed
                        const startBtn = this.getElement('#start-btn');
                        this.simulateClick(startBtn);
                        await this.wait(500);

                        // Reset cooldown
                        this.gameWindow.lastShootTime = 0;
                        if (this.gameWindow.WeaponSystem) {
                            this.gameWindow.WeaponSystem.lastFireTime = 0;
                        }

                        const initialTension = this.gameWindow.slingshotTension || 0;

                        // Start charging
                        this.gameWindow.startCharging();
                        await this.wait(50);

                        // Run manual updates to build tension
                        for (let i = 0; i < 10; i++) {
                            this.gameWindow.manualUpdate(0.1); // 100ms per update
                            await this.wait(10);
                        }

                        const finalTension = this.gameWindow.slingshotTension || 0;

                        // Release without firing (cancel)
                        this.gameWindow.cancelCharging();

                        if (finalTension <= initialTension) {
                            throw new Error(`Tension should build during charge: initial=${initialTension}, final=${finalTension}`);
                        }
                    }
                );

                this.addTest('fps-weapon-renders', 'FPS Weapon', 'FPS weapon renders in scene',
                    'Verifies that the FPS weapon is actually added to camera and renders',
                    async () => {
                        this.resetGame();
                        await this.wait(100);

                        // v3.0 is FPS only, no mode selection needed
                        const startBtn = this.getElement('#start-btn');
                        this.simulateClick(startBtn);
                        await this.wait(500);

                        // Check that camera has fpsWeapon as child
                        const camera = this.gameWindow.camera;
                        const fpsWeapon = this.gameWindow.fpsWeapon;

                        if (!fpsWeapon) {
                            throw new Error('fpsWeapon object should exist');
                        }
                        if (!camera) {
                            throw new Error('camera object should exist');
                        }

                        // Check if fpsWeapon is a child of camera
                        let isChild = false;
                        camera.children.forEach(child => {
                            if (child === fpsWeapon) isChild = true;
                        });

                        if (!isChild) {
                            throw new Error('fpsWeapon should be a child of camera for rendering');
                        }

                        // Camera must be in scene for children to render
                        if (!camera.parent) {
                            throw new Error('Camera must be added to scene (camera.parent should exist)');
                        }
                    }
                );

                this.addTest('fps-release-fires', 'FPS Charging', 'Slingshot fires on release',
                    'Verifies that releasing after charging fires a projectile',
                    async () => {
                        // Wait for game to fully initialize (up to 5 seconds)
                        let attempts = 0;
                        while (attempts < 50) {
                            if (this.gameWindow.camera && this.gameWindow.camera.position) {
                                break;
                            }
                            await this.wait(100);
                            attempts++;
                        }

                        if (!this.gameWindow.camera || !this.gameWindow.camera.position) {
                            throw new Error('Game failed to initialize - camera not ready');
                        }

                        this.resetGame();
                        await this.wait(300);

                        const startBtn = this.getElement('#start-btn');
                        if (!startBtn) {
                            throw new Error('Start button not found');
                        }
                        this.simulateClick(startBtn);
                        await this.wait(1000);  // Longer wait for game to fully start

                        // Verify game is in PLAYING state
                        if (this.gameWindow.gameState !== 'PLAYING') {
                            throw new Error(`Game not in PLAYING state: ${this.gameWindow.gameState}`);
                        }

                        // Reset cooldown to ensure we can fire
                        this.gameWindow.lastShootTime = 0;
                        if (this.gameWindow.WeaponSystem) {
                            this.gameWindow.WeaponSystem.lastFireTime = 0;
                        }

                        const initialProjectiles = this.gameWindow.projectiles?.length || 0;

                        // Verify camera still exists before shooting
                        const cam = this.gameWindow.camera;
                        if (!cam) {
                            throw new Error('Camera became undefined during test');
                        }
                        if (!cam.position) {
                            throw new Error('Camera exists but position is undefined');
                        }

                        // Slingshot: start charging, build tension, then release
                        this.gameWindow.startCharging();
                        await this.wait(50);

                        // Build some tension
                        for (let i = 0; i < 5; i++) {
                            this.gameWindow.manualUpdate(0.1);
                            await this.wait(10);
                        }

                        // Release and fire
                        this.gameWindow.releaseAndFire();
                        await this.wait(50);

                        // Check that projectile was created
                        const projectilesAfterFire = this.gameWindow.projectiles?.length || 0;

                        if (projectilesAfterFire <= initialProjectiles) {
                            throw new Error(`Projectile should be created on release: initial=${initialProjectiles}, afterFire=${projectilesAfterFire}`);
                        }
                    }
                );

                // === PROJECTILE SYSTEM TESTS ===
                // Tests for projectile creation, movement, and collision

                this.addTest('projectile-creation', 'Projectile System', 'Projectiles are created when shooting',
                    'Verifies that shooting creates a projectile object in the scene',
                    async () => {
                        this.resetGame();
                        await this.wait(100);
                        const startBtn = this.getElement('#start-btn');
                        this.simulateClick(startBtn);
                        await this.wait(500);  // Longer wait for game to fully start

                        // Reset cooldown to ensure we can fire
                        this.gameWindow.lastShootTime = 0;
                        if (this.gameWindow.weapon) {
                            this.gameWindow.weapon.lastFireTime = 0;
                        }

                        const initialCount = this.gameWindow.projectiles?.length || 0;

                        // NERF gun fires immediately on startFiring
                        this.gameWindow.startFiring();
                        await this.wait(100);  // Longer wait
                        this.gameWindow.stopFiring();
                        await this.wait(100);

                        let newCount = this.gameWindow.projectiles?.length || 0;

                        // If still no projectile, try direct fire as fallback
                        if (newCount <= initialCount && this.gameWindow.fireWeapon) {
                            this.gameWindow.lastShootTime = 0;
                            if (this.gameWindow.weapon) {
                                this.gameWindow.weapon.lastFireTime = 0;
                            }
                            this.gameWindow.fireWeapon(200);
                            await this.wait(50);
                            newCount = this.gameWindow.projectiles?.length || 0;
                        }

                        if (newCount <= initialCount) {
                            throw new Error(`Projectile not created: before=${initialCount}, after=${newCount}`);
                        }
                    }
                );

                this.addTest('projectile-movement', 'Projectile System', 'Projectiles move after creation',
                    'Verifies that projectiles travel through the scene',
                    async () => {
                        this.resetGame();
                        await this.wait(100);
                        const startBtn = this.getElement('#start-btn');
                        this.simulateClick(startBtn);
                        await this.wait(300);

                        // Reset cooldown
                        this.gameWindow.lastShootTime = 0;
                        if (this.gameWindow.weapon) {
                            this.gameWindow.weapon.lastFireTime = 0;
                        }

                        // Fire a projectile
                        this.gameWindow.startFiring();
                        await this.wait(50);
                        this.gameWindow.stopFiring();
                        await this.wait(50);

                        const projectiles = this.gameWindow.projectiles || [];
                        if (projectiles.length === 0) {
                            throw new Error('No projectile created');
                        }

                        const proj = projectiles[projectiles.length - 1];
                        const initialZ = proj.position.z;

                        // Wait for movement
                        await this.wait(200);

                        // Projectile should have moved (manual update if needed)
                        if (this.gameWindow.manualUpdate) {
                            this.gameWindow.manualUpdate(0.1);
                        }
                        await this.wait(50);

                        const newZ = proj.position.z;
                        if (Math.abs(newZ - initialZ) < 0.5) {
                            throw new Error(`Projectile did not move: initial=${initialZ}, current=${newZ}`);
                        }
                    }
                );

                this.addTest('projectile-cleanup', 'Projectile System', 'Projectiles are cleaned up when out of bounds',
                    'Verifies that projectiles are removed when they go too far',
                    async () => {
                        this.resetGame();
                        await this.wait(100);
                        const startBtn = this.getElement('#start-btn');
                        this.simulateClick(startBtn);
                        await this.wait(500);  // Longer wait for game init

                        // Reset cooldown
                        this.gameWindow.lastShootTime = 0;
                        if (this.gameWindow.weapon) {
                            this.gameWindow.weapon.lastFireTime = 0;
                        }

                        const initialCount = this.gameWindow.projectiles?.length || 0;

                        // Fire a projectile
                        this.gameWindow.startFiring();
                        await this.wait(100);  // Longer wait
                        this.gameWindow.stopFiring();
                        await this.wait(100);

                        const projectiles = this.gameWindow.projectiles || [];
                        if (projectiles.length <= initialCount) {
                            // Try manual fire as fallback
                            if (this.gameWindow.fireWeapon) {
                                this.gameWindow.fireWeapon(200);
                                await this.wait(50);
                            }
                        }

                        if (projectiles.length === 0) {
                            throw new Error('No projectile created');
                        }

                        const proj = projectiles[projectiles.length - 1];
                        // Force it far away (beyond 250 unit limit)
                        proj.position.set(1000, 1000, 1000);

                        // Trigger update
                        if (this.gameWindow.manualUpdate) {
                            this.gameWindow.manualUpdate(0.016);
                        }
                        await this.wait(100);

                        // Projectile should be marked inactive
                        if (proj.userData && proj.userData.active) {
                            throw new Error('Projectile should be inactive when out of bounds');
                        }
                    }
                );

                // === WALL BUMP EFFECT TESTS ===

                this.addTest('wall-bump-trigger', 'Wall Bump', 'Wall bump can be triggered',
                    'Verifies the wall bump effect system responds to triggers',
                    async () => {
                        this.resetGame();
                        await this.wait(100);
                        const startBtn = this.getElement('#start-btn');
                        this.simulateClick(startBtn);
                        await this.wait(300);

                        // Trigger a wall bump
                        if (this.gameWindow.triggerWallBump) {
                            this.gameWindow.triggerWallBump(0.8, -1, 0);
                        }
                        await this.wait(50);

                        const intensity = this.gameWindow.wallBumpIntensity || 0;
                        // Intensity may have decayed slightly due to game loop, but should still be positive
                        if (intensity < 0.1) {
                            throw new Error(`Wall bump intensity should be positive after trigger: ${intensity}`);
                        }
                    }
                );

                this.addTest('wall-bump-decay', 'Wall Bump', 'Wall bump decays over time',
                    'Verifies the wall bump effect decays after being triggered',
                    async () => {
                        this.resetGame();
                        await this.wait(100);
                        const startBtn = this.getElement('#start-btn');
                        this.simulateClick(startBtn);
                        await this.wait(300);

                        // Trigger a wall bump
                        if (this.gameWindow.triggerWallBump) {
                            this.gameWindow.triggerWallBump(1.0, -1, 0);
                        }

                        const initialIntensity = this.gameWindow.wallBumpIntensity || 0;

                        // Run several updates to decay
                        for (let i = 0; i < 10; i++) {
                            if (this.gameWindow.manualUpdate) {
                                this.gameWindow.manualUpdate(0.016);
                            }
                        }
                        await this.wait(50);

                        const finalIntensity = this.gameWindow.wallBumpIntensity || 0;
                        if (finalIntensity >= initialIntensity * 0.5) {
                            throw new Error(`Bump should decay: initial=${initialIntensity}, final=${finalIntensity}`);
                        }
                    }
                );

                // === PROJECTILE DIRECTION TESTS ===
                // Verify projectiles travel forward, not sideways

                this.addTest('projectile-travels-forward', 'Projectile Direction', 'Projectiles travel forward',
                    'Verifies that projectiles move in the forward direction based on player rotation',
                    async () => {
                        this.resetGame();
                        await this.wait(100);
                        const startBtn = this.getElement('#start-btn');
                        this.simulateClick(startBtn);
                        await this.wait(300);

                        // Reset cooldown
                        this.gameWindow.lastShootTime = 0;
                        if (this.gameWindow.weapon) {
                            this.gameWindow.weapon.lastFireTime = 0;
                        }

                        const initialProjCount = this.gameWindow.projectiles?.length || 0;

                        // Fire a projectile
                        this.gameWindow.startFiring();
                        await this.wait(50);
                        this.gameWindow.stopFiring();

                        const projectiles = this.gameWindow.projectiles || [];
                        if (projectiles.length <= initialProjCount) {
                            throw new Error('No projectile created');
                        }

                        const proj = projectiles[projectiles.length - 1];
                        const velocity = proj.userData?.velocity;
                        if (!velocity) {
                            throw new Error('Projectile has no velocity');
                        }

                        // Velocity should primarily be in the -Z direction (forward)
                        // Z component should be negative and larger in magnitude than X
                        if (velocity.z >= 0) {
                            throw new Error(`Projectile should travel forward (-Z): z=${velocity.z}`);
                        }
                        if (Math.abs(velocity.x) > Math.abs(velocity.z)) {
                            throw new Error(`Projectile traveling sideways more than forward: x=${velocity.x}, z=${velocity.z}`);
                        }
                    }
                );

                // === ENEMY SPAWNING TESTS ===
                // Verify enemies continue to spawn

                this.addTest('enemies-exist-in-game', 'Enemy Spawning', 'Enemies array exists in game',
                    'Verifies that the enemies array is accessible and game supports enemy spawning',
                    async () => {
                        this.resetGame();
                        await this.wait(100);
                        const startBtn = this.getElement('#start-btn');
                        this.simulateClick(startBtn);
                        await this.wait(500);

                        // Run many updates to trigger spawning (2% chance per frame)
                        for (let i = 0; i < 100; i++) {
                            if (this.gameWindow.manualUpdate) {
                                this.gameWindow.manualUpdate(0.016);
                            }
                        }
                        await this.wait(100);

                        // Check that enemies array exists (spawning system is in place)
                        const enemies = this.gameWindow.enemies;
                        if (!enemies) {
                            throw new Error('Enemies array not found - spawning system missing');
                        }

                        // Enemies may or may not have spawned yet (depends on room position)
                        // Just verify the array is accessible
                        if (!Array.isArray(enemies)) {
                            throw new Error('Enemies should be an array');
                        }
                    }
                );

                // === VISUAL RENDERING TESTS ===
                // These tests verify the Three.js canvas actually renders content

                this.addTest('visual-canvas-exists', 'Visual Rendering', 'Canvas element exists',
                    'Verifies the Three.js canvas element is present in the DOM',
                    async () => {
                        this.resetGame();
                        await this.wait(200);
                        const canvas = this.gameDocument.querySelector('canvas');
                        if (!canvas) {
                            throw new Error('Canvas element not found');
                        }
                        if (canvas.width === 0 || canvas.height === 0) {
                            throw new Error('Canvas has zero dimensions');
                        }
                    }
                );

                this.addTest('visual-canvas-renders', 'Visual Rendering', 'Renderer has made draw calls',
                    'Verifies the renderer is actively drawing content',
                    async () => {
                        this.resetGame();
                        await this.wait(100);
                        const startBtn = this.getElement('#start-btn');
                        this.simulateClick(startBtn);
                        await this.wait(300);

                        const renderer = this.gameWindow.renderer;
                        if (!renderer) throw new Error('Renderer not found');

                        const info = renderer.info;
                        if (!info) throw new Error('Renderer info not available');

                        // Check renderer has made draw calls (triangles rendered)
                        if (info.render.triangles === 0) {
                            throw new Error('Renderer has not drawn any triangles');
                        }

                        // Check scene has visible geometry
                        const scene = this.gameWindow.scene;
                        if (!scene || scene.children.length < 3) {
                            throw new Error('Scene appears empty or has too few objects');
                        }
                    }
                );

                this.addTest('visual-scene-has-objects', 'Visual Rendering', 'Scene contains 3D objects',
                    'Verifies the Three.js scene has objects (environment, cart, etc)',
                    async () => {
                        this.resetGame();
                        await this.wait(200);

                        const scene = this.gameWindow.scene;
                        if (!scene) throw new Error('Scene not found');

                        // Check scene has children (floor, walls, cart, etc)
                        if (scene.children.length < 5) {
                            throw new Error(`Scene has too few objects: ${scene.children.length}`);
                        }
                    }
                );

                this.addTest('visual-renderer-works', 'Visual Rendering', 'Renderer is functioning',
                    'Verifies the WebGL renderer is initialized and working',
                    async () => {
                        this.resetGame();
                        await this.wait(200);

                        const renderer = this.gameWindow.renderer;
                        if (!renderer) throw new Error('Renderer not found');

                        // Check renderer info
                        const info = renderer.info;
                        if (!info) throw new Error('Renderer info not available');

                        // Verify renderer has done some rendering
                        const startBtn = this.getElement('#start-btn');
                        this.simulateClick(startBtn);
                        await this.wait(300);

                        // Check render count increased
                        if (info.render.calls === 0) {
                            throw new Error('Renderer has not made any draw calls');
                        }
                    }
                );

                this.addTest('visual-camera-positioned', 'Visual Rendering', 'Camera is properly positioned',
                    'Verifies camera position is valid (not at origin, inside scene)',
                    async () => {
                        this.resetGame();
                        await this.wait(100);
                        const startBtn = this.getElement('#start-btn');
                        this.simulateClick(startBtn);
                        await this.wait(200);

                        const camera = this.gameWindow.camera;
                        if (!camera) throw new Error('Camera not found');

                        // Camera should be above ground
                        if (camera.position.y < 1) {
                            throw new Error(`Camera too low: y=${camera.position.y}`);
                        }

                        // Camera should have valid projection matrix
                        if (!camera.projectionMatrix || camera.projectionMatrix.elements[0] === 0) {
                            throw new Error('Camera projection matrix not set');
                        }
                    }
                );

                this.addTest('visual-animation-running', 'Visual Rendering', 'Animation loop is running',
                    'Verifies the game animation loop is active and updating',
                    async () => {
                        this.resetGame();
                        await this.wait(100);
                        const startBtn = this.getElement('#start-btn');
                        this.simulateClick(startBtn);
                        await this.wait(100);

                        // Record initial camera Z position
                        const camera = this.gameWindow.camera;
                        const initialZ = camera.position.z;

                        // Wait for animation frames
                        await this.wait(300);

                        // Camera should have moved (cart moves forward)
                        const newZ = camera.position.z;
                        if (Math.abs(newZ - initialZ) < 0.1) {
                            throw new Error('Animation not running - camera position unchanged');
                        }
                    }
                );

                // === SKELETON ENEMY MODEL TESTS ===

                this.addTest('skeleton-enemy-structure', 'Skeleton Enemy', 'Enemy has skeleton model structure',
                    'Verifies enemy carts have skeleton driver with proper bone structure',
                    async () => {
                        this.resetGame();
                        await this.wait(100);
                        const startBtn = this.getElement('#start-btn');
                        this.simulateClick(startBtn);
                        await this.wait(500);

                        // Directly test EnemyVisual.createEnemy (enemies don't spawn in entrance room)
                        const THREE = this.gameWindow.THREE;
                        const EnemyVisual = this.gameWindow.EnemyVisual;
                        const Enemy = this.gameWindow.Enemy;

                        if (!EnemyVisual || !Enemy) {
                            throw new Error('EnemyVisual or Enemy not found');
                        }

                        const config = Enemy.types.SKELETON;
                        const enemy = EnemyVisual.createEnemy(THREE, config);

                        if (!enemy || !enemy.children) {
                            throw new Error('Enemy has no children groups');
                        }

                        // Skeleton enemy mesh contains visual group which has cart + skeleton
                        let hasCartAndSkeleton = false;
                        enemy.traverse(child => {
                            if (child.userData && child.userData.skeleton && child.userData.cart) {
                                hasCartAndSkeleton = true;
                            }
                        });

                        // Also check the top-level userData
                        if (enemy.userData.skeleton && enemy.userData.cart) {
                            hasCartAndSkeleton = true;
                        }

                        if (!hasCartAndSkeleton) {
                            throw new Error('Enemy missing skeleton or cart in userData');
                        }
                    }
                );

                this.addTest('skeleton-enemy-userData', 'Skeleton Enemy', 'Enemy has proper userData',
                    'Verifies enemy carts have health, active, and drift properties',
                    async () => {
                        this.resetGame();
                        await this.wait(100);
                        const startBtn = this.getElement('#start-btn');
                        this.simulateClick(startBtn);
                        await this.wait(500);

                        // Directly test EnemyVisual.createEnemy (enemies don't spawn in entrance room)
                        const THREE = this.gameWindow.THREE;
                        const EnemyVisual = this.gameWindow.EnemyVisual;
                        const EnemySystem = this.gameWindow.EnemySystem;
                        const Enemy = this.gameWindow.Enemy;

                        if (!EnemyVisual || !EnemySystem || !Enemy) {
                            throw new Error('EnemyVisual, EnemySystem, or Enemy not found');
                        }

                        const config = Enemy.types.SKELETON;
                        const enemy = EnemyVisual.createEnemy(THREE, config);

                        // Get userData from EnemySystem
                        const enemyData = EnemySystem.createEnemyData('SKELETON');
                        Object.assign(enemy.userData, enemyData);

                        const ud = enemy.userData;
                        if (typeof ud.health !== 'number') {
                            throw new Error('Enemy missing health property');
                        }
                        if (typeof ud.active !== 'boolean') {
                            throw new Error('Enemy missing active property');
                        }
                        if (typeof ud.driftSpeed !== 'number') {
                            throw new Error('Enemy missing driftSpeed property');
                        }
                    }
                );

                // === SHELF DESIGN TESTS ===

                this.addTest('shelf-has-products', 'Shelf Design', 'Shelves have product items',
                    'Verifies that shelf units contain product meshes',
                    async () => {
                        this.resetGame();
                        await this.wait(200);

                        const scene = this.gameWindow.scene;
                        if (!scene) throw new Error('Scene not found');

                        // Find shelf groups (they contain multiple small meshes for products)
                        let shelfFound = false;
                        scene.traverse((obj) => {
                            // Shelves typically have many children (frame + shelves + products)
                            if (obj.children && obj.children.length > 10) {
                                shelfFound = true;
                            }
                        });

                        if (!shelfFound) {
                            throw new Error('No shelf structures found with products');
                        }
                    }
                );

                // === PRE-SPAWNING SYSTEM TESTS ===

                this.addTest('enemies-spawn-ahead', 'Pre-Spawning', 'Enemies spawn ahead of player',
                    'Verifies enemies exist in rooms player hasnt entered yet',
                    async () => {
                        this.resetGame();
                        await this.wait(100);
                        const startBtn = this.getElement('#start-btn');
                        this.simulateClick(startBtn);
                        await this.wait(300);

                        const enemies = this.gameWindow.enemies;
                        const camera = this.gameWindow.camera;

                        if (!enemies || enemies.length === 0) {
                            throw new Error('No enemies spawned at game start');
                        }

                        // At least one enemy should be ahead of the player (lower Z value)
                        const playerZ = camera.position.z;
                        const enemiesAhead = enemies.filter(e => e.position.z < playerZ - 5);

                        if (enemiesAhead.length === 0) {
                            throw new Error('No enemies spawned ahead of player position');
                        }
                    }
                );

                this.addTest('getAdjacentRooms-exposed', 'Pre-Spawning', 'getAdjacentRooms function accessible',
                    'Verifies the room connectivity function is exposed for testing',
                    async () => {
                        this.resetGame();
                        await this.wait(200);

                        // Check if mallGrid exists (room system)
                        const mallGrid = this.gameWindow.mallGrid;
                        if (!mallGrid) {
                            throw new Error('mallGrid not exposed for testing');
                        }

                        // Verify rooms exist
                        if (!mallGrid.rooms || mallGrid.rooms.length === 0) {
                            throw new Error('No rooms in mallGrid');
                        }
                    }
                );

                // === SAFE STARTING ROOM TESTS ===

                this.addTest('safe-room-no-enemies', 'Safe Room', 'Starting room has no enemies',
                    'Verifies the first room (1,2) never spawns enemies',
                    async () => {
                        this.resetGame();
                        await this.wait(100);
                        const startBtn = this.getElement('#start-btn');
                        this.simulateClick(startBtn);
                        await this.wait(500);

                        const enemies = this.gameWindow.enemies || [];
                        const mallGrid = this.gameWindow.mallGrid;
                        const ROOM_UNIT = 30;

                        // Find enemies in starting room (gridX: 1, gridZ: 2)
                        const startRoomCenterX = 1 * ROOM_UNIT + ROOM_UNIT / 2;
                        const startRoomCenterZ = 2 * ROOM_UNIT + ROOM_UNIT / 2;

                        const enemiesInStart = enemies.filter(e => {
                            if (!e.userData || !e.userData.active) return false;
                            const dx = Math.abs(e.position.x - startRoomCenterX);
                            const dz = Math.abs(e.position.z - startRoomCenterZ);
                            return dx < ROOM_UNIT / 2 && dz < ROOM_UNIT / 2;
                        });

                        if (enemiesInStart.length > 0) {
                            throw new Error(`Starting room should have no enemies, found ${enemiesInStart.length}`);
                        }
                    }
                );

                // === LINE OF SIGHT TESTS ===

                this.addTest('line-of-sight-function', 'Enemy AI', 'canEnemySeePlayer function exists',
                    'Verifies the line of sight check function is available',
                    async () => {
                        this.resetGame();
                        await this.wait(200);

                        const fn = this.gameWindow.canEnemySeePlayer;
                        if (typeof fn !== 'function') {
                            throw new Error('canEnemySeePlayer function not exposed');
                        }
                    }
                );

                // === COLLISION TESTS ===

                this.addTest('player-collision-exists', 'Collision', 'Player has collision detection',
                    'Verifies player cart collision system is active',
                    async () => {
                        this.resetGame();
                        await this.wait(100);
                        const startBtn = this.getElement('#start-btn');
                        this.simulateClick(startBtn);
                        await this.wait(200);

                        // Check if wall collision function exists
                        const fn = this.gameWindow.checkWallCollision;
                        if (typeof fn !== 'function') {
                            throw new Error('checkWallCollision function not exposed');
                        }
                    }
                );

                // === JOKER SMILE SKELETON TEST ===

                this.addTest('skeleton-has-teeth', 'Skeleton Enemy', 'Skeleton has teeth for smile',
                    'Verifies skeleton model includes teeth geometry',
                    async () => {
                        this.resetGame();
                        await this.wait(100);
                        const startBtn = this.getElement('#start-btn');
                        this.simulateClick(startBtn);
                        await this.wait(500);

                        // Directly test EnemyVisual.createEnemy (enemies don't spawn in entrance room)
                        const THREE = this.gameWindow.THREE;
                        const EnemyVisual = this.gameWindow.EnemyVisual;
                        const Enemy = this.gameWindow.Enemy;

                        if (!EnemyVisual || !Enemy) {
                            throw new Error('EnemyVisual or Enemy not found');
                        }

                        const config = Enemy.types.SKELETON;
                        const enemy = EnemyVisual.createEnemy(THREE, config);

                        // Check that enemy has many mesh children (detailed skeleton)
                        let meshCount = 0;
                        enemy.traverse(obj => {
                            if (obj.isMesh) meshCount++;
                        });

                        // Detailed skeleton with teeth should have 40+ meshes
                        if (meshCount < 40) {
                            throw new Error(`Skeleton lacks detail, only ${meshCount} meshes (need 40+)`);
                        }
                    }
                );
            }

            addTest(id, group, name, description, fn) {
                this.tests.push({ id, group, name, description, fn, status: 'pending', error: null, time: 0 });
            }

            renderTests() {
                const container = document.getElementById('test-list');
                container.innerHTML = '';

                const groups = {};
                this.tests.forEach(test => {
                    if (!groups[test.group]) groups[test.group] = [];
                    groups[test.group].push(test);
                });

                for (const [groupName, tests] of Object.entries(groups)) {
                    const groupDiv = document.createElement('div');
                    groupDiv.className = 'test-group';

                    const passCount = tests.filter(t => t.status === 'pass').length;
                    const header = document.createElement('div');
                    header.className = 'group-header';
                    header.innerHTML = `
                        <span>${groupName}</span>
                        <span class="group-count">${passCount}/${tests.length}</span>
                    `;
                    groupDiv.appendChild(header);

                    tests.forEach(test => {
                        const testDiv = document.createElement('div');
                        testDiv.className = 'test-item';
                        testDiv.dataset.testId = test.id;

                        let statusIcon = '-';
                        if (test.status === 'pass') statusIcon = '&#10003;';
                        else if (test.status === 'fail') statusIcon = '&#10007;';
                        else if (test.status === 'running') statusIcon = '...';

                        testDiv.innerHTML = `
                            <div class="test-status status-${test.status}">${statusIcon}</div>
                            <div class="test-info">
                                <div class="test-name">${test.name}</div>
                                <div class="test-desc">${test.description}</div>
                                ${test.error ? `<div class="test-error">${test.error}</div>` : ''}
                            </div>
                            <div class="test-time">${test.time ? test.time + 'ms' : ''}</div>
                        `;

                        testDiv.addEventListener('click', () => this.runSingleTest(test.id));
                        groupDiv.appendChild(testDiv);
                    });

                    container.appendChild(groupDiv);
                }

                this.updateSummary();
            }

            updateSummary() {
                this.results = { pass: 0, fail: 0, pending: 0 };
                this.tests.forEach(test => {
                    if (test.status === 'pass') this.results.pass++;
                    else if (test.status === 'fail') this.results.fail++;
                    else this.results.pending++;
                });

                document.getElementById('pass-count').textContent = this.results.pass;
                document.getElementById('fail-count').textContent = this.results.fail;
                document.getElementById('pending-count').textContent = this.results.pending;
                document.getElementById('total-count').textContent = this.tests.length;

                const progress = ((this.results.pass + this.results.fail) / this.tests.length) * 100;
                document.getElementById('test-progress').style.width = progress + '%';
            }

            async runTest(test) {
                test.status = 'running';
                test.error = null;
                this.currentTest = test;
                this.renderTests();
                this.log(`Running: ${test.name}`, 'info');

                const startTime = performance.now();
                try {
                    await test.fn();
                    test.status = 'pass';
                    test.time = Math.round(performance.now() - startTime);
                    this.log(`PASS: ${test.name} (${test.time}ms)`, 'success');
                } catch (error) {
                    test.status = 'fail';
                    test.error = error.message;
                    test.time = Math.round(performance.now() - startTime);
                    this.log(`FAIL: ${test.name} - ${error.message}`, 'error');
                }

                this.currentTest = null;
                this.renderTests();
            }

            async runSingleTest(testId) {
                if (this.isRunning) return;
                this.isRunning = true;

                const test = this.tests.find(t => t.id === testId);
                if (test) {
                    await this.runTest(test);
                }

                this.isRunning = false;
            }

            async runAllTests() {
                if (this.isRunning) return;
                this.isRunning = true;
                this.delay = parseInt(document.getElementById('test-delay').value) || 500;

                this.log('Starting all tests...', 'info');
                document.getElementById('run-all-btn').disabled = true;

                for (const test of this.tests) {
                    test.status = 'pending';
                    test.error = null;
                    test.time = 0;
                }
                this.renderTests();

                for (const test of this.tests) {
                    await this.runTest(test);
                    await this.wait(this.delay);
                }

                this.log(`Tests complete: ${this.results.pass} passed, ${this.results.fail} failed`,
                    this.results.fail > 0 ? 'warn' : 'success');

                document.getElementById('run-all-btn').disabled = false;
                this.isRunning = false;
            }

            reset() {
                this.tests.forEach(test => {
                    test.status = 'pending';
                    test.error = null;
                    test.time = 0;
                });
                this.resetGame();
                this.renderTests();
                this.log('Tests reset', 'info');
            }

            captureState() {
                const state = {
                    gameState: this.getGameState(),
                    score: this.getScore(),
                    distance: this.getDistance(),
                    menuVisible: this.isVisible(this.getElement('#menu-screen')),
                    hudVisible: this.isVisible(this.getElement('#hud')),
                    pauseVisible: this.isVisible(this.getElement('#pause-screen')),
                    gameoverVisible: this.isVisible(this.getElement('#gameover-screen')),
                    timestamp: new Date().toISOString()
                };

                this.log(`State captured: ${JSON.stringify(state)}`, 'info');
                console.log('Game State Capture:', state);

                // Copy to clipboard
                navigator.clipboard.writeText(JSON.stringify(state, null, 2)).then(() => {
                    this.log('State copied to clipboard', 'success');
                }).catch(() => {
                    this.log('Could not copy to clipboard', 'warn');
                });
            }
        }

        // Initialize
        const runner = new UITestRunner();
        window.runner = runner; // Expose for Puppeteer

        document.getElementById('game-frame').addEventListener('load', () => {
            runner.init();
        });

        document.getElementById('run-all-btn').addEventListener('click', () => runner.runAllTests());
        document.getElementById('reset-btn').addEventListener('click', () => runner.reset());
        document.getElementById('capture-btn').addEventListener('click', () => runner.captureState());
        document.getElementById('run-selected-btn').addEventListener('click', () => {
            runner.log('Click on a test to run it individually', 'info');
        });
    </script>
</body>
</html>
