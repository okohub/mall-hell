<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mall Hell</title>
    <link rel="stylesheet" href="./src/styles/main.css">
    <!-- Google Analytics (async, non-blocking) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-1GQ02MKM01"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-1GQ02MKM01');
    </script>
</head>
<body>
    <div id="game-container">
        <div id="ui-layer">
            <div id="crosshair"><div id="crosshair-circle"></div><div id="crosshair-dot"></div></div>

            <!-- Tension Indicator (ring around crosshair) -->
            <div id="tension-indicator">
                <svg viewBox="0 0 100 100">
                    <circle class="tension-bg" cx="50" cy="50" r="45"/>
                    <circle class="tension-fill" cx="50" cy="50" r="45"/>
                </svg>
                <div id="tension-text"></div>
            </div>

            <div id="hud">
                <div id="score-container">
                    <div id="score-label">CHAOS SCORE</div>
                    <div id="score">0</div>
                </div>

                <!-- Status Panel: Enemy Progress + Map -->
                <div id="status-panel">
                    <div id="enemy-progress-header">
                        <span class="progress-label">CLEARED</span>
                        <span id="enemy-progress">0 / 0</span>
                    </div>
                    <div class="enemy-type-counts">
                        <div class="enemy-type-count" id="skeleton-count">
                            <span class="enemy-icon">üíÄ</span>
                            <span class="enemy-value">0</span>
                        </div>
                        <div class="enemy-type-count" id="dino-count">
                            <span class="enemy-icon">ü¶ñ</span>
                            <span class="enemy-value">0</span>
                        </div>
                    </div>
                    <div id="minimap-section">
                        <div id="minimap-grid"></div>
                    </div>
                </div>

                <div id="timer-container">
                    <div id="timer-label">TIME REMAINING</div>
                    <div id="timer-display">3:00</div>
                    <div id="timer-bar">
                        <div id="timer-fill"></div>
                    </div>
                </div>

            </div>

            <div id="ammo-display">SLINGSHOT READY</div>

            <div id="health-container">
                <div id="health-label">HEALTH</div>
                <div id="health-bar">
                    <div id="health-fill"></div>
                </div>
                <div id="health-value">100</div>
            </div>


            <div id="hit-marker"></div>
            <div id="damage-overlay"></div>

            <!-- Objective Text (shown at game start) -->
            <div id="objective-display">
                <div class="objective-text">CLEAR THE MALL!</div>
                <div class="objective-subtext">Eliminate all enemies before time runs out</div>
            </div>


            <div id="menu-screen">
                <div class="menu-container">
                    <div class="title-wrapper">
                        <div class="title">MALL HELL</div>
                    </div>
                    <div class="version">VERSION 5.1</div>
                    <div class="subtitle">SUPERMARKET MAYHEM</div>
                    <div class="instructions" id="instructions">
                        <div class="control-item">
                            <span class="control-key">W / ‚Üë</span>
                            <span class="control-action">Drive</span>
                        </div>
                        <div class="control-item">
                            <span class="control-key">S / ‚Üì</span>
                            <span class="control-action">Reverse</span>
                        </div>
                        <div class="control-item">
                            <span class="control-key">A / ‚Üê</span>
                            <span class="control-action">Turn Left</span>
                        </div>
                        <div class="control-item">
                            <span class="control-key">D / ‚Üí</span>
                            <span class="control-action">Turn Right</span>
                        </div>
                        <div class="control-item">
                            <span class="control-key">SPACE</span>
                            <span class="control-action">Charge & Fire</span>
                        </div>
                    </div>
                    <div class="how-to-play-btn" id="how-to-play-btn">[ HOW TO PLAY ]</div>
                    <button class="btn" id="start-btn">START CHAOS</button>
                </div>
            </div>

            <div id="how-to-play-modal">
                <div class="modal-content">
                    <h2>HOW TO PLAY</h2>
                    <h3>YOU ARE A KID IN A SHOPPING CART</h3>
                    <p>Explore the mall and cause as much chaos as possible before time runs out!</p>
                    <h3>CONTROLS</h3>
                    <p><span class="key">W/S</span> Drive forward and reverse</p>
                    <p><span class="key">A/D</span> Dodge left and right to aim</p>
                    <p><span class="key">SPACE</span> Hold to charge your slingshot, release to fire</p>
                    <h3>AIMING</h3>
                    <p>Line up your crosshair with enemies by dodging left and right. Fire when ready!</p>
                    <h3>SCORING</h3>
                    <p>Hit enemies: +100 points<br>Destroy enemies: +300 points<br>Hit obstacles: +150 points</p>
                    <h3>TIP</h3>
                    <p>Explore all 16 mall sections to maximize your chaos score!</p>
                    <button class="modal-close" id="modal-close">GOT IT!</button>
                </div>
            </div>

            <div id="gameover-screen">
                <div class="menu-container">
                    <div class="title" id="gameover-title">CHECKOUT!</div>
                    <div id="final-score-container">
                        <div id="final-score-label">TOTAL CHAOS</div>
                        <div id="final-score">0</div>
                        <div id="rating">Mild Mischief</div>
                    </div>
                    <button class="btn" id="restart-btn">PLAY AGAIN</button>
                </div>
            </div>

            <div id="pause-screen">
                <div class="menu-container">
                    <div class="title">PAUSED</div>
                    <div class="pause-score">Current Chaos: <span id="pause-score-value">0</span></div>
                    <div class="pause-buttons">
                        <button class="pause-btn primary" id="resume-btn">RESUME</button>
                        <button class="pause-btn" id="quit-btn">QUIT TO MENU</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <!-- Shared Libraries -->
    <script src="./src/shared/materials-theme.js"></script>

    <!-- UI Domain -->
    <script src="./src/ui/ui.js"></script>
    <script src="./src/ui/ui-orchestrator.js"></script>

    <!-- Engine Domain (core systems - load first) -->
    <script src="./src/engine/engine.js"></script>
    <script src="./src/engine/collision-orchestrator.js"></script>
    <script src="./src/engine/input-orchestrator.js"></script>
    <script src="./src/engine/state-orchestrator.js"></script>
    <script src="./src/engine/loop-orchestrator.js"></script>
    <script src="./src/engine/scene-orchestrator.js"></script>
    <script src="./src/engine/entity-orchestrator.js"></script>
    <script src="./src/engine/game-session.js"></script>
    <script src="./src/engine/post-process-orchestrator.js"></script>
    <script src="./src/engine/analytics-orchestrator.js"></script>

    <!-- Room Domain -->
    <script src="./src/room/room.js"></script>
    <script src="./src/room/room-theme.js"></script>
    <script src="./src/room/room-mesh.js"></script>
    <script src="./src/room/room-orchestrator.js"></script>

    <!-- Player Domain -->
    <script src="./src/player/player.js"></script>
    <script src="./src/player/player-theme.js"></script>
    <script src="./src/player/player-mesh.js"></script>
    <script src="./src/player/player-orchestrator.js"></script>

    <!-- Weapon Domain -->
    <script src="./src/weapon/weapon.js"></script>
    <script src="./src/weapon/weapon-orchestrator.js"></script>

    <!-- Slingshot -->
    <script src="./src/weapon/slingshot-mesh.js"></script>
    <script src="./src/weapon/slingshot-animation.js"></script>
    <script src="./src/weapon/slingshot.js"></script>

    <!-- NerfGun -->
    <script src="./src/weapon/nerfgun-mesh.js"></script>
    <script src="./src/weapon/nerfgun-animation.js"></script>
    <script src="./src/weapon/nerfgun.js"></script>

    <!-- WaterGun -->
    <script src="./src/weapon/watergun-mesh.js"></script>
    <script src="./src/weapon/watergun-animation.js"></script>
    <script src="./src/weapon/watergun.js"></script>

    <!-- LaserGun -->
    <script src="./src/weapon/lasergun-mesh.js"></script>
    <script src="./src/weapon/lasergun-animation.js"></script>
    <script src="./src/weapon/lasergun.js"></script>

    <!-- Pickup System -->
    <script src="./src/weapon/pickup.js"></script>
    <script src="./src/weapon/pickup-orchestrator.js"></script>

    <!-- Projectile Domain -->
    <script src="./src/projectile/projectile.js"></script>
    <script src="./src/projectile/projectile-theme.js"></script>
    <script src="./src/projectile/projectile-mesh.js"></script>
    <script src="./src/projectile/projectile-orchestrator.js"></script>
    <script src="./src/particle/particle-orchestrator.js"></script>

    <!-- Enemy Domain -->
    <script src="./src/enemy/enemy.js"></script>

    <!-- Skeleton -->
    <script src="./src/enemy/skeleton-mesh.js"></script>
    <script src="./src/enemy/skeleton-animation.js"></script>
    <script src="./src/enemy/skeleton.js"></script>

    <!-- Dinosaur -->
    <script src="./src/enemy/dinosaur-mesh.js"></script>
    <script src="./src/enemy/dinosaur-animation.js"></script>
    <script src="./src/enemy/dinosaur.js"></script>

    <!-- Enemy modules -->
    <script src="./src/enemy/enemy-spawner.js"></script>
    <script src="./src/enemy/enemy-ai.js"></script>
    <script src="./src/enemy/enemy-collision.js"></script>

    <!-- Enemy orchestrator -->
    <script src="./src/enemy/enemy-orchestrator.js"></script>

    <!-- Environment Domain (Obstacles + Shelves) -->
    <script src="./src/environment/obstacle.js"></script>
    <script src="./src/environment/obstacle-theme.js"></script>
    <script src="./src/environment/obstacle-mesh.js"></script>
    <script src="./src/environment/shelf.js"></script>
    <script src="./src/environment/shelf-theme.js"></script>
    <script src="./src/environment/shelf-mesh.js"></script>
    <script src="./src/environment/environment-orchestrator.js"></script>
    <script src="./src/environment/spawn-orchestrator.js"></script>

    <script>
        // Domain modules loaded:
        // - Room: Room, RoomTheme, RoomMesh, RoomOrchestrator
        // - Player: Player, PlayerTheme, PlayerMesh, PlayerOrchestrator
        // - Weapon: Weapon, WeaponOrchestrator, Slingshot, WaterGun, LaserGun, NerfGun, WeaponPickup, PickupOrchestrator
        // - Projectile: Projectile, ProjectileTheme, ProjectileMesh (as ProjectileVisual), ProjectileOrchestrator
        // - Enemy: Enemy, Skeleton/Dinosaur (themes, mesh, animation), EnemyOrchestrator
        // - Environment: Obstacle, ObstacleTheme, ObstacleMesh (as ObstacleVisual), Shelf, ShelfTheme, ShelfMesh, EnvironmentOrchestrator

        // ============================================
        // GAME CONSTANTS
        // ============================================
        // Core constants used in index.html. Domain-specific values accessed via domain modules.

        const CROSSHAIR_BOUNDS_MARGIN = 50;

        // Domain constant aliases
        const PLAYER_MAX_HEALTH = Player.health.MAX;
        const CART_SPEED = Player.movement.SPEED;
        const MALL_THEMES = RoomTheme.themes;

        // ShelfSystem shim - delegates to Shelf for RoomOrchestrator compatibility
        const ShelfSystem = {
            getShelfTemplate: (id) => Shelf.getTemplate(id),
            getProductGeometry: (id) => Shelf.getProductType(id),
            pickProductColor: (theme) => Shelf.pickColor(theme.productColors || theme)
        };

        // Initialize RoomOrchestrator with layout from Room.layout
        RoomOrchestrator.init(Room, RoomTheme);
        RoomOrchestrator.loadLayout(MALL_THEMES);

        // Mall Grid interface (delegates to RoomOrchestrator)
        const mallGrid = RoomOrchestrator;

        // Game State - only variables that need local tracking
        let lastShootTime = 0;
        const cameraMode = 'hybrid-fps';    // v3.0 is FPS only

        // Three.js Setup
        let scene, camera, renderer;
        let projectiles = [];
        let enemies = [];
        let obstacles = [];
        let particles = [];
        let shelves = [];
        let ambientLight;
        let isFrozen = false;

        // Player mesh references
        let playerCart, playerChild, slingshotArm;

        // Room tracking
        let currentRoom = null;
        let visitedRooms = new Set();

        // Crosshair state
        let crosshairX = window.innerWidth / 2;
        let crosshairY = window.innerHeight / 2;

        // Locked target for sticky aim (don't switch until target gone)
        let lockedTarget = null;

        // Keyboard input handled by Input module (initialized later)

        // Clock handled by GameLoop module
        // Materials library loaded from src/shared/materials-theme.js

        // Scene hierarchy groups
        const sceneGroups = { environment: null, gameplay: null, effects: null, lighting: null };
        function initSceneGroups() {
            ['environment', 'gameplay', 'effects', 'lighting'].forEach(n => {
                sceneGroups[n] = new THREE.Group(); sceneGroups[n].name = n; scene.add(sceneGroups[n]);
            });
        }

        // Post-processing state
        let composer = null, damageVignetteStrength = 0;

        // DOM Elements (only what's needed - UIOrchestrator handles the rest)
        const container = document.getElementById('game-container');
        const scoreElement = document.getElementById('score');
        const hud = document.getElementById('hud');
        const ammoDisplay = document.getElementById('ammo-display');
        const healthContainer = document.getElementById('health-container');

        // Initialize Three.js using SceneOrchestrator
        function initThree() {
            SceneOrchestrator.init(THREE, container);
            scene = SceneOrchestrator.scene; camera = SceneOrchestrator.camera; renderer = SceneOrchestrator.renderer;
            MaterialsTheme.init(THREE); UIOrchestrator.init();
            AnalyticsOrchestrator.init({ measurementId: 'G-1GQ02MKM01', provider: 'gtag', debug: false });
            AnalyticsOrchestrator.gamePageView();
            initSceneGroups();

            // Lighting
            ambientLight = new THREE.AmbientLight(0xfff8f0, 0.6); scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(10, 20, 10); dirLight.castShadow = true;
            Object.assign(dirLight.shadow.mapSize, { width: 2048, height: 2048 });
            Object.assign(dirLight.shadow.camera, { near: 0.5, far: 100, left: -30, right: 30, top: 30, bottom: -30 });
            scene.add(dirLight);

            // Player and weapons
            createEnvironment();
            const p = PlayerMesh.createPlayerCart(THREE);
            playerCart = p.cart; playerChild = p.child; slingshotArm = p.slingshot;
            playerCart.position.set(0, 0, -5); scene.add(playerCart);
            WeaponOrchestrator.init(scene);
            [Slingshot, WaterGun, LaserGun, NerfGun].forEach(w => WeaponOrchestrator.register(w));
            WeaponOrchestrator.equip('slingshot', THREE, MaterialsTheme, camera);
            PickupOrchestrator.init(scene, THREE);
        }

        function initPostProcessing() {
            const r = PostProcessOrchestrator.init(THREE, renderer, scene, camera, { bloomStrength: 0.4, bloomThreshold: 0.8, damageIntensity: 0.0 });
            composer = r.composer; window.composer = composer;
        }

        function createEnvironment() {
            RoomOrchestrator.getAllRooms().forEach(room => room && RoomOrchestrator.createRoomMeshes(THREE, room, { scene, shelfArray: shelves, shelfOrchestrator: EnvironmentOrchestrator }));
        }

        function createEnemy(x, z, enemyType = 'SKELETON') {
            const g = EnemyOrchestrator.createMesh(THREE, enemyType, x, z);
            if (g) { scene.add(g); enemies.push(g); }
            return g;
        }

        function createObstacle(x, z, type) {
            const g = ObstacleVisual.createByType(THREE, type);
            g.position.set(x, 0, z);
            scene.add(g); obstacles.push(g);
            return g;
        }

        function createProjectile(direction, spawnPos, speed, fireResult = null) {
            const ps = WeaponOrchestrator.getProjectileSpeed();
            const projectileType = fireResult?.projectileType || 'stone';
            const g = ProjectileOrchestrator.createMesh(THREE, direction, spawnPos, speed ?? ps.max, {
                speedMin: ps.min,
                speedMax: ps.max,
                fallbackCamera: camera,
                projectileType: projectileType
            });
            scene.add(g); projectiles.push(g);
            return g;
        }

        function spawnParticles(pos, color, count) { ParticleOrchestrator.spawn(THREE, pos, color, count, particles, scene); }

        const addScore = (pts, pos) => GameSession.addScore(pts, pos);
        const startCharging = () => { if (!StateOrchestrator.is('PLAYING')) return; const r = WeaponOrchestrator.onFireStart(Date.now()); if (r) shoot(r.speed, r); };
        const updateCharging = (dt) => { const r = WeaponOrchestrator.update(dt, Date.now()); if (r) shoot(r.speed, r); };
        const cancelCharging = () => WeaponOrchestrator.cancelAction();
        const releaseAndFire = () => { const r = WeaponOrchestrator.onFireRelease(Date.now()); if (r) shoot(r.speed, r); };

        function shoot(speed, fireResult = null) {
            lastShootTime = Date.now();
            if (cameraMode === 'hybrid-fps') WeaponOrchestrator.triggerFireAnim();

            const { spawnPos, direction } = ProjectileOrchestrator.calculateFire(THREE, camera, crosshairX, crosshairY);
            if (fireResult?.spread) { direction.x += fireResult.spread.x; direction.y += fireResult.spread.y; direction.normalize(); }
            createProjectile(direction, spawnPos, speed, fireResult);
            updateAmmoDisplay();
        }

        function updateAmmoDisplay() {
            const ammo = WeaponOrchestrator.getAmmo();
            const display = WeaponOrchestrator.getAmmoDisplay() || 'READY';
            const isEmpty = ammo <= 0;
            ammoDisplay.textContent = isEmpty ? 'NO AMMO' : display;
            ammoDisplay.style.borderColor = isEmpty ? '#e94560' : '#3498db';
        }

        function resetGame() {
            lastShootTime = 0; isFrozen = false;
            GameSession.reset(); GameSession.setCamera(camera);
            InputOrchestrator.reset(); PlayerOrchestrator.reset();
            WeaponOrchestrator.reset(); WeaponOrchestrator.equip('slingshot', THREE, MaterialsTheme, camera);
            PickupOrchestrator.reset();
            SpawnOrchestrator.resetPlanning(); // Reset room planning state
            EnemyOrchestrator._dinoSpawnCount = 0; // Reset dino spawn tracking
            UIOrchestrator.resetEnemyProgress(); // Reset enemy progress tracking
            crosshairX = window.innerWidth / 2; crosshairY = window.innerHeight / 2;
            lockedTarget = null; currentRoom = null; visitedRooms.clear();
            scoreElement.textContent = '0'; updateTimerDisplay(); UIOrchestrator.resetHealthBar(PLAYER_MAX_HEALTH);
            [projectiles, enemies, obstacles, particles].forEach(arr => arr.forEach(o => scene.remove(o)));
            projectiles = []; enemies = []; obstacles = []; particles = [];
            playerCart.position.set(PlayerOrchestrator.position.x, 0, PlayerOrchestrator.position.z);
            playerCart.rotation.set(0, PlayerOrchestrator.rotation, 0);
            camera.position.set(PlayerOrchestrator.position.x, 2.2, PlayerOrchestrator.position.z);
            camera.rotation.set(-0.12, PlayerOrchestrator.rotation, 0);
        }

        const updateCursor = () => UIOrchestrator.updateCursor(StateOrchestrator.is('PLAYING'), renderer.domElement);

        function startGame() {
            resetGame(); GameSession.start(); StateOrchestrator.forceTransition('PLAYING'); UIOrchestrator.showGameplay();
            crosshairX = window.innerWidth / 2; crosshairY = window.innerHeight / 2;
            updateCursor(); spawnInitialObjects();
            // Initialize minimap with all rooms
            UIOrchestrator.initMinimap(RoomOrchestrator.getAllRooms());
            UIOrchestrator.showMinimap();
            // Show objective text
            UIOrchestrator.showObjective();
            AnalyticsOrchestrator.gameStart();
        }

        function endGame(died = false) {
            StateOrchestrator.forceTransition('GAME_OVER');
            const s = GameSession.getScore();
            const playTime = GameSession.DURATION - GameSession.getTimer();
            UIOrchestrator.showGameOver(s, UI.getScoreRating(s), died); updateCursor();
            AnalyticsOrchestrator.gameOver({ score: s, playTime: Math.round(playTime), died, rating: UI.getScoreRating(s) });
        }

        function damagePlayer(amount, source = 'unknown') {
            if (!StateOrchestrator.is('PLAYING') || !PlayerOrchestrator.damage(amount)) return;
            UIOrchestrator.updateHealthBar(PlayerOrchestrator.getHealth(), PLAYER_MAX_HEALTH);
            UIOrchestrator.showDamageOverlay();
            damageVignetteStrength = Math.min(1.0, damageVignetteStrength + amount / 50);
            AnalyticsOrchestrator.damageTaken(amount, source, PlayerOrchestrator.getHealth());
            if (PlayerOrchestrator.isDead()) endGame(true);
        }

        function pauseGame() {
            if (!StateOrchestrator.is('PLAYING')) return;
            StateOrchestrator.forceTransition('PAUSED'); cancelCharging();
            UIOrchestrator.showPause(GameSession.getScore()); updateCursor();
        }

        function resumeGame() {
            if (!StateOrchestrator.is('PAUSED')) return;
            StateOrchestrator.forceTransition('PLAYING'); UIOrchestrator.hidePause();
            LoopOrchestrator.resetDelta(); updateCursor();
        }

        function quitToMenu() {
            StateOrchestrator.forceTransition('MENU'); UIOrchestrator.showMenu(); resetGame(); updateCursor();
        }

        const togglePause = () => StateOrchestrator.is('PLAYING') ? pauseGame() : StateOrchestrator.is('PAUSED') ? resumeGame() : null;
        const toggleFreeze = () => { if (StateOrchestrator.is('PLAYING')) { isFrozen = !isFrozen; if (!isFrozen) LoopOrchestrator.resetDelta(); } };
        const updateTimerDisplay = () => UIOrchestrator.updateTimerDisplay(GameSession.getTimer(), GameSession.DURATION);

        // Spawn callbacks - passed to SpawnOrchestrator for mesh creation
        const spawnCallbacks = {
            createEnemy: (x, z, type) => {
                const enemy = createEnemy(x, z, type);
                if (type === 'DINOSAUR') UIOrchestrator.showBossWarning('DINO BOSS!');
                return enemy;
            },
            createObstacle: (x, z, type) => createObstacle(x, z, type),
            onRoomMaterialized: (room, roomKey) => {
                visitedRooms.add(roomKey);
                // Spawn weapon pickup in materialized room
                PickupOrchestrator.trySpawnForRoom(
                    { x: room.worldX, z: room.worldZ },
                    Room.structure.UNIT,
                    Room.structure.UNIT,
                    obstacles,
                    shelves
                );
            }
        };

        // Plan all rooms and spawn nearby ones (lazy loading for performance)
        function spawnInitialObjects() {
            // Phase 1: Plan all rooms (fast, data only - no mesh creation)
            const planResult = SpawnOrchestrator.planAllRooms(
                RoomOrchestrator.getAllRooms(),
                Room.structure,
                (score) => EnemyOrchestrator.getSpawnType(score),
                GameSession.getScore()
            );

            // Set total enemy count for progress tracking
            UIOrchestrator.setTotalEnemies(planResult.totalEnemies);

            // Phase 2: Materialize starting room + adjacent (uses RoomOrchestrator for spatial queries)
            const startRoom = mallGrid.getRoomAtWorld(PlayerOrchestrator.position.x, PlayerOrchestrator.position.z);
            SpawnOrchestrator.materializeNearbyRooms(startRoom, mallGrid, RoomOrchestrator, spawnCallbacks);
        }

        function updateCurrentRoom() {
            const room = mallGrid.getRoomAtWorld(PlayerOrchestrator.position.x, PlayerOrchestrator.position.z);
            if (room && room !== currentRoom) {
                currentRoom = room;
                // Materialize current room + adjacent rooms (RoomOrchestrator handles spatial logic)
                SpawnOrchestrator.materializeNearbyRooms(room, mallGrid, RoomOrchestrator, spawnCallbacks);
            }
        }

        function update(dt) {
            if (!StateOrchestrator.is('PLAYING') || isFrozen) return;

            // Update invulnerability
            PlayerOrchestrator.updateInvulnerability();

            // Update game timer via GameSession
            if (GameSession.updateTimer(dt)) {
                endGame(false); // Time's up
                return;
            }
            updateTimerDisplay();

            RoomOrchestrator.updateAmbientLighting(ambientLight, PlayerOrchestrator.position, mallGrid, THREE);
            // Player movement with collision against walls, obstacles, and shelves
            PlayerOrchestrator.fullUpdate({
                keys: InputOrchestrator.keys,
                dt,
                collisionCheck: (nX, nZ, oX, oZ) => CollisionOrchestrator.checkAllCollisions(nX, nZ, oX, oZ, {
                    gridOrchestrator: mallGrid,
                    roomConfig: Room.structure,
                    obstacles,
                    shelves,
                    playerRadius: Player.visual.COLLISION_RADIUS
                }),
                onCollision: (pos, dir, intensity) => {
                    // Spawn metal sparks on environment collision
                    const sparkCount = Math.ceil(3 + intensity * 5);
                    // Metal spark colors: bright orange, yellow, white-hot
                    const sparkColors = [0xff6600, 0xff9900, 0xffcc00, 0xffff66, 0xffffff];
                    for (let i = 0; i < sparkCount; i++) {
                        const color = sparkColors[Math.floor(Math.random() * sparkColors.length)];
                        ParticleOrchestrator.spawn(THREE, pos, color, 1, particles, scene, {
                            velocitySpread: 10 + intensity * 8,
                            upwardVelocity: { min: 3, max: 12 },
                            life: 0.2 + Math.random() * 0.3,
                            scale: 0.3 + Math.random() * 0.4  // Small sparks
                        });
                    }
                },
                cart: playerCart,
                camera
            });

            // Push player out of any overlapping objects (run multiple times for nested overlaps)
            for (let i = 0; i < 5; i++) {
                if (!CollisionOrchestrator.pushOutOfOverlaps(PlayerOrchestrator.position, obstacles, shelves, Player.visual.COLLISION_RADIUS)) break;
            }
            // Hard clamp to room bounds (last resort - never go through walls)
            CollisionOrchestrator.clampToRoomBounds(PlayerOrchestrator.position, mallGrid, Room.structure, Player.visual.COLLISION_RADIUS);
            playerCart.position.x = PlayerOrchestrator.position.x;
            playerCart.position.z = PlayerOrchestrator.position.z;

            // FPS mode
            playerCart.visible = true;
            if (playerChild) playerChild.visible = false;
            if (slingshotArm) slingshotArm.visible = false;
            if (WeaponOrchestrator.fpsMesh) { WeaponOrchestrator.showFPSWeapon(); WeaponOrchestrator.updateTransform(PlayerOrchestrator.currentTurnRate); }
            updateCharging(dt); WeaponOrchestrator.animateFPS(dt); updateAmmoDisplay(); updateCurrentRoom();

            // Auto-aim
            const aim = WeaponOrchestrator.updateAim({ camera, playerPosition: PlayerOrchestrator.position, enemies, obstacles, shelves, collisionOrchestrator: CollisionOrchestrator, gridOrchestrator: mallGrid, roomConfig: Room.structure, playerRadius: Player.visual.COLLISION_RADIUS, boundsMargin: CROSSHAIR_BOUNDS_MARGIN });
            crosshairX = aim.crosshairX; crosshairY = aim.crosshairY; lockedTarget = WeaponOrchestrator.getLockedTarget();

            // Pickups
            PickupOrchestrator.update(dt, { x: PlayerOrchestrator.position.x, y: 0, z: PlayerOrchestrator.position.z }, Date.now()).forEach(p => {
                const prevWeapon = WeaponOrchestrator.getCurrentId();
                const r = PickupOrchestrator.collect(p, WeaponOrchestrator, THREE, MaterialsTheme, camera);
                if (r?.switched) {
                    UIOrchestrator.showPickupNotification?.(p.config.name);
                    AnalyticsOrchestrator.weaponSwitch(r.weaponId, prevWeapon);
                    AnalyticsOrchestrator.pickupCollected('weapon', r.weaponId);
                } else if (r?.ammoAdded > 0) {
                    UIOrchestrator.showPickupNotification?.(`+${r.ammoAdded} Ammo`);
                    AnalyticsOrchestrator.pickupCollected(p.config.isAmmo ? 'ammo' : 'weapon_ammo', p.config.id);
                }
            });
            PickupOrchestrator.cleanupBehind(PlayerOrchestrator.position.z);

            // UI updates
            UIOrchestrator.updateCrosshairUI(crosshairX, crosshairY, aim.hasTarget);
            UIOrchestrator.updateTensionUI(crosshairX, crosshairY, WeaponOrchestrator.isCharging(), WeaponOrchestrator.getTension(), WeaponOrchestrator.getMaxTension());
            // Count enemies by type
            const activeEnemies = enemies.filter(e => e.userData.active);
            const enemyCounts = {
                skeleton: activeEnemies.filter(e => e.userData.type === 'SKELETON').length,
                dinosaur: activeEnemies.filter(e => e.userData.type === 'DINOSAUR').length
            };
            UIOrchestrator.updateEnemyCount(enemyCounts);
            // Update minimap with LIVE enemy positions
            UIOrchestrator.updateMinimap({
                currentRoom,
                enemies: activeEnemies,
                gridOrchestrator: mallGrid,
                roomConfig: Room.structure
            });

            // Entity updates
            ProjectileOrchestrator.updateMeshArray(projectiles, { dt, cameraPosition: camera.position });

            EnemyOrchestrator.updateAll(enemies, {
                playerPosition: PlayerOrchestrator.position,
                playerCart,
                dt,
                baseSpeed: CART_SPEED,
                isInvulnerable: PlayerOrchestrator.getIsInvulnerable(),
                onPlayerCollision: () => damagePlayer(Player.health.ENEMY_DAMAGE, 'enemy'),
                collisionCheck: (nX, nZ, oX, oZ) => CollisionOrchestrator.checkAllCollisions(nX, nZ, oX, oZ, { gridOrchestrator: mallGrid, roomConfig: Room.structure, obstacles, shelves, playerRadius: 1.5 }),
                hasLineOfSight: (fX, fZ, tX, tZ) => CollisionOrchestrator.hasLineOfSight(fX, fZ, tX, tZ, mallGrid, Room.structure),
                clampToRoomBounds: (pos) => CollisionOrchestrator.clampToRoomBounds(pos, mallGrid, Room.structure, 1.5),
                obstacles,
                shelves
            });
            // Update obstacles (no damage - player collides via movement check above)
            EnvironmentOrchestrator.updateObstaclesArray(obstacles, { playerCart, dt });
            ParticleOrchestrator.updateAll(particles, dt, { gravity: 15, fadeRate: 2 });

            // Dinosaur spawn - escalation mechanic (every 1000 points)
            // No skeleton respawning - "Clear the Mall" design
            if (EnemyOrchestrator.checkDinoSpawn(GameSession.getScore())) {
                // Spawn dino in player's current room or nearby
                const spawnRoom = currentRoom || mallGrid.getRoomAtWorld(PlayerOrchestrator.position.x, PlayerOrchestrator.position.z);
                if (spawnRoom && spawnRoom.theme !== 'ENTRANCE') {
                    const pos = SpawnOrchestrator.findValidPosition(spawnRoom, Room.structure, [], 5);
                    if (pos) {
                        const dino = createEnemy(pos.x, pos.z, 'DINOSAUR');
                        if (dino) UIOrchestrator.showBossWarning('DINO BOSS!');
                    }
                }
            }

            // Runtime pickup spawning - maintains pickup availability
            SpawnOrchestrator.tryRuntimePickupSpawn({
                currentRoom,
                playerPosition: PlayerOrchestrator.position,
                visitedRooms,
                gridOrchestrator: mallGrid,
                roomConfig: Room.structure,
                currentPickupCount: PickupOrchestrator.getCount(),
                dt,
                pickupOrchestrator: PickupOrchestrator,
                obstacles,
                shelves
            });

            // Collision detection
            CollisionOrchestrator.processProjectileHits(projectiles, enemies, obstacles, {
                THREE,
                gridOrchestrator: mallGrid,
                roomConfig: Room.structure,
                shelves,
                onEnemyHit: (enemy, damage, closestPoint, result) => {
                    UIOrchestrator.showHitMarker();
                    const enemyType = enemy.userData.config?.id || 'cart';
                    const hb = enemy.userData.healthBar;
                    if (hb) {
                        const healthPercent = EnemyOrchestrator.getHealthPercent(enemy);
                        if (enemyType === 'dinosaur' && typeof DinosaurMesh !== 'undefined') {
                            DinosaurMesh.updateHealthBar(hb, healthPercent);
                        } else if (typeof SkeletonMesh !== 'undefined') {
                            SkeletonMesh.updateHealthBar(hb, healthPercent);
                        }
                    }
                    const color = (enemy.userData.config || ENEMY_TYPES.CART).visual?.bodyColor || 0xe94560;
                    if (result.destroyed) {
                        addScore(result.scoreDestroy, enemy.position); spawnParticles(enemy.position, color, 15);
                        UIOrchestrator.addKilledEnemy(); // Track progress
                        AnalyticsOrchestrator.enemyKill(enemyType, result.scoreDestroy);
                    } else {
                        addScore(result.scoreHit, enemy.position); spawnParticles(closestPoint, 0xf39c12, 3);
                    }
                },
                onObstacleHit: (obs) => {
                    UIOrchestrator.showHitMarker(); addScore(150, obs.position); spawnParticles(obs.position, 0xf1c40f, 10);
                    AnalyticsOrchestrator.obstacleHit(obs.userData?.type || 'unknown', 150);
                },
                onWallHit: (pos) => { spawnParticles(pos, 0x888888, 5); }
            });

            // Cleanup inactive objects
            const c = EntityOrchestrator.cleanupAllInactive({ projectiles, enemies, obstacles, particles }, scene);
            projectiles = c.projectiles; enemies = c.enemies; obstacles = c.obstacles; particles = c.particles;
        }

        // Event Listeners
        document.getElementById('start-btn').addEventListener('click', startGame);
        document.getElementById('restart-btn').addEventListener('click', startGame);
        document.getElementById('resume-btn').addEventListener('click', resumeGame);
        document.getElementById('quit-btn').addEventListener('click', quitToMenu);

        // How to Play modal
        const howToPlayModal = document.getElementById('how-to-play-modal');
        const modalCloseBtn = document.getElementById('modal-close');
        const closeModal = (e) => { e.preventDefault(); howToPlayModal.classList.remove('visible'); };
        document.getElementById('how-to-play-btn').addEventListener('click', (e) => { e.preventDefault(); howToPlayModal.classList.add('visible'); });
        modalCloseBtn.addEventListener('click', closeModal);
        modalCloseBtn.addEventListener('touchend', closeModal);
        howToPlayModal.addEventListener('click', (e) => e.target === howToPlayModal && closeModal(e));
        document.addEventListener('keydown', (e) => e.key === 'Escape' && howToPlayModal.classList.contains('visible') && (closeModal(e), e.stopPropagation()), true);

        // Legacy aliases
        const WEAPON_TYPES = Weapon.types, PROJECTILE_TYPES = Projectile.types, ENEMY_TYPES = Enemy.types, AIM_PROFILES = Weapon.aimProfiles;

        // Initialize systems
        initThree();
        StateOrchestrator.init('MENU');
        LoopOrchestrator.init(THREE);
        LoopOrchestrator.setUpdateCallback(update);
        LoopOrchestrator.setRenderCallback((dt) => {
            damageVignetteStrength *= 0.95;
            PostProcessOrchestrator.setDamageIntensity(damageVignetteStrength);
            composer ? composer.render(dt) : renderer.render(scene, camera);
        });
        InputOrchestrator.init();
        EntityOrchestrator.init(scene);
        InputOrchestrator.onActionStart('fire', () => StateOrchestrator.is('PLAYING') && startCharging());
        InputOrchestrator.onActionRelease('fire', () => StateOrchestrator.is('PLAYING') && releaseAndFire());
        InputOrchestrator.onActionStart('pause', togglePause);
        InputOrchestrator.onActionStart('freeze', toggleFreeze);
        EntityOrchestrator.registerType('enemy', { maxCount: 10, despawnDistance: 20 });
        EntityOrchestrator.registerType('obstacle', { maxCount: 15, despawnDistance: 30 });
        EntityOrchestrator.registerType('projectile', { maxCount: 50, despawnDistance: 20 });
        EntityOrchestrator.registerType('particle', { maxCount: 100, despawnDistance: 50 });
        EnemyOrchestrator.init(Enemy, scene);
        GameSession.init({ camera });

        // Expose internals for test framework (TestBridge injected only during tests)
        window.__gameInternals = {
            // Game state - delegate to GameSession
            getScore: () => GameSession.getScore(),
            setScore: (v) => GameSession.setScore(v),
            getGameTimer: () => GameSession.getTimer(),
            setGameTimer: (v) => GameSession.setTimer(v),
            // Player state - delegate to PlayerOrchestrator
            getPlayerPosition: () => PlayerOrchestrator.position,
            setPlayerPosition: (v) => { PlayerOrchestrator.position = v; },
            getPlayerRotation: () => PlayerOrchestrator.rotation,
            setPlayerRotation: (v) => { PlayerOrchestrator.rotation = v; },
            getPlayerHealth: () => PlayerOrchestrator.health,
            setPlayerHealth: (v) => { PlayerOrchestrator.health = v; },
            getWallBumpIntensity: () => PlayerOrchestrator.wallBumpIntensity,
            setWallBumpIntensity: (v) => { PlayerOrchestrator.wallBumpIntensity = v; },
            // Weapon state - delegate to WeaponOrchestrator
            getSlingshotTension: () => WeaponOrchestrator.getTension(),
            setSlingshotTension: (v) => WeaponOrchestrator.setTension?.(v),
            getIsChargingSlingshot: () => WeaponOrchestrator.isCharging(),
            setIsChargingSlingshot: (v) => v ? WeaponOrchestrator.onFireStart(Date.now()) : WeaponOrchestrator.cancelAction(),
            getLastShootTime: () => lastShootTime,
            setLastShootTime: (v) => { lastShootTime = v; },
            getCameraMode: () => cameraMode,
            setCameraMode: () => {},  // Read-only in v3
            getFpsWeapon: () => WeaponOrchestrator.fpsMesh,
            getProjectiles: () => projectiles,
            getEnemies: () => enemies,
            getObstacles: () => obstacles,
            getShelves: () => shelves,
            // Functions
            startGame, pauseGame, resumeGame, endGame, resetGame, damagePlayer,
            startCharging, releaseAndFire, cancelCharging, updateAmmoDisplay,
            manualUpdate: (dt = 0.016) => update(dt),
            triggerWallBump: (intensity, dirX, dirZ) => {
                PlayerOrchestrator.wallBumpIntensity = intensity;
                PlayerOrchestrator.wallBumpDirection = { x: dirX, z: dirZ };
            },
            // Object references
            scene, camera, renderer, playerCart, playerChild
        };

        updateCursor();

        // Set initial UI state (MENU)
        healthContainer.style.display = 'none';
        hud.style.display = 'none';

        // Start the game loop
        LoopOrchestrator.start();
    </script>
</body>
</html>
