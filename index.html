<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mall Hell v3.0</title>
    <link rel="stylesheet" href="./src/styles/main.css">
</head>
<body>
    <div id="game-container">
        <div id="ui-layer">
            <div id="crosshair"><div id="crosshair-dot"></div></div>

            <!-- Tension Indicator (ring around crosshair) -->
            <div id="tension-indicator">
                <svg viewBox="0 0 100 100">
                    <circle class="tension-bg" cx="50" cy="50" r="45"/>
                    <circle class="tension-fill" cx="50" cy="50" r="45"/>
                </svg>
                <div id="tension-text"></div>
            </div>

            <div id="hud">
                <div id="score-container">
                    <div id="score-label">CHAOS SCORE</div>
                    <div id="score">0</div>
                </div>

                <div id="timer-container">
                    <div id="timer-label">TIME REMAINING</div>
                    <div id="timer-display">3:00</div>
                    <div id="timer-bar">
                        <div id="timer-fill"></div>
                    </div>
                </div>

                <div id="ammo-display">SLINGSHOT READY</div>

                <div id="pause-indicator">ESC to Pause</div>

                <div id="controls-hint">WASD Drive | SPACE Fire | Auto-Aim</div>
            </div>

            <div id="health-container">
                <div id="health-label">HEALTH</div>
                <div id="health-bar">
                    <div id="health-fill"></div>
                </div>
                <div id="health-value">100</div>
            </div>

            <div id="cooldown-indicator">
                <div id="cooldown-ring">
                    <div id="cooldown-fill"></div>
                </div>
            </div>

            <div id="hit-marker"></div>
            <div id="damage-overlay"></div>

            <div id="menu-screen">
                <div class="menu-container">
                    <div class="title-wrapper">
                        <div class="title">MALL HELL</div>
                    </div>
                    <div class="version">VERSION 3.3</div>
                    <div class="subtitle">SUPERMARKET MAYHEM</div>
                    <div class="instructions" id="instructions">
                        <div class="control-item">
                            <span class="control-key">W</span>
                            <span class="control-action">Drive</span>
                        </div>
                        <div class="control-item">
                            <span class="control-key">S</span>
                            <span class="control-action">Reverse</span>
                        </div>
                        <div class="control-item">
                            <span class="control-key">A</span>
                            <span class="control-action">Turn Left</span>
                        </div>
                        <div class="control-item">
                            <span class="control-key">D</span>
                            <span class="control-action">Turn Right</span>
                        </div>
                        <div class="control-item">
                            <span class="control-key">SPACE</span>
                            <span class="control-action">Charge & Fire</span>
                        </div>
                    </div>
                    <div class="how-to-play-btn" id="how-to-play-btn">[ HOW TO PLAY ]</div>
                    <button class="btn" id="start-btn">START CHAOS</button>
                </div>
            </div>

            <div id="how-to-play-modal">
                <div class="modal-content">
                    <h2>HOW TO PLAY</h2>
                    <h3>YOU ARE A KID IN A SHOPPING CART</h3>
                    <p>Explore the mall and cause as much chaos as possible before time runs out!</p>
                    <h3>CONTROLS</h3>
                    <p><span class="key">W/S</span> Drive forward and reverse</p>
                    <p><span class="key">A/D</span> Turn left and right</p>
                    <p><span class="key">SPACE</span> Hold to charge your slingshot, release to fire</p>
                    <h3>SMART AIMING</h3>
                    <p>Your crosshair automatically tracks the most dangerous target. Focus on timing your shots!</p>
                    <h3>SCORING</h3>
                    <p>Hit enemies: +100 points<br>Destroy enemies: +300 points<br>Hit obstacles: +150 points</p>
                    <h3>TIP</h3>
                    <p>Explore all 16 mall sections to maximize your chaos score!</p>
                    <button class="modal-close" id="modal-close">GOT IT!</button>
                </div>
            </div>

            <div id="gameover-screen">
                <div class="menu-container">
                    <div class="title" id="gameover-title">CHECKOUT!</div>
                    <div id="final-score-container">
                        <div id="final-score-label">TOTAL CHAOS</div>
                        <div id="final-score">0</div>
                        <div id="rating">Mild Mischief</div>
                    </div>
                    <button class="btn" id="restart-btn">PLAY AGAIN</button>
                </div>
            </div>

            <div id="pause-screen">
                <div class="menu-container">
                    <div class="title">PAUSED</div>
                    <div class="pause-score">Current Chaos: <span id="pause-score-value">0</span></div>
                    <div class="pause-buttons">
                        <button class="pause-btn primary" id="resume-btn">RESUME</button>
                        <button class="pause-btn" id="quit-btn">QUIT TO MENU</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <!-- Shared Libraries -->
    <script src="./src/shared/materials-theme.js"></script>

    <!-- UI Domain -->
    <script src="./src/ui/ui.js"></script>
    <script src="./src/ui/ui-system.js"></script>

    <!-- Engine Domain (core systems - load first) -->
    <script src="./src/engine/engine.js"></script>
    <script src="./src/engine/collision-system.js"></script>
    <script src="./src/engine/input-system.js"></script>
    <script src="./src/engine/state-system.js"></script>
    <script src="./src/engine/loop-system.js"></script>
    <script src="./src/engine/scene-system.js"></script>
    <script src="./src/engine/entity-system.js"></script>

    <!-- Room Domain -->
    <script src="./src/room/room.js"></script>
    <script src="./src/room/room-theme.js"></script>
    <script src="./src/room/room-mesh.js"></script>
    <script src="./src/room/room-system.js"></script>

    <!-- Player Domain -->
    <script src="./src/player/player.js"></script>
    <script src="./src/player/player-theme.js"></script>
    <script src="./src/player/player-mesh.js"></script>
    <script src="./src/player/player-system.js"></script>

    <!-- Weapon Domain -->
    <script src="./src/weapon/weapon.js"></script>
    <script src="./src/weapon/weapon-theme.js"></script>
    <script src="./src/weapon/weapon-mesh.js"></script>
    <script src="./src/weapon/weapon-system.js"></script>

    <!-- Projectile Domain -->
    <script src="./src/projectile/projectile.js"></script>
    <script src="./src/projectile/projectile-theme.js"></script>
    <script src="./src/projectile/projectile-mesh.js"></script>
    <script src="./src/projectile/projectile-system.js"></script>

    <!-- Enemy Domain -->
    <script src="./src/enemy/enemy.js"></script>
    <script src="./src/enemy/enemy-theme.js"></script>
    <script src="./src/enemy/enemy-mesh.js"></script>
    <script src="./src/enemy/enemy-system.js"></script>

    <!-- Environment Domain (Obstacles + Shelves) -->
    <script src="./src/environment/obstacle.js"></script>
    <script src="./src/environment/obstacle-theme.js"></script>
    <script src="./src/environment/obstacle-mesh.js"></script>
    <script src="./src/environment/shelf.js"></script>
    <script src="./src/environment/shelf-theme.js"></script>
    <script src="./src/environment/shelf-mesh.js"></script>
    <script src="./src/environment/environment-system.js"></script>
    <script src="./src/environment/spawn-system.js"></script>

    <script>
        // Domain modules loaded:
        // - Room: Room, RoomTheme, RoomMesh, RoomSystem
        // - Player: Player, PlayerTheme, PlayerMesh, PlayerSystem
        // - Weapon: Weapon, WeaponTheme, WeaponMesh, WeaponSystem
        // - Projectile: Projectile, ProjectileTheme, ProjectileMesh (as ProjectileVisual), ProjectileSystem
        // - Enemy: Enemy, EnemyTheme, EnemyMesh (as EnemyVisual), EnemySystem
        // - Environment: Obstacle, ObstacleTheme, ObstacleMesh (as ObstacleVisual), Shelf, ShelfTheme, ShelfMesh, EnvironmentSystem

        // ============================================
        // GAME CONSTANTS - Aliases to Domain Values
        // ============================================
        // Most constants now live in domain files. These are aliases for backward compatibility.

        // Room Constants (from Room domain)
        const ROOM_UNIT = Room.structure.UNIT;
        const DOOR_WIDTH = Room.structure.DOOR_WIDTH;

        // Game Duration (game-specific, not in domains yet)
        const GAME_DURATION = 180;         // 3 minutes

        // Weapon Constants (from Weapon domain)
        const SLINGSHOT = Weapon.types.SLINGSHOT;
        const SHOOT_COOLDOWN = SLINGSHOT.cooldown;
        const TENSION_MIN = SLINGSHOT.minTension;
        const TENSION_MAX = SLINGSHOT.maxTension;
        const TENSION_CHARGE_RATE = SLINGSHOT.chargeRate;
        const PROJECTILE_SPEED_MIN = SLINGSHOT.projectileSpeed.min;
        const PROJECTILE_SPEED_MAX = SLINGSHOT.projectileSpeed.max;

        // Enemy Constants (from Enemy domain)
        const ENEMY_HEALTH = Enemy.types.SKELETON.health;

        // Player Movement Constants (from Player domain)
        const CART_SPEED = Player.movement.SPEED;
        const CART_TURN_SPEED = Player.movement.TURN_SPEED;
        const CART_REVERSE_SPEED = Player.movement.REVERSE_SPEED;
        const CART_ACCELERATION = Player.movement.ACCELERATION;
        const CART_DECELERATION = Player.movement.DECELERATION;
        const CART_MAX_SPEED = Player.movement.MAX_SPEED;
        const CART_FRICTION = Player.movement.FRICTION;
        const CART_IDLE_DRIFT = Player.movement.IDLE_DRIFT;

        // Cart Visual Constants (from Player domain)
        const CART_LEAN_ANGLE = Player.visual.LEAN_ANGLE;
        const CAMERA_ROLL_FACTOR = Player.visual.CAMERA_ROLL_FACTOR;

        // Crosshair Constants (UI-specific, not in domains yet)
        const CROSSHAIR_BOUNDS_MARGIN = 50;

        // Player Health Constants (from Player domain)
        const PLAYER_MAX_HEALTH = Player.health.MAX;
        const ENEMY_COLLISION_DAMAGE = Player.health.ENEMY_DAMAGE;
        const OBSTACLE_COLLISION_DAMAGE = Player.health.OBSTACLE_DAMAGE;
        const INVULNERABILITY_DURATION = Player.health.INVULNERABILITY_DURATION;

        // Mall themes - alias to RoomTheme for backward compatibility
        const MALL_THEMES = RoomTheme.themes;

        // AimingSystem shim - delegates to WeaponSystem for backward compatibility
        const AimingSystem = {
            reset: () => WeaponSystem.reset(),
            getProfileConfig: () => WeaponSystem.getAimProfileConfig(),
            isEnabled: () => WeaponSystem.isAimingEnabled(),
            setLock: (target) => WeaponSystem.setLock(target),
            clearLock: () => WeaponSystem.clearLock(),
            scoreEnemy: (enemy, cameraPos, playerPos, config) => WeaponSystem.scoreEnemy(enemy, cameraPos, playerPos),
            scoreObstacle: (obs, cameraPos, playerPos, config) => WeaponSystem.scoreObstacle(obs, cameraPos, playerPos),
            updateCrosshair: (x, y) => WeaponSystem.updateCrosshair(x, y),
            getCrosshairPosition: () => WeaponSystem.getCrosshairPosition(),
            isAimAssistActive: () => WeaponSystem.isAimAssistActive()
        };

        // ShelfSystem shim - delegates to Shelf for backward compatibility
        const ShelfSystem = {
            getShelfTemplate: (id) => Shelf.getTemplate(id),
            getProductGeometry: (id) => Shelf.getProductType(id),
            pickProductColor: (theme) => Shelf.pickColor(theme.productColors || theme)
        };

        // Mall Grid Layout (16 rooms)
        // Grid coordinates: x = column (0-4), z = row (0-4)
        // Each room is ROOM_UNIT x ROOM_UNIT (30x30)
        // World position: worldX = gridX * ROOM_UNIT, worldZ = gridZ * ROOM_UNIT
        const MALL_GRID = {
            // Row 0 (z=0)
            '0_0': { theme: 'ELECTRONICS', doors: ['south'] },
            '1_0': { theme: 'GAMING', doors: ['south', 'east'] },
            '2_0': { theme: 'TOYS', doors: ['south'] },
            // Row 1 (z=1)
            '0_1': { theme: 'APPLIANCES', doors: ['north', 'south', 'east'] },
            '1_1': { theme: 'JUNCTION', doors: ['north', 'south', 'east', 'west'] },
            '2_1': { theme: 'SPORTS', doors: ['north', 'south', 'west'] },
            // Row 2 (z=2) - Main corridor with ENTRANCE
            '-1_2': { theme: 'BAKERY', doors: ['east'] },
            '0_2': { theme: 'PRODUCE', doors: ['north', 'south', 'east', 'west'] },
            '1_2': { theme: 'ENTRANCE', doors: ['north', 'south', 'east', 'west'] },
            '2_2': { theme: 'DAIRY', doors: ['north', 'south', 'east', 'west'] },
            '3_2': { theme: 'FROZEN', doors: ['west'] },
            // Row 3 (z=3)
            '0_3': { theme: 'SNACKS', doors: ['north', 'south', 'east'] },
            '1_3': { theme: 'JUNCTION', doors: ['north', 'south', 'east', 'west'] },
            '2_3': { theme: 'BEVERAGES', doors: ['north', 'south', 'west'] },
            // Row 4 (z=4)
            '0_4': { theme: 'CLOTHING', doors: ['north', 'east'] },
            '1_4': { theme: 'PHARMACY', doors: ['north', 'west'] },
        };

        // Mall Grid Helper Functions
        const mallGrid = {
            getRoom(gridX, gridZ) {
                const key = `${gridX}_${gridZ}`;
                const roomDef = MALL_GRID[key];
                if (!roomDef) return null;
                return {
                    ...roomDef,
                    gridX,
                    gridZ,
                    worldX: gridX * ROOM_UNIT + ROOM_UNIT / 2,
                    worldZ: gridZ * ROOM_UNIT + ROOM_UNIT / 2,
                    themeData: MALL_THEMES[roomDef.theme]
                };
            },
            getRoomAtWorld(worldX, worldZ) {
                const gridX = Math.floor(worldX / ROOM_UNIT);
                const gridZ = Math.floor(worldZ / ROOM_UNIT);
                return this.getRoom(gridX, gridZ);
            },
            getGridFromWorld(worldX, worldZ) {
                return {
                    x: Math.floor(worldX / ROOM_UNIT),
                    z: Math.floor(worldZ / ROOM_UNIT)
                };
            }
        };

        // Legacy compatibility - get theme at world position
        function getSectionAtZ(z) {
            const room = mallGrid.getRoomAtWorld(playerPosition.x, z);
            return room ? room.themeData : MALL_THEMES.ENTRANCE;
        }

        // Game State (managed by GameState module)
        let score = 0;
        let gameTimer = GAME_DURATION;    // Countdown timer (replaces distance)
        let lastShootTime = 0;
        let cameraMode = 'hybrid-fps';    // v3.0 is FPS only

        // Three.js Setup
        let scene, camera, renderer;
        let projectiles = [];
        let enemies = [];
        let obstacles = [];
        let particles = [];
        let shelves = [];
        let floorTiles = [];
        let lights = [];
        let ambientLight; // Global reference for section-based color changes
        let currentSection = null; // Track current section for ambient transitions

        // Helper to get theme at a given position (for compatibility)

        // Player
        let playerCart;
        let playerChild; // Child model reference (to hide in FPS)
        let slingshotArm;
        let fpsWeapon; // Slingshot with hands visible in FPS mode
        let fpsHands;  // Hands group for animation
        let fpsBandL, fpsBandR, fpsPouch, fpsStone; // For pull animation
        let fpsFireAnim = 0; // Firing animation progress (0 = ready, >0 = animating)

        // Slingshot Tension State
        let slingshotTension = 0;        // Current tension (0 to TENSION_MAX)
        let isChargingSlingshot = false; // Is player holding to charge

        // Player Position & Movement (grid-based maze)
        // Start at center of ENTRANCE room (grid 1,2): world center = (1*30+15, 2*30+15) = (45, 75)
        let playerPosition = { x: 45, z: 75 };
        let playerRotation = 0;                  // Facing direction (radians, 0 = -Z)
        let playerSpeed = 0;                     // Current forward speed
        let currentTurnRate = 0;                 // Smooth turning
        let playerHealth = PLAYER_MAX_HEALTH;
        let lastDamageTime = 0;
        let isInvulnerable = false;

        // Cart visual state
        let currentLeanAngle = 0;

        // Wall bump effect
        let wallBumpIntensity = 0;       // Current bump animation intensity (0-1)
        let wallBumpDirection = { x: 0, z: 0 }; // Direction of bump pushback

        // Room tracking
        let currentRoom = null;
        let visitedRooms = new Set();

        // Crosshair state
        let crosshairX = window.innerWidth / 2;
        let crosshairY = window.innerHeight / 2;

        // Locked target for sticky aim (don't switch until target gone)
        let lockedTarget = null;

        // Keyboard input handled by Input module (initialized later)

        // Clock handled by GameLoop module
        // Materials library loaded from src/shared/materials-theme.js

        // === SCENE HIERARCHY GROUPS ===
        const sceneGroups = {
            environment: null,  // floor, ceiling, walls, shelves
            gameplay: null,     // player, enemies, obstacles
            effects: null,      // particles, projectiles
            lighting: null      // all lights
        };

        function initSceneGroups() {
            sceneGroups.environment = new THREE.Group();
            sceneGroups.environment.name = 'environment';
            sceneGroups.gameplay = new THREE.Group();
            sceneGroups.gameplay.name = 'gameplay';
            sceneGroups.effects = new THREE.Group();
            sceneGroups.effects.name = 'effects';
            sceneGroups.lighting = new THREE.Group();
            sceneGroups.lighting.name = 'lighting';

            scene.add(sceneGroups.environment);
            scene.add(sceneGroups.gameplay);
            scene.add(sceneGroups.effects);
            scene.add(sceneGroups.lighting);
        }

        // === POST-PROCESSING (disabled - using direct rendering) ===
        let composer = null;
        let damageVignetteStrength = 0;

        // DOM Elements
        const container = document.getElementById('game-container');
        const scoreElement = document.getElementById('score');
        const timerDisplay = document.getElementById('timer-display');
        const timerFill = document.getElementById('timer-fill');
        const hud = document.getElementById('hud');
        const menuScreen = document.getElementById('menu-screen');
        const gameoverScreen = document.getElementById('gameover-screen');
        const finalScoreElement = document.getElementById('final-score');
        const ratingElement = document.getElementById('rating');
        const hitMarker = document.getElementById('hit-marker');
        const cooldownFill = document.getElementById('cooldown-fill');
        const ammoDisplay = document.getElementById('ammo-display');
        const pauseScreen = document.getElementById('pause-screen');
        const pauseScoreValue = document.getElementById('pause-score-value');
        const healthFill = document.getElementById('health-fill');
        const healthValue = document.getElementById('health-value');
        const healthContainer = document.getElementById('health-container');
        const damageOverlay = document.getElementById('damage-overlay');
        const gameoverTitle = document.getElementById('gameover-title');

        // Initialize Three.js
        function initThree() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);
            scene.fog = new THREE.Fog(0x1a1a2e, 50, 200);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 3, 0);
            camera.rotation.order = 'YXZ';
            scene.add(camera); // Required for camera children (FPS weapon) to render

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.insertBefore(renderer.domElement, container.firstChild);

            // Initialize shared material library
            MaterialsTheme.init(THREE);

            // Initialize UI system
            UISystem.init();

            // Initialize scene hierarchy groups
            initSceneGroups();

            // Lighting - stronger ambient to compensate for removed point lights
            ambientLight = new THREE.AmbientLight(0xfff8f0, 0.6);
            scene.add(ambientLight);

            // Main directional light
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(10, 20, 10);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            dirLight.shadow.camera.near = 0.5;
            dirLight.shadow.camera.far = 100;
            dirLight.shadow.camera.left = -30;
            dirLight.shadow.camera.right = 30;
            dirLight.shadow.camera.top = 30;
            dirLight.shadow.camera.bottom = -30;
            scene.add(dirLight);

            // Post-processing disabled (direct rendering used instead)

            // Create supermarket environment
            createEnvironment();

            // Create player cart using domain mesh
            const playerCartResult = PlayerMesh.createPlayerCart(THREE);
            playerCart = playerCartResult.cart;
            playerChild = playerCartResult.child;
            slingshotArm = playerCartResult.slingshot;
            playerCart.position.set(0, 0, -5);
            scene.add(playerCart);

            // Create FPS weapon using domain mesh
            const fpsWeaponResult = WeaponMesh.createFPSWeapon(THREE, MaterialsTheme);
            fpsWeapon = fpsWeaponResult.weapon;
            fpsHands = fpsWeaponResult.hands;
            fpsBandL = fpsWeaponResult.bandL;
            fpsBandR = fpsWeaponResult.bandR;
            fpsPouch = fpsWeaponResult.pouch;
            fpsStone = fpsWeaponResult.stone;
            camera.add(fpsWeapon);
            fpsWeapon.visible = false;

            window.addEventListener('resize', onWindowResize);

            // Expose for testing
            window.scene = scene;
            window.camera = camera;
            window.renderer = renderer;
        }

        // === POST-PROCESSING SETUP ===
        function initPostProcessing() {
            // EffectComposer - inline implementation for r128 compatibility
            // Based on Three.js examples/jsm/postprocessing

            // RenderPass - renders scene to texture
            class RenderPass {
                constructor(scene, camera) {
                    this.scene = scene;
                    this.camera = camera;
                    this.clear = true;
                    this.clearDepth = false;
                    this.needsSwap = false;
                    this.enabled = true;
                }
                render(renderer, writeBuffer, readBuffer) {
                    renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);
                    if (this.clear) renderer.clear();
                    renderer.render(this.scene, this.camera);
                }
            }

            // ShaderPass - applies a shader to the scene
            class ShaderPass {
                constructor(shader) {
                    this.uniforms = THREE.UniformsUtils.clone(shader.uniforms);
                    this.material = new THREE.ShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: shader.vertexShader,
                        fragmentShader: shader.fragmentShader
                    });
                    this.fsQuad = new FullScreenQuad(this.material);
                    this.enabled = true;
                    this.needsSwap = true;
                    this.clear = false;
                    this.renderToScreen = false;
                }
                render(renderer, writeBuffer, readBuffer) {
                    this.uniforms.tDiffuse.value = readBuffer.texture;
                    renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);
                    if (this.clear) renderer.clear();
                    this.fsQuad.render(renderer);
                }
            }

            // FullScreenQuad helper
            class FullScreenQuad {
                constructor(material) {
                    const geo = new THREE.PlaneGeometry(2, 2);
                    this.mesh = new THREE.Mesh(geo, material);
                    this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
                    this.scene = new THREE.Scene();
                    this.scene.add(this.mesh);
                }
                render(renderer) {
                    renderer.render(this.scene, this.camera);
                }
                get material() { return this.mesh.material; }
                set material(v) { this.mesh.material = v; }
            }

            // EffectComposer
            class EffectComposer {
                constructor(renderer, renderTarget) {
                    this.renderer = renderer;
                    const size = renderer.getSize(new THREE.Vector2());
                    this.renderTarget1 = renderTarget || new THREE.WebGLRenderTarget(size.x, size.y, {
                        minFilter: THREE.LinearFilter,
                        magFilter: THREE.LinearFilter,
                        format: THREE.RGBAFormat
                    });
                    this.renderTarget2 = this.renderTarget1.clone();
                    this.writeBuffer = this.renderTarget1;
                    this.readBuffer = this.renderTarget2;
                    this.passes = [];
                }
                addPass(pass) {
                    this.passes.push(pass);
                    const size = this.renderer.getSize(new THREE.Vector2());
                    pass.setSize && pass.setSize(size.x, size.y);
                }
                render(deltaTime) {
                    let maskActive = false;
                    for (let i = 0; i < this.passes.length; i++) {
                        const pass = this.passes[i];
                        if (!pass.enabled) continue;
                        pass.renderToScreen = (i === this.passes.length - 1);
                        pass.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime, maskActive);
                        if (pass.needsSwap) {
                            const tmp = this.readBuffer;
                            this.readBuffer = this.writeBuffer;
                            this.writeBuffer = tmp;
                        }
                    }
                }
                setSize(width, height) {
                    this.renderTarget1.setSize(width, height);
                    this.renderTarget2.setSize(width, height);
                    this.passes.forEach(pass => pass.setSize && pass.setSize(width, height));
                }
            }

            // Bloom shader (simplified UnrealBloom)
            const BloomShader = {
                uniforms: {
                    tDiffuse: { value: null },
                    bloomStrength: { value: 0.5 },
                    bloomThreshold: { value: 0.85 }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform sampler2D tDiffuse;
                    uniform float bloomStrength;
                    uniform float bloomThreshold;
                    varying vec2 vUv;

                    void main() {
                        vec4 texel = texture2D(tDiffuse, vUv);
                        float brightness = dot(texel.rgb, vec3(0.2126, 0.7152, 0.0722));
                        vec3 bloom = vec3(0.0);
                        if (brightness > bloomThreshold) {
                            bloom = (texel.rgb - bloomThreshold) * bloomStrength;
                        }
                        // Simple box blur for bloom spread
                        vec2 texelSize = vec2(1.0 / 1920.0, 1.0 / 1080.0);
                        for (int x = -2; x <= 2; x++) {
                            for (int y = -2; y <= 2; y++) {
                                vec4 neighbor = texture2D(tDiffuse, vUv + vec2(float(x), float(y)) * texelSize * 2.0);
                                float nb = dot(neighbor.rgb, vec3(0.2126, 0.7152, 0.0722));
                                if (nb > bloomThreshold) {
                                    bloom += (neighbor.rgb - bloomThreshold) * bloomStrength * 0.04;
                                }
                            }
                        }
                        gl_FragColor = vec4(texel.rgb + bloom, texel.a);
                    }
                `
            };

            // Vignette + Color Grading shader
            const VignetteShader = {
                uniforms: {
                    tDiffuse: { value: null },
                    damageIntensity: { value: 0.0 },
                    saturation: { value: 1.1 },
                    contrast: { value: 1.05 }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform sampler2D tDiffuse;
                    uniform float damageIntensity;
                    uniform float saturation;
                    uniform float contrast;
                    varying vec2 vUv;

                    void main() {
                        vec4 texel = texture2D(tDiffuse, vUv);

                        // Subtle always-on vignette for atmosphere
                        float baseVignette = 1.0 - smoothstep(0.4, 1.0, length(vUv - 0.5) * 1.2);

                        // Damage vignette (red edges)
                        float damageVignette = smoothstep(0.3, 0.9, length(vUv - 0.5) * 1.5);
                        vec3 damageColor = vec3(0.9, 0.1, 0.05);

                        // Apply color grading
                        vec3 color = texel.rgb;

                        // Saturation
                        float gray = dot(color, vec3(0.2126, 0.7152, 0.0722));
                        color = mix(vec3(gray), color, saturation);

                        // Contrast
                        color = (color - 0.5) * contrast + 0.5;

                        // Apply vignettes
                        color *= baseVignette * 0.15 + 0.85;
                        color = mix(color, damageColor, damageVignette * damageIntensity);

                        gl_FragColor = vec4(color, texel.a);
                    }
                `
            };

            // Create composer
            composer = new EffectComposer(renderer);

            // Render pass
            const renderPass = new RenderPass(scene, camera);
            composer.addPass(renderPass);

            // Bloom pass
            bloomPass = new ShaderPass(BloomShader);
            bloomPass.uniforms.bloomStrength.value = 0.4;
            bloomPass.uniforms.bloomThreshold.value = 0.8;
            composer.addPass(bloomPass);

            // Vignette + color grading pass
            vignettePass = new ShaderPass(VignetteShader);
            vignettePass.uniforms.damageIntensity.value = 0.0;
            composer.addPass(vignettePass);

            // Store for resize
            window.composer = composer;
        }

        function createEnvironment() {
            // Create all rooms in the grid using RoomSystem
            Object.keys(MALL_GRID).forEach(key => {
                const [gridX, gridZ] = key.split('_').map(Number);
                const room = mallGrid.getRoom(gridX, gridZ);
                if (room) {
                    RoomSystem.createRoomMeshes(THREE, room, {
                        scene: scene,
                        shelfArray: shelves,
                        shelfSystem: ShelfSystem
                    });
                }
            });
        }

        function createEnemyCart(x, z, enemyType = 'SKELETON') {
            // Get config from ENEMY_TYPES registry
            const config = ENEMY_TYPES[enemyType] || ENEMY_TYPES.CART;

            // Use EnemyVisual to create the mesh (handles both CART and SKELETON)
            const group = EnemyVisual.createEnemy(THREE, config);

            // Set userData using EnemySystem helper (includes health, damage, etc.)
            const enemyData = EnemySystem.createEnemyData(enemyType);
            Object.assign(group.userData, enemyData);

            // Position and add to scene
            group.position.set(x, 0, z);
            scene.add(group);
            enemies.push(group);
            return group;
        }

        function createObstacle(x, z, type) {
            const group = new THREE.Group();
            group.userData = {
                type: type,
                active: true,
                hit: false,
                fallAngle: 0,
                fallSpeed: 0
            };

            if (type === 'stack') {
                const colors = [0xe74c3c, 0x3498db, 0x2ecc71, 0xf1c40f, 0x9b59b6];
                const color = colors[Math.floor(Math.random() * colors.length)];

                // Pyramid of boxes
                for (let row = 0; row < 3; row++) {
                    const boxesInRow = 3 - row;
                    for (let col = 0; col < boxesInRow; col++) {
                        const boxGeo = new THREE.BoxGeometry(1, 0.8, 1);
                        const boxMat = new THREE.MeshStandardMaterial({ color: color });
                        const box = new THREE.Mesh(boxGeo, boxMat);
                        box.position.set(
                            (col - (boxesInRow - 1) / 2) * 1.1,
                            0.4 + row * 0.85,
                            0
                        );
                        box.castShadow = true;
                        group.add(box);
                    }
                }
                group.userData.width = 3;
                group.userData.height = 3;
            } else if (type === 'barrel') {
                const barrelGeo = new THREE.CylinderGeometry(0.6, 0.6, 1.5, 16);
                const barrelMat = new THREE.MeshStandardMaterial({ color: 0x2980b9 });
                const barrel = new THREE.Mesh(barrelGeo, barrelMat);
                barrel.position.y = 0.75;
                barrel.castShadow = true;
                group.add(barrel);

                // Bands
                const bandGeo = new THREE.TorusGeometry(0.62, 0.05, 8, 32);
                const bandMat = new THREE.MeshStandardMaterial({ color: 0x1a5276 });
                [-0.4, 0.4].forEach(y => {
                    const band = new THREE.Mesh(bandGeo, bandMat);
                    band.rotation.x = Math.PI / 2;
                    band.position.y = 0.75 + y;
                    group.add(band);
                });

                group.userData.width = 1.5;
                group.userData.height = 2;
            } else if (type === 'display') {
                // Promotional display stand
                const standGeo = new THREE.BoxGeometry(2, 3, 1.5);
                const standMat = new THREE.MeshStandardMaterial({ color: 0xf39c12 });
                const stand = new THREE.Mesh(standGeo, standMat);
                stand.position.y = 1.5;
                stand.castShadow = true;
                group.add(stand);

                // Sale sign
                const signGeo = new THREE.BoxGeometry(1.8, 0.8, 0.1);
                const signCanvas = document.createElement('canvas');
                signCanvas.width = 256;
                signCanvas.height = 128;
                const ctx = signCanvas.getContext('2d');
                ctx.fillStyle = '#e74c3c';
                ctx.fillRect(0, 0, 256, 128);
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 48px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('SALE!', 128, 80);
                const signTex = new THREE.CanvasTexture(signCanvas);
                const signMat = new THREE.MeshStandardMaterial({ map: signTex });
                const sign = new THREE.Mesh(signGeo, signMat);
                sign.position.set(0, 3.5, 0);
                group.add(sign);

                group.userData.width = 2.5;
                group.userData.height = 4;
            }

            group.position.set(x, 0, z);
            scene.add(group);
            obstacles.push(group);
            return group;
        }

        function createProjectile(direction, spawnPos, speed = PROJECTILE_SPEED_MAX) {
            const group = new THREE.Group();

            // Get projectile config from WeaponSystem
            const projConfig = WeaponSystem.getProjectileConfig();
            const baseSize = projConfig.size || 0.2;
            const baseColor = projConfig.color || 0xf39c12;
            const hasGlow = projConfig.glow !== false;
            const emissiveMin = projConfig.emissiveIntensity?.min || 0.2;
            const emissiveMax = projConfig.emissiveIntensity?.max || 0.6;

            // Stone/ball projectile - size scales slightly with power
            const sizeScale = 0.8 + (speed / PROJECTILE_SPEED_MAX) * 0.4;
            const stoneGeo = new THREE.SphereGeometry(baseSize * sizeScale, 12, 12);
            const stoneMat = new THREE.MeshStandardMaterial({
                color: baseColor,
                emissive: baseColor,
                emissiveIntensity: emissiveMin + (speed / PROJECTILE_SPEED_MAX) * (emissiveMax - emissiveMin)
            });
            const stone = new THREE.Mesh(stoneGeo, stoneMat);
            group.add(stone);

            // Glow - brighter for faster projectiles (if enabled)
            if (hasGlow) {
                const glowColor = projConfig.glowColor || baseColor;
                const glowGeo = new THREE.SphereGeometry(baseSize * 1.5 * sizeScale, 12, 12);
                const glowMat = new THREE.MeshBasicMaterial({
                    color: glowColor,
                    transparent: true,
                    opacity: 0.2 + (speed / PROJECTILE_SPEED_MAX) * 0.3
                });
                const glow = new THREE.Mesh(glowGeo, glowMat);
                group.add(glow);
            }

            // Use provided spawn position (slingshot) or fallback to camera
            if (spawnPos) {
                group.position.copy(spawnPos);
            } else {
                group.position.copy(camera.position);
                group.position.y -= 0.5;
            }

            // Calculate power (0-1) based on speed
            const power = (speed - PROJECTILE_SPEED_MIN) / (PROJECTILE_SPEED_MAX - PROJECTILE_SPEED_MIN);

            group.userData = {
                velocity: direction.clone().multiplyScalar(speed),
                active: true,
                prevPosition: group.position.clone(), // For sweep collision detection
                power: Math.max(0, Math.min(1, power)), // Clamped 0-1
                projectileType: WeaponSystem.getWeaponConfig().projectile
            };

            scene.add(group);
            projectiles.push(group);
            return group;
        }

        // Shared particle geometry for performance
        const particleGeo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
        const MAX_PARTICLES = 50;  // Limit particle count

        function createParticle(position, color) {
            // Enforce particle limit
            if (particles.length >= MAX_PARTICLES) return;

            const mat = new THREE.MeshBasicMaterial({ color: color });
            const particle = new THREE.Mesh(particleGeo, mat);
            particle.position.copy(position);
            particle.userData = {
                velocity: new THREE.Vector3(
                    (Math.random() - 0.5) * 10,
                    Math.random() * 8 + 2,
                    (Math.random() - 0.5) * 10
                ),
                life: 0.8  // Shorter life
            };
            scene.add(particle);
            particles.push(particle);
        }

        function spawnParticles(position, color, count) {
            // Limit particles based on current count
            const available = MAX_PARTICLES - particles.length;
            const toSpawn = Math.min(count, available);
            for (let i = 0; i < toSpawn; i++) {
                createParticle(position, color);
            }
        }

        function addScore(points, position) {
            score += points;
            UISystem.updateScore(score, true);

            // Convert 3D position to screen position and show popup
            const screenPos = UISystem.worldToScreen(position, camera);
            UISystem.showScorePopup(points, screenPos.x, screenPos.y);
        }

        // Slingshot Charging Functions (delegating to WeaponSystem)
        function startCharging() {
            if (!isChargingSlingshot && StateSystem.is('PLAYING')) {
                const now = Date.now();
                if (!WeaponSystem.canFire(now)) return; // Still on cooldown

                // Start weapon system charge
                if (WeaponSystem.startCharge(now)) {
                    // Sync legacy state for backward compatibility
                    isChargingSlingshot = true;
                    slingshotTension = WeaponSystem.getTension();
                }
            }
        }

        function updateCharging(dt) {
            if (WeaponSystem.isCharging) {
                WeaponSystem.updateCharge(dt);
                // Sync legacy state
                slingshotTension = WeaponSystem.getTension();
                isChargingSlingshot = WeaponSystem.isCharging;
            }
        }

        function cancelCharging() {
            WeaponSystem.reset();
            isChargingSlingshot = false;
            slingshotTension = 0;
        }

        function releaseAndFire() {
            if (!WeaponSystem.isCharging) return;

            const now = Date.now();
            const fireResult = WeaponSystem.fire(now);

            // Sync legacy state
            isChargingSlingshot = false;
            slingshotTension = 0;

            if (fireResult) {
                shoot(fireResult.speed);
            }
        }

        function shoot(speed = PROJECTILE_SPEED_MAX) {
            const now = Date.now();
            lastShootTime = now;

            // Trigger FPS firing animation
            if (cameraMode === 'hybrid-fps') {
                fpsFireAnim = 1.0; // Start animation
            }

            // Get spawn position (FPS mode only)
            const spawnPos = camera.position.clone();
            const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
            spawnPos.add(forward.multiplyScalar(0.5));
            spawnPos.y -= 0.3;

            // Get direction from crosshair using raycaster
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2(
                (crosshairX / window.innerWidth) * 2 - 1,
                -(crosshairY / window.innerHeight) * 2 + 1
            );
            raycaster.setFromCamera(mouse, camera);

            // Shoot toward where crosshair is pointing (auto-aim keeps it on target)
            const farPoint = new THREE.Vector3();
            farPoint.copy(raycaster.ray.direction).multiplyScalar(100).add(raycaster.ray.origin);

            const direction = new THREE.Vector3();
            direction.subVectors(farPoint, spawnPos);
            direction.normalize();

            createProjectile(direction, spawnPos, speed);

            // Visual feedback
            ammoDisplay.textContent = 'RELOADING...';
            ammoDisplay.style.borderColor = '#e94560';
            setTimeout(() => {
                ammoDisplay.textContent = 'SLINGSHOT READY';
                ammoDisplay.style.borderColor = '#3498db';
            }, SHOOT_COOLDOWN);
        }

        function resetGame() {
            score = 0;
            gameTimer = GAME_DURATION;
            lastShootTime = 0;
            scoreElement.textContent = '0';
            updateTimerDisplay();

            // Reset player position and movement (start at center of ENTRANCE room)
            playerPosition = { x: 45, z: 75 };  // Grid (1,2) center
            playerRotation = 0;
            playerSpeed = 0;
            currentTurnRate = 0;
            playerHealth = PLAYER_MAX_HEALTH;
            lastDamageTime = 0;
            isInvulnerable = false;

            // Reset input state
            InputSystem.reset();

            // Reset cart visual state
            currentLeanAngle = 0;
            fpsFireAnim = 0;

            // Reset room tracking
            currentRoom = null;
            visitedRooms.clear();

            // Reset weapon system (also resets slingshot tension)
            WeaponSystem.reset();
            slingshotTension = 0;
            isChargingSlingshot = false;

            // Reset aiming system
            AimingSystem.reset();
            crosshairX = window.innerWidth / 2;
            crosshairY = window.innerHeight / 2;
            lockedTarget = null;

            // Reset health UI
            UISystem.resetHealthBar(PLAYER_MAX_HEALTH);

            // Clear all game objects
            projectiles.forEach(p => scene.remove(p));
            enemies.forEach(e => scene.remove(e));
            obstacles.forEach(o => scene.remove(o));
            particles.forEach(p => scene.remove(p));

            projectiles = [];
            enemies = [];
            obstacles = [];
            particles = [];

            // Reset cart position
            playerCart.position.set(playerPosition.x, 0, playerPosition.z);
            playerCart.rotation.set(0, playerRotation, 0);

            // Reset camera for FPS view
            camera.position.set(playerPosition.x, 2.2, playerPosition.z);
            camera.rotation.set(-0.12, playerRotation, 0);
        }

        function updateCursor() {
            UISystem.updateCursor(StateSystem.is('PLAYING'), renderer.domElement);
        }

        function startGame() {
            resetGame();
            StateSystem.forceTransition('PLAYING');
            UISystem.showGameplay();
            // Center crosshair on start
            crosshairX = window.innerWidth / 2;
            crosshairY = window.innerHeight / 2;
            updateCursor();

            spawnInitialObjects();
        }

        function endGame(died = false) {
            StateSystem.forceTransition('GAME_OVER');
            const rating = UI.getScoreRating(score);
            UISystem.showGameOver(score, rating, died);
            updateCursor();
        }

        function damagePlayer(amount) {
            if (isInvulnerable || !StateSystem.is('PLAYING')) return;

            playerHealth = Math.max(0, playerHealth - amount);
            UISystem.updateHealthBar(playerHealth, PLAYER_MAX_HEALTH);

            // Trigger GPU-based damage vignette (scales with damage)
            damageVignetteStrength = Math.min(1.0, damageVignetteStrength + amount / 50);

            // Flash CSS overlay for immediate feedback
            UISystem.showDamageOverlay();

            // Start invulnerability
            isInvulnerable = true;
            lastDamageTime = Date.now();

            // Check for death
            if (playerHealth <= 0) {
                endGame(true);
            }
        }

        function updateInvulnerability() {
            if (isInvulnerable && Date.now() - lastDamageTime >= INVULNERABILITY_DURATION) {
                isInvulnerable = false;
            }
        }

        function pauseGame() {
            if (!StateSystem.is('PLAYING')) return;
            StateSystem.forceTransition('PAUSED');
            cancelCharging(); // Cancel any charging in progress
            UISystem.showPause(score);
            updateCursor();
        }

        function resumeGame() {
            if (!StateSystem.is('PAUSED')) return;
            StateSystem.forceTransition('PLAYING');
            UISystem.hidePause();
            LoopSystem.resetDelta(); // Reset delta to avoid jump
            updateCursor();
        }

        function quitToMenu() {
            StateSystem.forceTransition('MENU');
            UISystem.showMenu();
            resetGame();
            updateCursor();
        }

        function togglePause() {
            if (StateSystem.is('PLAYING')) {
                pauseGame();
            } else if (StateSystem.is('PAUSED')) {
                resumeGame();
            }
        }

        function spawnInitialObjects() {
            // Room-based spawning - trigger initial room spawn
            updateCurrentRoom();
        }

        function spawnObjects() {
            // Room-based spawning handles this now
            // Objects spawn when entering new rooms via updateCurrentRoom()
        }

        // Timer display update
        function updateTimerDisplay() {
            UISystem.updateTimerDisplay(gameTimer, GAME_DURATION);
        }

        // Room tracking and spawning
        function updateCurrentRoom() {
            const room = mallGrid.getRoomAtWorld(playerPosition.x, playerPosition.z);
            if (room && room !== currentRoom) {
                const roomKey = `${room.gridX}_${room.gridZ}`;
                currentRoom = room;

                // Spawn contents if not visited
                if (!visitedRooms.has(roomKey)) {
                    visitedRooms.add(roomKey);
                    spawnRoomContents(room);
                }
            }
        }

        // Spawn enemies and obstacles for a room
        function spawnRoomContents(room) {
            SpawnSystem.spawnRoomContents(room, Room.structure, {
                createEnemy: (x, z) => createEnemyCart(x, z, 'SKELETON'),
                createObstacle: (x, z, type) => createObstacle(x, z, type)
            });
        }

        function updateCooldownIndicator() {
            const elapsed = Date.now() - lastShootTime;
            UISystem.updateCooldownIndicator(elapsed, SHOOT_COOLDOWN);
        }

        function update(dt) {
            if (!StateSystem.is('PLAYING')) return;

            // Update invulnerability
            updateInvulnerability();

            // Update game timer
            gameTimer -= dt;
            if (gameTimer <= 0) {
                gameTimer = 0;
                endGame(false); // Time's up - not died
                return;
            }
            updateTimerDisplay();

            // Update room-based ambient lighting
            const room = mallGrid.getRoomAtWorld(playerPosition.x, playerPosition.z);
            if (room && room.themeData) {
                const targetColor = new THREE.Color(room.themeData.ambientColor);
                ambientLight.color.lerp(targetColor, 0.02);
            }

            // === WASD DRIVING MOVEMENT ===
            // Handle turning (A/D)
            const targetTurnRate = (InputSystem.keys.turnLeft ? 1 : 0) - (InputSystem.keys.turnRight ? 1 : 0);
            currentTurnRate += (targetTurnRate * CART_TURN_SPEED - currentTurnRate) * 8 * dt;
            playerRotation += currentTurnRate * dt;

            // Handle acceleration/deceleration (W/S)
            if (InputSystem.keys.forward) {
                playerSpeed += CART_ACCELERATION * dt;
            } else if (InputSystem.keys.backward) {
                playerSpeed -= CART_ACCELERATION * dt;
            } else {
                // Apply friction when no input, but maintain small idle drift
                if (playerSpeed > CART_IDLE_DRIFT) {
                    playerSpeed = Math.max(CART_IDLE_DRIFT, playerSpeed - CART_FRICTION * dt);
                } else if (playerSpeed < CART_IDLE_DRIFT) {
                    // Accelerate towards idle drift speed
                    playerSpeed = Math.min(CART_IDLE_DRIFT, playerSpeed + CART_FRICTION * 0.5 * dt);
                }
            }

            // Clamp speed
            playerSpeed = Math.max(-CART_REVERSE_SPEED, Math.min(CART_MAX_SPEED, playerSpeed));

            // Calculate velocity from rotation + speed
            const velocityX = -Math.sin(playerRotation) * playerSpeed;
            const velocityZ = -Math.cos(playerRotation) * playerSpeed;

            // Calculate new position
            let newX = playerPosition.x + velocityX * dt;
            let newZ = playerPosition.z + velocityZ * dt;

            // Wall collision detection
            const collision = CollisionSystem.checkWallCollision(newX, newZ, playerPosition.x, playerPosition.z, mallGrid, Room.structure);

            // Trigger wall bump effect on collision
            if (collision.blocked && playerSpeed > 1) {
                wallBumpIntensity = Math.min(1, playerSpeed / CART_MAX_SPEED);
                wallBumpDirection = {
                    x: collision.blockedX ? -Math.sign(velocityX) : 0,
                    z: collision.blockedZ ? -Math.sign(velocityZ) : 0
                };
                // Reduce speed on impact
                playerSpeed *= 0.3;
            }

            if (!collision.blockedX) playerPosition.x = newX;
            if (!collision.blockedZ) playerPosition.z = newZ;

            // Decay wall bump effect
            wallBumpIntensity *= 0.85;
            if (wallBumpIntensity < 0.01) wallBumpIntensity = 0;

            // Update cart position and rotation
            playerCart.position.x = playerPosition.x;
            playerCart.position.z = playerPosition.z;
            playerCart.rotation.y = playerRotation;

            // Cart leaning based on turn rate
            const targetLeanAngle = -currentTurnRate * CART_LEAN_ANGLE;
            currentLeanAngle += (targetLeanAngle - currentLeanAngle) * 8 * dt;
            playerCart.rotation.z = currentLeanAngle;

            // === FPS CAMERA (follows player rotation) ===
            // Apply wall bump offset to camera
            const bumpOffsetX = wallBumpDirection.x * wallBumpIntensity * 0.3;
            const bumpOffsetZ = wallBumpDirection.z * wallBumpIntensity * 0.3;
            const bumpShake = wallBumpIntensity * (Math.random() - 0.5) * 0.1;

            camera.position.x = playerPosition.x + bumpOffsetX;
            camera.position.y = 2.2 + bumpShake;
            camera.position.z = playerPosition.z + bumpOffsetZ;

            // Camera follows player rotation
            camera.rotation.set(0, 0, 0);
            camera.rotation.y = playerRotation;
            camera.rotation.x = -0.12 + wallBumpIntensity * 0.05; // Tilt on bump

            // Subtle roll for immersion + bump roll
            camera.rotation.z = currentLeanAngle * CAMERA_ROLL_FACTOR * 0.5 + bumpShake * 2;

            // FPS mode: hide child, show hands
            playerCart.visible = true;
            if (playerChild) playerChild.visible = false;
            if (slingshotArm) slingshotArm.visible = false;
            if (fpsWeapon) {
                fpsWeapon.visible = true;

                // Weapon lean when turning (matches cart lean for immersion)
                const weaponLeanAngle = -currentTurnRate * 0.15; // Subtle lean
                const weaponSway = currentTurnRate * 0.03;       // Horizontal sway

                // Smoothly interpolate weapon lean
                fpsWeapon.rotation.z = fpsWeapon.rotation.z * 0.85 + weaponLeanAngle * 0.15;
                fpsWeapon.position.x = 0.15 + fpsWeapon.position.x * 0.9 + weaponSway * 0.1;

                // Clamp position to prevent drift
                fpsWeapon.position.x = Math.max(0.1, Math.min(0.2, fpsWeapon.position.x));
            }

            // Update charging
            updateCharging(dt);

            // Animate FPS slingshot - LEFT hand pulls back pouch
            if (isChargingSlingshot) {
                // CHARGING: Left hand pulls back based on tension
                const pullBack = slingshotTension; // 0 to 1
                const pullZ = pullBack * 0.2;  // Pull back distance
                const pullY = pullBack * 0.03; // Slight upward pull

                // Move pouch and stone back with left hand
                if (fpsPouch) {
                    fpsPouch.position.z = 0.08 + pullZ;
                    fpsPouch.position.y = 0.02 + pullY;
                }
                if (fpsStone) {
                    fpsStone.position.z = 0.08 + pullZ;
                    fpsStone.position.y = 0.025 + pullY;
                    fpsStone.visible = true;
                }

                // Rubber bands stretch and thin out with tension
                const bandStretch = 1 + pullBack * 1.8;  // Length multiplier
                const bandThin = 1 - pullBack * 0.3;     // Thinner when stretched
                const bandAngle = pullBack * 0.6;        // Angle toward pull point

                if (fpsBandL) {
                    fpsBandL.scale.set(bandThin, bandStretch, bandThin);
                    fpsBandL.position.z = 0.04 + pullZ * 0.5;
                    fpsBandL.rotation.x = 0.3 + bandAngle;
                    fpsBandL.rotation.z = 0.1 - pullBack * 0.05;
                }
                if (fpsBandR) {
                    fpsBandR.scale.set(bandThin, bandStretch, bandThin);
                    fpsBandR.position.z = 0.04 + pullZ * 0.5;
                    fpsBandR.rotation.x = 0.3 + bandAngle;
                    fpsBandR.rotation.z = -0.1 + pullBack * 0.05;
                }

                // Pull LEFT hand back with pouch (pinching gesture)
                if (fpsHands && fpsHands.userData.leftHand) {
                    const leftHand = fpsHands.userData.leftHand;
                    leftHand.position.z = -0.15 + pullZ;
                    leftHand.position.y = -0.08 + pullY;
                    // Tighten pinch as tension increases
                    if (leftHand.userData.fingers) {
                        leftHand.userData.fingers[0].rotation.x = 0.8 + pullBack * 0.3; // Index curls more
                    }
                    if (leftHand.userData.thumb) {
                        leftHand.userData.thumb.rotation.x = 0.4 + pullBack * 0.2;
                    }
                }
            } else if (fpsFireAnim > 0) {
                // FIRING: Quick release animation - bands snap back
                fpsFireAnim -= dt * 8; // Fast snap
                if (fpsFireAnim < 0) fpsFireAnim = 0;

                const snapProgress = 1 - fpsFireAnim; // 0 to 1
                const snapZ = (1 - snapProgress) * 0.08;
                const snapY = (1 - snapProgress) * 0.02;

                // Pouch snaps forward
                if (fpsPouch) {
                    fpsPouch.position.z = 0.08 + snapZ;
                    fpsPouch.position.y = 0.02 + snapY;
                }
                if (fpsStone) {
                    fpsStone.position.z = 0.08 + snapZ;
                    fpsStone.position.y = 0.025 + snapY;
                    fpsStone.visible = fpsFireAnim > 0.7; // Stone disappears quickly (fired)
                }

                // Bands snap back with slight overshoot
                const bandSnap = 1 + (1 - snapProgress) * 0.4;
                const overshoot = snapProgress > 0.8 ? Math.sin((snapProgress - 0.8) * Math.PI * 5) * 0.1 : 0;

                if (fpsBandL) {
                    fpsBandL.scale.set(1, bandSnap + overshoot, 1);
                    fpsBandL.position.z = 0.04 + snapZ * 0.3;
                    fpsBandL.rotation.x = 0.3 + (1 - snapProgress) * 0.3;
                }
                if (fpsBandR) {
                    fpsBandR.scale.set(1, bandSnap + overshoot, 1);
                    fpsBandR.position.z = 0.04 + snapZ * 0.3;
                    fpsBandR.rotation.x = 0.3 + (1 - snapProgress) * 0.3;
                }

                // Left hand follows release
                if (fpsHands && fpsHands.userData.leftHand) {
                    const leftHand = fpsHands.userData.leftHand;
                    leftHand.position.z = -0.15 + snapZ;
                    leftHand.position.y = -0.08 + snapY;
                    // Open fingers after release
                    if (leftHand.userData.fingers) {
                        leftHand.userData.fingers[0].rotation.x = 0.8 + (1 - snapProgress) * 0.3;
                    }
                }
            } else {
                // READY: Reset to ready position
                if (fpsPouch) {
                    fpsPouch.position.set(0, 0.02, 0.08);
                }
                if (fpsStone) {
                    fpsStone.position.set(0, 0.025, 0.08);
                    fpsStone.visible = true;
                }
                if (fpsBandL) {
                    fpsBandL.scale.set(1, 1, 1);
                    fpsBandL.position.z = 0.04;
                    fpsBandL.rotation.set(0.3, 0, 0.1);
                }
                if (fpsBandR) {
                    fpsBandR.scale.set(1, 1, 1);
                    fpsBandR.position.z = 0.04;
                    fpsBandR.rotation.set(0.3, 0, -0.1);
                }
                if (fpsHands && fpsHands.userData.leftHand) {
                    const leftHand = fpsHands.userData.leftHand;
                    leftHand.position.set(-0.05, -0.08, -0.15);
                    if (leftHand.userData.fingers) {
                        leftHand.userData.fingers[0].rotation.x = 0.8;
                    }
                    if (leftHand.userData.thumb) {
                        leftHand.userData.thumb.rotation.x = 0.4;
                    }
                }
            }

            // Update current room for spawning
            updateCurrentRoom();

            // Smart Auto-Aim with Sticky Targeting - using AimingSystem
            let aimAssistActive = false;
            const aimConfig = AimingSystem.getProfileConfig();

            // Helper to check if a target object is still valid
            function isTargetValid(obj) {
                if (!obj || !obj.userData?.active) return false;
                if (obj.userData.hit) return false; // Obstacle already hit

                // Check if in front of camera
                const pos = obj.position.clone();
                pos.project(camera);
                if (pos.z >= 1 || pos.z <= 0) return false;

                // Check if passed behind player
                const zDist = camera.position.z - obj.position.z;
                if (zDist < -10) return false; // Too far behind

                // Check line-of-sight (no walls blocking)
                if (!CollisionSystem.hasLineOfSight(playerPosition.x, playerPosition.z, obj.position.x, obj.position.z, mallGrid, Room.structure)) {
                    return false; // Wall blocks view
                }

                return true;
            }

            // Helper to get screen position of target
            function getTargetScreenPos(obj, yOffset = 0) {
                const pos = obj.position.clone();
                pos.y += yOffset;
                pos.project(camera);
                return {
                    x: (pos.x * 0.5 + 0.5) * window.innerWidth,
                    y: (-pos.y * 0.5 + 0.5) * window.innerHeight
                };
            }

            // Only do aim assist if enabled by AimingSystem and WeaponSystem
            if (AimingSystem.isEnabled() && WeaponSystem.getAimAssistEnabled()) {
                // Check if current locked target is still valid (sticky targeting)
                if (lockedTarget && aimConfig.stickyTargeting && isTargetValid(lockedTarget)) {
                    // Keep tracking current target
                    aimAssistActive = true;
                    AimingSystem.setLock(lockedTarget);
                    const yOffset = lockedTarget.userData.height ? lockedTarget.userData.height * 0.4 : 1.5;
                    const screenPos = getTargetScreenPos(lockedTarget, yOffset);
                    crosshairX = screenPos.x;
                    crosshairY = screenPos.y;
                } else {
                    // Find new best target using AimingSystem scoring
                    AimingSystem.clearLock();
                    lockedTarget = null;
                    let bestTarget = null;
                    let bestScore = -Infinity;

                    // Evaluate enemies using AimingSystem.scoreEnemy
                    enemies.forEach(enemy => {
                        if (!isTargetValid(enemy)) return;
                        const score = AimingSystem.scoreEnemy(enemy, camera.position, playerPosition, aimConfig);
                        if (score > bestScore) {
                            bestScore = score;
                            bestTarget = enemy;
                        }
                    });

                    // Evaluate obstacles using AimingSystem.scoreObstacle
                    obstacles.forEach(obs => {
                        if (!isTargetValid(obs)) return;
                        const score = AimingSystem.scoreObstacle(obs, camera.position, playerPosition, aimConfig);
                        if (score > bestScore) {
                            bestScore = score;
                            bestTarget = obs;
                        }
                    });

                    // Lock onto new target
                    if (bestTarget) {
                        lockedTarget = bestTarget;
                        aimAssistActive = true;
                        AimingSystem.setLock(bestTarget);
                        const yOffset = bestTarget.userData.height ? bestTarget.userData.height * 0.4 : 1.5;
                        const screenPos = getTargetScreenPos(bestTarget, yOffset);
                        crosshairX = screenPos.x;
                        crosshairY = screenPos.y;
                    }
                }
            }

            // Sync crosshair position with AimingSystem
            AimingSystem.updateCrosshair(crosshairX, crosshairY);

            // Keep crosshair within screen bounds
            crosshairX = Math.max(CROSSHAIR_BOUNDS_MARGIN, Math.min(window.innerWidth - CROSSHAIR_BOUNDS_MARGIN, crosshairX));
            crosshairY = Math.max(CROSSHAIR_BOUNDS_MARGIN, Math.min(window.innerHeight - CROSSHAIR_BOUNDS_MARGIN, crosshairY));

            // Update crosshair DOM position and aim-assist visual feedback (using AimingSystem state)
            const crosshairEl = document.getElementById('crosshair');
            if (AimingSystem.isAimAssistActive()) {
                crosshairEl.classList.add('aim-assist-active');
            } else {
                crosshairEl.classList.remove('aim-assist-active');
            }
            const crosshairPos = AimingSystem.getCrosshairPosition();
            crosshairEl.style.left = crosshairPos.x + 'px';
            crosshairEl.style.top = crosshairPos.y + 'px';

            // Update tension indicator (using AimingSystem for position)
            const tensionEl = document.getElementById('tension-indicator');
            if (tensionEl) {
                tensionEl.style.left = crosshairPos.x + 'px';
                tensionEl.style.top = crosshairPos.y + 'px';

                if (isChargingSlingshot) {
                    tensionEl.classList.add('charging');

                    // Update tension class for color
                    tensionEl.classList.remove('medium', 'high', 'max');
                    if (slingshotTension >= TENSION_MAX) {
                        tensionEl.classList.add('max');
                    } else if (slingshotTension >= 0.7) {
                        tensionEl.classList.add('high');
                    } else if (slingshotTension >= 0.4) {
                        tensionEl.classList.add('medium');
                    }

                    // Update arc fill (283 = circumference of r=45 circle)
                    const fillEl = tensionEl.querySelector('.tension-fill');
                    if (fillEl) {
                        const dashOffset = 283 * (1 - slingshotTension);
                        fillEl.style.strokeDashoffset = dashOffset;
                    }

                    // Update text
                    const textEl = document.getElementById('tension-text');
                    if (textEl) {
                        const power = Math.round(slingshotTension * 100);
                        textEl.textContent = power >= 100 ? 'MAX POWER!' : power + '%';
                    }
                } else {
                    tensionEl.classList.remove('charging', 'medium', 'high', 'max');
                }
            }

            // Spawn new objects (room-based)
            spawnObjects();

            // Update projectiles
            projectiles.forEach(proj => {
                if (!proj.userData.active) return;
                proj.position.add(proj.userData.velocity.clone().multiplyScalar(dt));

                // Check if out of bounds (relative to camera position)
                const distFromCamera = proj.position.distanceTo(camera.position);
                if (distFromCamera > 150 ||
                    proj.position.y < 0 || proj.position.y > 15) {
                    proj.userData.active = false;
                }
            });

            // Update enemies
            enemies.forEach(enemy => {
                if (!enemy.userData.active) return;

                // Use EnemySystem for behavior updates (movement + drift)
                EnemySystem.updateBehavior(enemy, playerPosition, dt, CART_SPEED);

                // Calculate distance for other checks
                const toPlayer = new THREE.Vector3(
                    playerPosition.x - enemy.position.x,
                    0,
                    playerPosition.z - enemy.position.z
                );
                const distToPlayer = toPlayer.length();

                // Face player
                const lookDir = Math.atan2(
                    playerPosition.x - enemy.position.x,
                    playerPosition.z - enemy.position.z
                );
                enemy.rotation.y = lookDir;

                // Animate eyes (track player)
                if (typeof EnemyVisual !== 'undefined' && enemy.userData.cart) {
                    EnemyVisual.animateEyes(enemy.userData.cart, playerPosition);
                }

                // Animate skeleton walking (pushing cart with effort)
                if (typeof EnemyVisual !== 'undefined' && enemy.userData.skeleton) {
                    const walkSpeed = enemy.userData.config?.walkSpeed || 3.5;
                    enemy.userData.walkTimer = (enemy.userData.walkTimer || 0) + dt * walkSpeed;
                    EnemyVisual.animateSkeletonWalk(enemy.userData.cart, enemy.userData.walkTimer, walkSpeed);
                }

                // Hit flash
                if (enemy.userData.hitFlash > 0) {
                    enemy.userData.hitFlash -= dt * 5;
                    if (enemy.userData.hitFlash < 0) enemy.userData.hitFlash = 0;

                    // Use EnemyVisual for hit flash if available
                    if (typeof EnemyVisual !== 'undefined' && enemy.userData.cart) {
                        EnemyVisual.applyHitFlash(enemy.userData.cart, enemy.userData.hitFlash);
                    } else {
                        // Fallback for legacy enemies
                        enemy.children.forEach(child => {
                            if (child.material && child.material.emissive) {
                                child.material.emissiveIntensity = enemy.userData.hitFlash;
                            }
                        });
                    }
                }

                // Remove if too far from player (outside current room area)
                if (distToPlayer > 60) {
                    enemy.userData.active = false;
                }

                // Player collision with enemy (use cart position, not camera)
                if (enemy.userData.active && !isInvulnerable) {
                    const distToPlayer = Math.sqrt(
                        Math.pow(enemy.position.x - playerCart.position.x, 2) +
                        Math.pow(enemy.position.z - playerCart.position.z, 2)
                    );
                    if (distToPlayer < 3.5) {
                        damagePlayer(ENEMY_COLLISION_DAMAGE);
                    }
                }
            });

            // Update obstacles
            obstacles.forEach(obs => {
                if (!obs.userData.active) return;

                if (obs.userData.hit) {
                    obs.userData.fallSpeed += 5 * dt;
                    obs.userData.fallAngle += obs.userData.fallSpeed * dt;
                    obs.rotation.x = obs.userData.fallAngle;
                    obs.position.y -= obs.userData.fallSpeed * dt * 0.5;

                    if (obs.userData.fallAngle > Math.PI / 2) {
                        obs.userData.active = false;
                    }
                }

                // Remove if too far from player
                const distToPlayer = obs.position.distanceTo(playerCart.position);
                if (distToPlayer > 60) {
                    obs.userData.active = false;
                }

                // Player collision with obstacle (use cart position, not camera)
                if (obs.userData.active && !obs.userData.hit && !isInvulnerable) {
                    const distToPlayer = Math.sqrt(
                        Math.pow(obs.position.x - playerCart.position.x, 2) +
                        Math.pow(obs.position.z - playerCart.position.z, 2)
                    );
                    const hitDist = (obs.userData.width || 2) * 0.6;
                    if (distToPlayer < hitDist + 1.5) {
                        damagePlayer(OBSTACLE_COLLISION_DAMAGE);
                        obs.userData.hit = true; // Knock it over too
                    }
                }
            });

            // Update particles
            particles.forEach(particle => {
                particle.userData.velocity.y -= 15 * dt;
                particle.position.add(particle.userData.velocity.clone().multiplyScalar(dt));
                particle.userData.life -= dt * 2;
                particle.material.opacity = particle.userData.life;
                particle.material.transparent = true;
            });

            // Collision detection with improved accuracy
            projectiles.forEach(proj => {
                if (!proj.userData.active) return;

                // Store previous position for sweep check
                const prevPos = proj.userData.prevPosition || proj.position.clone();
                const currPos = proj.position;

                // Check enemy collisions - optimized with early exit and reused vectors
                const projDir = currPos.clone().sub(prevPos);
                const projLen = projDir.length();
                if (projLen > 0) {
                    projDir.normalize();
                }

                for (let i = 0; i < enemies.length && proj.userData.active; i++) {
                    const enemy = enemies[i];
                    if (!enemy.userData.active) continue;

                    // Quick distance check first (cheaper than full calculation)
                    const dx = enemy.position.x - currPos.x;
                    const dz = enemy.position.z - currPos.z;
                    if (dx * dx + dz * dz > 100) continue;  // Skip if > 10 units away

                    // Enemy hitbox center
                    const enemyCenter = enemy.position.clone();
                    enemyCenter.y += 1.2;

                    const hitRadius = 2.5;
                    const toEnemy = enemyCenter.sub(prevPos);  // Reuse enemyCenter vector

                    if (projLen > 0) {
                        const dot = toEnemy.dot(projDir);
                        const clampedDot = Math.max(0, Math.min(projLen, dot));
                        const closestPoint = prevPos.clone().addScaledVector(projDir, clampedDot);
                        enemyCenter.copy(enemy.position).y += 1.2;  // Restore for distance check
                        const dist = closestPoint.distanceTo(enemyCenter);

                        if (dist < hitRadius) {
                            proj.userData.active = false;
                            const damage = 1 + Math.round((proj.userData.power || 0) * 2);

                            // Use EnemySystem for damage handling
                            const result = EnemySystem.damage(enemy, damage);
                            if (result) {
                                UISystem.showHitMarker();

                                // Update health bar using EnemySystem helper
                                const healthPercent = EnemySystem.getHealthPercent(enemy);
                                const healthBarGroup = enemy.userData.healthBar;
                                if (healthBarGroup && typeof EnemyVisual !== 'undefined') {
                                    EnemyVisual.updateHealthBar(healthBarGroup, healthPercent);
                                } else {
                                    // Fallback for legacy health bar
                                    const healthBar = enemy.getObjectByName('healthBar');
                                    if (healthBar) {
                                        healthBar.scale.x = healthPercent;
                                        healthBar.position.x = -(1 - healthBar.scale.x);
                                    }
                                }

                                // Use score values from EnemySystem result
                                const config = enemy.userData.config || ENEMY_TYPES.CART;
                                const visualColor = config.visual?.bodyColor || 0xe94560;
                                if (result.destroyed) {
                                    addScore(result.scoreDestroy, enemy.position);
                                    spawnParticles(enemy.position, visualColor, 15);
                                } else {
                                    addScore(result.scoreHit, enemy.position);
                                    spawnParticles(closestPoint, 0xf39c12, 3);
                                }
                            }
                        }
                    }
                }

                // Check obstacle collisions - optimized
                for (let i = 0; i < obstacles.length && proj.userData.active; i++) {
                    const obs = obstacles[i];
                    if (!obs.userData.active || obs.userData.hit) continue;

                    // Quick distance check
                    const dx = obs.position.x - currPos.x;
                    const dz = obs.position.z - currPos.z;
                    if (dx * dx + dz * dz > 64) continue;  // Skip if > 8 units away

                    const obsCenter = obs.position.clone();
                    obsCenter.y += (obs.userData.height || 2) * 0.4;
                    const hitRadius = (obs.userData.width || 2) * 0.8;

                    const toObs = obsCenter.sub(prevPos);

                    if (projLen > 0) {
                        const dot = toObs.dot(projDir);
                        const clampedDot = Math.max(0, Math.min(projLen, dot));
                        const closestPoint = prevPos.clone().addScaledVector(projDir, clampedDot);
                        obsCenter.copy(obs.position).y += (obs.userData.height || 2) * 0.4;
                        const dist = closestPoint.distanceTo(obsCenter);

                        if (dist < hitRadius) {
                            proj.userData.active = false;
                            obs.userData.hit = true;
                            UISystem.showHitMarker();
                            addScore(150, obs.position);
                            spawnParticles(obs.position, 0xf1c40f, 10);  // Fewer particles
                        }
                    }
                }

                // Store current position for next frame's sweep check
                proj.userData.prevPosition = proj.position.clone();
            });

            // Clean up inactive objects
            projectiles = projectiles.filter(p => {
                if (!p.userData.active) {
                    scene.remove(p);
                    return false;
                }
                return true;
            });

            enemies = enemies.filter(e => {
                if (!e.userData.active) {
                    scene.remove(e);
                    return false;
                }
                return true;
            });

            obstacles = obstacles.filter(o => {
                if (!o.userData.active) {
                    scene.remove(o);
                    return false;
                }
                return true;
            });

            particles = particles.filter(p => {
                if (p.userData.life <= 0) {
                    scene.remove(p);
                    return false;
                }
                return true;
            });

            updateCooldownIndicator();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            if (composer) composer.setSize(window.innerWidth, window.innerHeight);
        }

        // Game loop handled by GameLoop module (configured in initialization)

        // Event Listeners
        document.getElementById('start-btn').addEventListener('click', startGame);
        document.getElementById('restart-btn').addEventListener('click', startGame);
        document.getElementById('resume-btn').addEventListener('click', resumeGame);
        document.getElementById('quit-btn').addEventListener('click', quitToMenu);

        // How to Play modal
        const howToPlayModal = document.getElementById('how-to-play-modal');
        const modalCloseBtn = document.getElementById('modal-close');

        document.getElementById('how-to-play-btn').addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            howToPlayModal.classList.add('visible');
        });

        modalCloseBtn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            howToPlayModal.classList.remove('visible');
        });

        // Also handle touch for mobile
        modalCloseBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            howToPlayModal.classList.remove('visible');
        });

        // Close on backdrop click
        howToPlayModal.addEventListener('click', (e) => {
            if (e.target === howToPlayModal) {
                howToPlayModal.classList.remove('visible');
            }
        });

        // Close on ESC key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && howToPlayModal.classList.contains('visible')) {
                howToPlayModal.classList.remove('visible');
                e.stopPropagation();
            }
        }, true);

        // Keyboard controls handled by Input module (initialized above)
        // WASD movement, Space (fire), and ESC (pause) are all handled via Input callbacks

        // Expose game state and functions for testing
        Object.defineProperty(window, 'gameState', {
            get: () => StateSystem.get(),
            set: (v) => { StateSystem.forceTransition(v); }
        });
        Object.defineProperty(window, 'score', {
            get: () => score,
            set: (v) => { score = v; }
        });
        Object.defineProperty(window, 'gameTimer', {
            get: () => gameTimer,
            set: (v) => { gameTimer = v; }
        });
        // Legacy compatibility - distance now returns timer-based progress
        Object.defineProperty(window, 'distance', {
            get: () => (GAME_DURATION - gameTimer) * (CART_SPEED / 3),
            set: (v) => { }
        });
        // playerX returns offset from starting position for legacy test compatibility
        // (v2 tests expected lateral strafe bounded to 10)
        const PLAYER_START_X = 45; // Center of ENTRANCE room
        Object.defineProperty(window, 'playerX', {
            get: () => playerPosition.x - PLAYER_START_X,
            set: (v) => { playerPosition.x = v + PLAYER_START_X; }
        });
        Object.defineProperty(window, 'playerPosition', {
            get: () => playerPosition,
            set: (v) => { playerPosition = v; }
        });
        Object.defineProperty(window, 'playerRotation', {
            get: () => playerRotation,
            set: (v) => { playerRotation = v; }
        });
        Object.defineProperty(window, 'playerHealth', {
            get: () => playerHealth,
            set: (v) => { playerHealth = v; }
        });
        Object.defineProperty(window, 'health', {
            get: () => playerHealth,
            set: (v) => { playerHealth = v; }
        });
        window.startGame = startGame;
        window.pauseGame = pauseGame;
        window.resumeGame = resumeGame;
        window.endGame = endGame;
        window.damagePlayer = damagePlayer;
        window.takeDamage = damagePlayer;
        window.keys = InputSystem.keys;
        window.enemies = enemies;
        window.obstacles = obstacles;

        // Expose 3D objects for testing
        Object.defineProperty(window, 'fpsWeapon', {
            get: () => fpsWeapon
        });
        Object.defineProperty(window, 'playerChild', {
            get: () => playerChild
        });
        Object.defineProperty(window, 'playerCart', {
            get: () => playerCart
        });

        // Expose slingshot tension for testing
        Object.defineProperty(window, 'slingshotTension', {
            get: () => slingshotTension,
            set: (v) => { slingshotTension = v; }
        });
        Object.defineProperty(window, 'isChargingSlingshot', {
            get: () => isChargingSlingshot,
            set: (v) => { isChargingSlingshot = v; }
        });
        window.startCharging = startCharging;
        window.releaseAndFire = releaseAndFire;
        window.cancelCharging = cancelCharging;
        // Aliases for test compatibility
        window.startFiring = startCharging;
        window.stopFiring = releaseAndFire;
        Object.defineProperty(window, 'isFiring', {
            get: () => isChargingSlingshot
        });
        window.resetGame = resetGame;
        // Manual update function for test compatibility (RAF may not run in backgrounded iframes)
        window.manualUpdate = (dt = 0.016) => update(dt);
        // Wall bump effect exposure for testing
        Object.defineProperty(window, 'wallBumpIntensity', {
            get: () => wallBumpIntensity,
            set: (v) => { wallBumpIntensity = v; }
        });
        window.triggerWallBump = (intensity, dirX, dirZ) => {
            wallBumpIntensity = intensity;
            wallBumpDirection = { x: dirX, z: dirZ };
        };
        Object.defineProperty(window, 'cameraMode', {
            get: () => cameraMode,
            set: (v) => { cameraMode = v; }
        });
        // Expose lastShootTime for test to reset cooldown
        Object.defineProperty(window, 'lastShootTime', {
            get: () => lastShootTime,
            set: (v) => { lastShootTime = v; }
        });
        Object.defineProperty(window, 'camera', {
            get: () => camera
        });
        Object.defineProperty(window, 'projectiles', {
            get: () => projectiles
        });

        // Expose domain objects for testing
        // Engine domain
        window.Engine = Engine;
        window.CollisionSystem = CollisionSystem;
        window.InputSystem = InputSystem;
        window.StateSystem = StateSystem;
        window.LoopSystem = LoopSystem;
        window.SceneSystem = SceneSystem;
        window.EntitySystem = EntitySystem;

        // Weapon domain
        window.Weapon = Weapon;
        window.WeaponMesh = WeaponMesh;
        window.WeaponVisual = WeaponMesh; // Alias for backward compatibility
        window.WeaponSystem = WeaponSystem;

        // Projectile domain
        window.Projectile = Projectile;
        window.ProjectileVisual = ProjectileVisual;
        window.ProjectileSystem = ProjectileSystem;

        // Enemy domain
        window.Enemy = Enemy;
        window.EnemyVisual = EnemyVisual;
        window.EnemySystem = EnemySystem;

        // Room domain
        window.Room = Room;
        window.RoomTheme = RoomTheme;
        window.RoomMesh = RoomMesh;
        window.RoomSystem = RoomSystem;

        // Player domain
        window.Player = Player;
        window.PlayerTheme = PlayerTheme;
        window.PlayerMesh = PlayerMesh;
        window.PlayerSystem = PlayerSystem;

        // Environment domain
        window.Obstacle = Obstacle;
        window.ObstacleVisual = ObstacleVisual;
        window.Shelf = Shelf;
        window.ShelfVisual = ShelfVisual;
        window.EnvironmentSystem = EnvironmentSystem;

        // Legacy aliases for backward compatibility with existing game code
        const WEAPON_TYPES = Weapon.types;
        const PROJECTILE_TYPES = Projectile.types;
        const ENEMY_TYPES = Enemy.types;
        const AIM_PROFILES = Weapon.aimProfiles;

        // Initialize and start
        initThree();

        // Initialize engine systems
        StateSystem.init('MENU');
        LoopSystem.init(THREE);

        // Configure game loop callbacks
        LoopSystem.setUpdateCallback(update);
        LoopSystem.setRenderCallback((dt) => {
            // Decay damage vignette (for CSS overlay)
            damageVignetteStrength *= 0.95;

            // Render with post-processing
            if (composer) {
                composer.render(dt);
            } else {
                renderer.render(scene, camera);
            }
        });

        InputSystem.init();
        EntitySystem.init(scene);

        // Register Input action callbacks
        InputSystem.onActionStart('fire', () => {
            if (StateSystem.is('PLAYING')) startCharging();
        });
        InputSystem.onActionRelease('fire', () => {
            if (StateSystem.is('PLAYING')) releaseAndFire();
        });
        InputSystem.onActionStart('pause', togglePause);

        // Register entity types with EntityManager
        EntitySystem.registerType('enemy', { maxCount: 10, despawnDistance: 20 });
        EntitySystem.registerType('obstacle', { maxCount: 15, despawnDistance: 30 });
        EntitySystem.registerType('projectile', { maxCount: 50, despawnDistance: 20 });
        EntitySystem.registerType('particle', { maxCount: 100, despawnDistance: 50 });

        // Initialize domain systems
        WeaponSystem.init(Weapon);
        EnemySystem.init(Enemy, scene);

        updateCursor();

        // Set initial UI state (MENU)
        healthContainer.style.display = 'none';
        hud.style.display = 'none';

        // Start the game loop
        LoopSystem.start();
    </script>
</body>
</html>
