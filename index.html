<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mall Hell</title>
    <link rel="stylesheet" href="./src/styles/main.css">
</head>
<body>
    <div id="game-container">
        <div id="ui-layer">
            <div id="crosshair"><div id="crosshair-circle"></div><div id="crosshair-dot"></div></div>

            <!-- Tension Indicator (ring around crosshair) -->
            <div id="tension-indicator">
                <svg viewBox="0 0 100 100">
                    <circle class="tension-bg" cx="50" cy="50" r="45"/>
                    <circle class="tension-fill" cx="50" cy="50" r="45"/>
                </svg>
                <div id="tension-text"></div>
            </div>

            <div id="hud">
                <div id="score-container">
                    <div id="score-label">CHAOS SCORE</div>
                    <div id="score">0</div>
                </div>

                <div id="timer-container">
                    <div id="timer-label">TIME REMAINING</div>
                    <div id="timer-display">3:00</div>
                    <div id="timer-bar">
                        <div id="timer-fill"></div>
                    </div>
                </div>

                <div id="ammo-display">SLINGSHOT READY</div>

                <div id="pause-indicator">ESC to Pause</div>

                <div id="controls-hint">A/D Dodge | SPACE Fire</div>
            </div>

            <div id="health-container">
                <div id="health-label">HEALTH</div>
                <div id="health-bar">
                    <div id="health-fill"></div>
                </div>
                <div id="health-value">100</div>
            </div>

            <div id="cooldown-indicator">
                <div id="cooldown-ring">
                    <div id="cooldown-fill"></div>
                </div>
            </div>

            <div id="hit-marker"></div>
            <div id="damage-overlay"></div>

            <div id="menu-screen">
                <div class="menu-container">
                    <div class="title-wrapper">
                        <div class="title">MALL HELL</div>
                    </div>
                    <div class="version">VERSION 4.1</div>
                    <div class="subtitle">SUPERMARKET MAYHEM</div>
                    <div class="instructions" id="instructions">
                        <div class="control-item">
                            <span class="control-key">W / ↑</span>
                            <span class="control-action">Drive</span>
                        </div>
                        <div class="control-item">
                            <span class="control-key">S / ↓</span>
                            <span class="control-action">Reverse</span>
                        </div>
                        <div class="control-item">
                            <span class="control-key">A / ←</span>
                            <span class="control-action">Turn Left</span>
                        </div>
                        <div class="control-item">
                            <span class="control-key">D / →</span>
                            <span class="control-action">Turn Right</span>
                        </div>
                        <div class="control-item">
                            <span class="control-key">SPACE</span>
                            <span class="control-action">Charge & Fire</span>
                        </div>
                    </div>
                    <div class="how-to-play-btn" id="how-to-play-btn">[ HOW TO PLAY ]</div>
                    <button class="btn" id="start-btn">START CHAOS</button>
                </div>
            </div>

            <div id="how-to-play-modal">
                <div class="modal-content">
                    <h2>HOW TO PLAY</h2>
                    <h3>YOU ARE A KID IN A SHOPPING CART</h3>
                    <p>Explore the mall and cause as much chaos as possible before time runs out!</p>
                    <h3>CONTROLS</h3>
                    <p><span class="key">W/S</span> Drive forward and reverse</p>
                    <p><span class="key">A/D</span> Dodge left and right to aim</p>
                    <p><span class="key">SPACE</span> Hold to charge your slingshot, release to fire</p>
                    <h3>AIMING</h3>
                    <p>Line up your crosshair with enemies by dodging left and right. Fire when ready!</p>
                    <h3>SCORING</h3>
                    <p>Hit enemies: +100 points<br>Destroy enemies: +300 points<br>Hit obstacles: +150 points</p>
                    <h3>TIP</h3>
                    <p>Explore all 16 mall sections to maximize your chaos score!</p>
                    <button class="modal-close" id="modal-close">GOT IT!</button>
                </div>
            </div>

            <div id="gameover-screen">
                <div class="menu-container">
                    <div class="title" id="gameover-title">CHECKOUT!</div>
                    <div id="final-score-container">
                        <div id="final-score-label">TOTAL CHAOS</div>
                        <div id="final-score">0</div>
                        <div id="rating">Mild Mischief</div>
                    </div>
                    <button class="btn" id="restart-btn">PLAY AGAIN</button>
                </div>
            </div>

            <div id="pause-screen">
                <div class="menu-container">
                    <div class="title">PAUSED</div>
                    <div class="pause-score">Current Chaos: <span id="pause-score-value">0</span></div>
                    <div class="pause-buttons">
                        <button class="pause-btn primary" id="resume-btn">RESUME</button>
                        <button class="pause-btn" id="quit-btn">QUIT TO MENU</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <!-- Shared Libraries -->
    <script src="./src/shared/materials-theme.js"></script>

    <!-- UI Domain -->
    <script src="./src/ui/ui.js"></script>
    <script src="./src/ui/ui-system.js"></script>

    <!-- Engine Domain (core systems - load first) -->
    <script src="./src/engine/engine.js"></script>
    <script src="./src/engine/collision-system.js"></script>
    <script src="./src/engine/input-system.js"></script>
    <script src="./src/engine/state-system.js"></script>
    <script src="./src/engine/loop-system.js"></script>
    <script src="./src/engine/scene-system.js"></script>
    <script src="./src/engine/entity-system.js"></script>
    <script src="./src/engine/game-session.js"></script>
    <script src="./src/engine/post-process-system.js"></script>

    <!-- Room Domain -->
    <script src="./src/room/room.js"></script>
    <script src="./src/room/room-theme.js"></script>
    <script src="./src/room/room-mesh.js"></script>
    <script src="./src/room/room-system.js"></script>

    <!-- Player Domain -->
    <script src="./src/player/player.js"></script>
    <script src="./src/player/player-theme.js"></script>
    <script src="./src/player/player-mesh.js"></script>
    <script src="./src/player/player-system.js"></script>

    <!-- Weapon Domain -->
    <script src="./src/weapon/weapon.js"></script>
    <script src="./src/weapon/weapon-manager.js"></script>
    <script src="./src/weapon/slingshot.js"></script>
    <script src="./src/weapon/watergun.js"></script>
    <script src="./src/weapon/nerfgun.js"></script>
    <script src="./src/weapon/pickup.js"></script>
    <script src="./src/weapon/pickup-system.js"></script>

    <!-- Projectile Domain -->
    <script src="./src/projectile/projectile.js"></script>
    <script src="./src/projectile/projectile-theme.js"></script>
    <script src="./src/projectile/projectile-mesh.js"></script>
    <script src="./src/projectile/projectile-system.js"></script>
    <script src="./src/particle/particle-system.js"></script>

    <!-- Enemy Domain -->
    <script src="./src/enemy/enemy.js"></script>
    <script src="./src/enemy/enemy-theme.js"></script>
    <script src="./src/enemy/enemy-mesh.js"></script>
    <script src="./src/enemy/enemy-system.js"></script>

    <!-- Environment Domain (Obstacles + Shelves) -->
    <script src="./src/environment/obstacle.js"></script>
    <script src="./src/environment/obstacle-theme.js"></script>
    <script src="./src/environment/obstacle-mesh.js"></script>
    <script src="./src/environment/shelf.js"></script>
    <script src="./src/environment/shelf-theme.js"></script>
    <script src="./src/environment/shelf-mesh.js"></script>
    <script src="./src/environment/environment-system.js"></script>
    <script src="./src/environment/spawn-system.js"></script>

    <script>
        // Domain modules loaded:
        // - Room: Room, RoomTheme, RoomMesh, RoomSystem
        // - Player: Player, PlayerTheme, PlayerMesh, PlayerSystem
        // - Weapon: Weapon, WeaponManager, Slingshot, WaterGun, NerfGun, WeaponPickup, PickupSystem
        // - Projectile: Projectile, ProjectileTheme, ProjectileMesh (as ProjectileVisual), ProjectileSystem
        // - Enemy: Enemy, EnemyTheme, EnemyMesh (as EnemyVisual), EnemySystem
        // - Environment: Obstacle, ObstacleTheme, ObstacleMesh (as ObstacleVisual), Shelf, ShelfTheme, ShelfMesh, EnvironmentSystem

        // ============================================
        // GAME CONSTANTS
        // ============================================
        // Core constants used in index.html. Domain-specific values accessed via domain modules.

        const CROSSHAIR_BOUNDS_MARGIN = 50;

        // Domain constant aliases
        const PLAYER_MAX_HEALTH = Player.health.MAX;
        const CART_SPEED = Player.movement.SPEED;
        const MALL_THEMES = RoomTheme.themes;

        // ShelfSystem shim - delegates to Shelf for RoomSystem compatibility
        const ShelfSystem = {
            getShelfTemplate: (id) => Shelf.getTemplate(id),
            getProductGeometry: (id) => Shelf.getProductType(id),
            pickProductColor: (theme) => Shelf.pickColor(theme.productColors || theme)
        };

        // Initialize RoomSystem with layout from Room.layout
        RoomSystem.init(Room, RoomTheme);
        RoomSystem.loadLayout(MALL_THEMES);

        // Mall Grid interface (delegates to RoomSystem)
        const mallGrid = RoomSystem;

        // Game State - only variables that need local tracking
        let lastShootTime = 0;
        const cameraMode = 'hybrid-fps';    // v3.0 is FPS only

        // Three.js Setup
        let scene, camera, renderer;
        let projectiles = [];
        let enemies = [];
        let obstacles = [];
        let particles = [];
        let shelves = [];
        let ambientLight;
        let isFrozen = false;

        // Player mesh references
        let playerCart, playerChild, slingshotArm;

        // Room tracking
        let currentRoom = null;
        let visitedRooms = new Set();

        // Crosshair state
        let crosshairX = window.innerWidth / 2;
        let crosshairY = window.innerHeight / 2;

        // Locked target for sticky aim (don't switch until target gone)
        let lockedTarget = null;

        // Keyboard input handled by Input module (initialized later)

        // Clock handled by GameLoop module
        // Materials library loaded from src/shared/materials-theme.js

        // Scene hierarchy groups
        const sceneGroups = { environment: null, gameplay: null, effects: null, lighting: null };
        function initSceneGroups() {
            ['environment', 'gameplay', 'effects', 'lighting'].forEach(n => {
                sceneGroups[n] = new THREE.Group(); sceneGroups[n].name = n; scene.add(sceneGroups[n]);
            });
        }

        // Post-processing state
        let composer = null, damageVignetteStrength = 0;

        // DOM Elements (only what's needed - UISystem handles the rest)
        const container = document.getElementById('game-container');
        const scoreElement = document.getElementById('score');
        const hud = document.getElementById('hud');
        const ammoDisplay = document.getElementById('ammo-display');
        const healthContainer = document.getElementById('health-container');

        // Initialize Three.js using SceneSystem
        function initThree() {
            SceneSystem.init(THREE, container);
            scene = SceneSystem.scene; camera = SceneSystem.camera; renderer = SceneSystem.renderer;
            MaterialsTheme.init(THREE); UISystem.init(); initSceneGroups();

            // Lighting
            ambientLight = new THREE.AmbientLight(0xfff8f0, 0.6); scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(10, 20, 10); dirLight.castShadow = true;
            Object.assign(dirLight.shadow.mapSize, { width: 2048, height: 2048 });
            Object.assign(dirLight.shadow.camera, { near: 0.5, far: 100, left: -30, right: 30, top: 30, bottom: -30 });
            scene.add(dirLight);

            // Player and weapons
            createEnvironment();
            const p = PlayerMesh.createPlayerCart(THREE);
            playerCart = p.cart; playerChild = p.child; slingshotArm = p.slingshot;
            playerCart.position.set(0, 0, -5); scene.add(playerCart);
            WeaponManager.init(scene);
            [Slingshot, WaterGun, NerfGun].forEach(w => WeaponManager.register(w));
            WeaponManager.equip('slingshot', THREE, MaterialsTheme, camera);
            PickupSystem.init(scene, THREE);
        }

        function initPostProcessing() {
            const r = PostProcessSystem.init(THREE, renderer, scene, camera, { bloomStrength: 0.4, bloomThreshold: 0.8, damageIntensity: 0.0 });
            composer = r.composer; window.composer = composer;
        }

        function createEnvironment() {
            RoomSystem.getAllRooms().forEach(room => room && RoomSystem.createRoomMeshes(THREE, room, { scene, shelfArray: shelves, shelfSystem: ShelfSystem }));
        }

        function createEnemyCart(x, z, enemyType = 'SKELETON') {
            const g = EnemySystem.createMesh(THREE, enemyType, x, z);
            if (g) { scene.add(g); enemies.push(g); }
            return g;
        }

        function createObstacle(x, z, type) {
            const g = ObstacleVisual.createByType(THREE, type);
            g.position.set(x, 0, z);
            scene.add(g); obstacles.push(g);
            return g;
        }

        function createProjectile(direction, spawnPos, speed) {
            const ps = WeaponManager.getProjectileSpeed();
            const g = ProjectileSystem.createMesh(THREE, direction, spawnPos, speed ?? ps.max, { speedMin: ps.min, speedMax: ps.max, fallbackCamera: camera });
            scene.add(g); projectiles.push(g);
            return g;
        }

        function spawnParticles(pos, color, count) { ParticleSystem.spawn(THREE, pos, color, count, particles, scene); }

        const addScore = (pts, pos) => GameSession.addScore(pts, pos);
        const startCharging = () => StateSystem.is('PLAYING') && WeaponManager.onFireStart(Date.now());
        const updateCharging = (dt) => { const r = WeaponManager.update(dt, Date.now()); if (r) shoot(r.speed, r); };
        const cancelCharging = () => WeaponManager.cancelAction();
        const releaseAndFire = () => { const r = WeaponManager.onFireRelease(Date.now()); if (r) shoot(r.speed, r); };

        function shoot(speed, fireResult = null) {
            lastShootTime = Date.now();
            if (cameraMode === 'hybrid-fps') WeaponManager.triggerFireAnim();

            const { spawnPos, direction } = ProjectileSystem.calculateFire(THREE, camera, crosshairX, crosshairY);
            if (fireResult?.spread) { direction.x += fireResult.spread.x; direction.y += fireResult.spread.y; direction.normalize(); }
            createProjectile(direction, spawnPos, speed, fireResult);
            updateAmmoDisplay();
        }

        function updateAmmoDisplay() {
            const reloading = WeaponManager.isReloading(Date.now());
            ammoDisplay.textContent = reloading ? 'RELOADING...' : (WeaponManager.getAmmoDisplay() || 'READY');
            ammoDisplay.style.borderColor = reloading ? '#e94560' : '#3498db';
        }

        function resetGame() {
            lastShootTime = 0; isFrozen = false;
            GameSession.reset(); GameSession.setCamera(camera);
            InputSystem.reset(); PlayerSystem.reset();
            WeaponManager.reset(); WeaponManager.equip('slingshot', THREE, MaterialsTheme, camera);
            PickupSystem.reset();
            crosshairX = window.innerWidth / 2; crosshairY = window.innerHeight / 2;
            lockedTarget = null; currentRoom = null; visitedRooms.clear();
            scoreElement.textContent = '0'; updateTimerDisplay(); UISystem.resetHealthBar(PLAYER_MAX_HEALTH);
            [projectiles, enemies, obstacles, particles].forEach(arr => arr.forEach(o => scene.remove(o)));
            projectiles = []; enemies = []; obstacles = []; particles = [];
            playerCart.position.set(PlayerSystem.position.x, 0, PlayerSystem.position.z);
            playerCart.rotation.set(0, PlayerSystem.rotation, 0);
            camera.position.set(PlayerSystem.position.x, 2.2, PlayerSystem.position.z);
            camera.rotation.set(-0.12, PlayerSystem.rotation, 0);
        }

        const updateCursor = () => UISystem.updateCursor(StateSystem.is('PLAYING'), renderer.domElement);

        function startGame() {
            resetGame(); GameSession.start(); StateSystem.forceTransition('PLAYING'); UISystem.showGameplay();
            crosshairX = window.innerWidth / 2; crosshairY = window.innerHeight / 2;
            updateCursor(); spawnInitialObjects();
        }

        function endGame(died = false) {
            StateSystem.forceTransition('GAME_OVER');
            const s = GameSession.getScore();
            UISystem.showGameOver(s, UI.getScoreRating(s), died); updateCursor();
        }

        function damagePlayer(amount) {
            if (!StateSystem.is('PLAYING') || !PlayerSystem.damage(amount)) return;
            UISystem.updateHealthBar(PlayerSystem.getHealth(), PLAYER_MAX_HEALTH);
            UISystem.showDamageOverlay();
            damageVignetteStrength = Math.min(1.0, damageVignetteStrength + amount / 50);
            if (PlayerSystem.isDead()) endGame(true);
        }

        function pauseGame() {
            if (!StateSystem.is('PLAYING')) return;
            StateSystem.forceTransition('PAUSED'); cancelCharging();
            UISystem.showPause(GameSession.getScore()); updateCursor();
        }

        function resumeGame() {
            if (!StateSystem.is('PAUSED')) return;
            StateSystem.forceTransition('PLAYING'); UISystem.hidePause();
            LoopSystem.resetDelta(); updateCursor();
        }

        function quitToMenu() {
            StateSystem.forceTransition('MENU'); UISystem.showMenu(); resetGame(); updateCursor();
        }

        const togglePause = () => StateSystem.is('PLAYING') ? pauseGame() : StateSystem.is('PAUSED') ? resumeGame() : null;
        const toggleFreeze = () => { if (StateSystem.is('PLAYING')) { isFrozen = !isFrozen; if (!isFrozen) LoopSystem.resetDelta(); } };
        const updateTimerDisplay = () => UISystem.updateTimerDisplay(GameSession.getTimer(), GameSession.DURATION);

        // Spawn all room contents at game start (no pop-in)
        function spawnInitialObjects() {
            RoomSystem.getAllRooms().forEach(room => {
                if (room) {
                    const roomKey = `${room.gridX}_${room.gridZ}`;
                    visitedRooms.add(roomKey);
                    spawnRoomContents(room);
                }
            });
        }

        function updateCurrentRoom() {
            const room = mallGrid.getRoomAtWorld(PlayerSystem.position.x, PlayerSystem.position.z);
            if (room && room !== currentRoom) {
                const roomKey = `${room.gridX}_${room.gridZ}`;
                currentRoom = room;
                if (!visitedRooms.has(roomKey)) { visitedRooms.add(roomKey); spawnRoomContents(room); }
            }
        }

        // Spawn enemies and obstacles for a room
        function spawnRoomContents(room) {
            SpawnSystem.spawnRoomContents(room, Room.structure, {
                createEnemy: (x, z) => createEnemyCart(x, z, 'SKELETON'),
                createObstacle: (x, z, type) => createObstacle(x, z, type)
            });
        }

        function updateCooldownIndicator() {
            const elapsed = Date.now() - lastShootTime;
            UISystem.updateCooldownIndicator(elapsed, WeaponManager.getCooldown());
        }

        function update(dt) {
            if (!StateSystem.is('PLAYING') || isFrozen) return;

            // Update invulnerability
            PlayerSystem.updateInvulnerability();

            // Update game timer via GameSession
            if (GameSession.updateTimer(dt)) {
                endGame(false); // Time's up
                return;
            }

            RoomSystem.updateAmbientLighting(ambientLight, PlayerSystem.position, mallGrid, THREE);
            // Player movement with collision against walls, obstacles, and shelves
            PlayerSystem.fullUpdate({
                keys: InputSystem.keys,
                dt,
                collisionCheck: (nX, nZ, oX, oZ) => CollisionSystem.checkAllCollisions(nX, nZ, oX, oZ, {
                    gridSystem: mallGrid,
                    roomConfig: Room.structure,
                    obstacles,
                    shelves,
                    playerRadius: Player.visual.COLLISION_RADIUS
                }),
                onCollision: (pos, dir, intensity) => {
                    // Spawn metal sparks on environment collision
                    const sparkCount = Math.ceil(3 + intensity * 5);
                    // Metal spark colors: bright orange, yellow, white-hot
                    const sparkColors = [0xff6600, 0xff9900, 0xffcc00, 0xffff66, 0xffffff];
                    for (let i = 0; i < sparkCount; i++) {
                        const color = sparkColors[Math.floor(Math.random() * sparkColors.length)];
                        ParticleSystem.spawn(THREE, pos, color, 1, particles, scene, {
                            velocitySpread: 10 + intensity * 8,
                            upwardVelocity: { min: 3, max: 12 },
                            life: 0.2 + Math.random() * 0.3,
                            scale: 0.3 + Math.random() * 0.4  // Small sparks
                        });
                    }
                },
                cart: playerCart,
                camera
            });

            // Push player out of any overlapping objects (run multiple times for nested overlaps)
            for (let i = 0; i < 5; i++) {
                if (!CollisionSystem.pushOutOfOverlaps(PlayerSystem.position, obstacles, shelves, Player.visual.COLLISION_RADIUS)) break;
            }
            // Hard clamp to room bounds (last resort - never go through walls)
            CollisionSystem.clampToRoomBounds(PlayerSystem.position, mallGrid, Room.structure, Player.visual.COLLISION_RADIUS);
            playerCart.position.x = PlayerSystem.position.x;
            playerCart.position.z = PlayerSystem.position.z;

            // FPS mode
            playerCart.visible = true;
            if (playerChild) playerChild.visible = false;
            if (slingshotArm) slingshotArm.visible = false;
            if (WeaponManager.fpsMesh) { WeaponManager.showFPSWeapon(); WeaponManager.updateTransform(PlayerSystem.currentTurnRate); }
            updateCharging(dt); WeaponManager.animateFPS(dt); updateAmmoDisplay(); updateCurrentRoom();

            // Auto-aim
            const aim = WeaponManager.updateAim({ camera, playerPosition: PlayerSystem.position, enemies, obstacles, shelves, collisionSystem: CollisionSystem, gridSystem: mallGrid, roomConfig: Room.structure, playerRadius: Player.visual.COLLISION_RADIUS, boundsMargin: CROSSHAIR_BOUNDS_MARGIN });
            crosshairX = aim.crosshairX; crosshairY = aim.crosshairY; lockedTarget = WeaponManager.getLockedTarget();

            // Pickups
            PickupSystem.update(dt, { x: PlayerSystem.position.x, y: 0, z: PlayerSystem.position.z }, Date.now()).forEach(p => {
                const r = PickupSystem.collect(p, WeaponManager, THREE, MaterialsTheme, camera);
                if (r?.switched) UISystem.showPickupNotification?.(p.config.name);
                else if (r?.ammoAdded > 0) UISystem.showPickupNotification?.(`+${r.ammoAdded} Ammo`);
            });
            PickupSystem.cleanupBehind(PlayerSystem.position.z);

            // UI updates
            UISystem.updateCrosshairUI(crosshairX, crosshairY, aim.hasTarget);
            UISystem.updateTensionUI(crosshairX, crosshairY, WeaponManager.isCharging(), WeaponManager.getTension(), WeaponManager.getMaxTension());

            // Entity updates
            ProjectileSystem.updateMeshArray(projectiles, { dt, cameraPosition: camera.position });
            EnemySystem.updateAll(enemies, {
                playerPosition: PlayerSystem.position,
                playerCart,
                dt,
                baseSpeed: CART_SPEED,
                isInvulnerable: PlayerSystem.getIsInvulnerable(),
                onPlayerCollision: () => damagePlayer(Player.health.ENEMY_DAMAGE),
                collisionCheck: (nX, nZ, oX, oZ) => CollisionSystem.checkAllCollisions(nX, nZ, oX, oZ, { gridSystem: mallGrid, roomConfig: Room.structure, obstacles, shelves, playerRadius: 1.5 }),
                hasLineOfSight: (fX, fZ, tX, tZ) => CollisionSystem.hasLineOfSight(fX, fZ, tX, tZ, mallGrid, Room.structure),
                clampToRoomBounds: (pos) => CollisionSystem.clampToRoomBounds(pos, mallGrid, Room.structure, 1.5),
                obstacles,
                shelves
            });
            // Update obstacles (no damage - player collides via movement check above)
            EnvironmentSystem.updateObstaclesArray(obstacles, { playerCart, dt });
            ParticleSystem.updateAll(particles, dt, { gravity: 15, fadeRate: 2 });

            // Collision detection
            CollisionSystem.processProjectileHits(projectiles, enemies, obstacles, {
                THREE,
                gridSystem: mallGrid,
                roomConfig: Room.structure,
                shelves,
                onEnemyHit: (enemy, damage, closestPoint, result) => {
                    UISystem.showHitMarker();
                    const hb = enemy.userData.healthBar;
                    if (hb && typeof EnemyVisual !== 'undefined') EnemyVisual.updateHealthBar(hb, EnemySystem.getHealthPercent(enemy));
                    const color = (enemy.userData.config || ENEMY_TYPES.CART).visual?.bodyColor || 0xe94560;
                    if (result.destroyed) { addScore(result.scoreDestroy, enemy.position); spawnParticles(enemy.position, color, 15); }
                    else { addScore(result.scoreHit, enemy.position); spawnParticles(closestPoint, 0xf39c12, 3); }
                },
                onObstacleHit: (obs) => { UISystem.showHitMarker(); addScore(150, obs.position); spawnParticles(obs.position, 0xf1c40f, 10); },
                onWallHit: (pos) => { spawnParticles(pos, 0x888888, 5); }
            });

            // Cleanup inactive objects
            const c = EntitySystem.cleanupAllInactive({ projectiles, enemies, obstacles, particles }, scene);
            projectiles = c.projectiles; enemies = c.enemies; obstacles = c.obstacles; particles = c.particles;
            updateCooldownIndicator();
        }

        // Event Listeners
        document.getElementById('start-btn').addEventListener('click', startGame);
        document.getElementById('restart-btn').addEventListener('click', startGame);
        document.getElementById('resume-btn').addEventListener('click', resumeGame);
        document.getElementById('quit-btn').addEventListener('click', quitToMenu);

        // How to Play modal
        const howToPlayModal = document.getElementById('how-to-play-modal');
        const modalCloseBtn = document.getElementById('modal-close');
        const closeModal = (e) => { e.preventDefault(); howToPlayModal.classList.remove('visible'); };
        document.getElementById('how-to-play-btn').addEventListener('click', (e) => { e.preventDefault(); howToPlayModal.classList.add('visible'); });
        modalCloseBtn.addEventListener('click', closeModal);
        modalCloseBtn.addEventListener('touchend', closeModal);
        howToPlayModal.addEventListener('click', (e) => e.target === howToPlayModal && closeModal(e));
        document.addEventListener('keydown', (e) => e.key === 'Escape' && howToPlayModal.classList.contains('visible') && (closeModal(e), e.stopPropagation()), true);

        // Legacy aliases
        const WEAPON_TYPES = Weapon.types, PROJECTILE_TYPES = Projectile.types, ENEMY_TYPES = Enemy.types, AIM_PROFILES = Weapon.aimProfiles;

        // Initialize systems
        initThree();
        StateSystem.init('MENU');
        LoopSystem.init(THREE);
        LoopSystem.setUpdateCallback(update);
        LoopSystem.setRenderCallback((dt) => {
            damageVignetteStrength *= 0.95;
            PostProcessSystem.setDamageIntensity(damageVignetteStrength);
            composer ? composer.render(dt) : renderer.render(scene, camera);
        });
        InputSystem.init();
        EntitySystem.init(scene);
        InputSystem.onActionStart('fire', () => StateSystem.is('PLAYING') && startCharging());
        InputSystem.onActionRelease('fire', () => StateSystem.is('PLAYING') && releaseAndFire());
        InputSystem.onActionStart('pause', togglePause);
        InputSystem.onActionStart('freeze', toggleFreeze);
        EntitySystem.registerType('enemy', { maxCount: 10, despawnDistance: 20 });
        EntitySystem.registerType('obstacle', { maxCount: 15, despawnDistance: 30 });
        EntitySystem.registerType('projectile', { maxCount: 50, despawnDistance: 20 });
        EntitySystem.registerType('particle', { maxCount: 100, despawnDistance: 50 });
        EnemySystem.init(Enemy, scene);
        GameSession.init({ camera });

        // Expose internals for test framework (TestBridge injected only during tests)
        window.__gameInternals = {
            // Game state - delegate to GameSession
            getScore: () => GameSession.getScore(),
            setScore: (v) => GameSession.setScore(v),
            getGameTimer: () => GameSession.getTimer(),
            setGameTimer: (v) => GameSession.setTimer(v),
            // Player state - delegate to PlayerSystem
            getPlayerPosition: () => PlayerSystem.position,
            setPlayerPosition: (v) => { PlayerSystem.position = v; },
            getPlayerRotation: () => PlayerSystem.rotation,
            setPlayerRotation: (v) => { PlayerSystem.rotation = v; },
            getPlayerHealth: () => PlayerSystem.health,
            setPlayerHealth: (v) => { PlayerSystem.health = v; },
            getWallBumpIntensity: () => PlayerSystem.wallBumpIntensity,
            setWallBumpIntensity: (v) => { PlayerSystem.wallBumpIntensity = v; },
            // Weapon state - delegate to WeaponManager
            getSlingshotTension: () => WeaponManager.getTension(),
            setSlingshotTension: (v) => WeaponManager.setTension?.(v),
            getIsChargingSlingshot: () => WeaponManager.isCharging(),
            setIsChargingSlingshot: (v) => v ? WeaponManager.onFireStart(Date.now()) : WeaponManager.cancelAction(),
            getLastShootTime: () => lastShootTime,
            setLastShootTime: (v) => { lastShootTime = v; },
            getCameraMode: () => cameraMode,
            setCameraMode: () => {},  // Read-only in v3
            getFpsWeapon: () => WeaponManager.fpsMesh,
            getProjectiles: () => projectiles,
            getEnemies: () => enemies,
            getObstacles: () => obstacles,
            // Functions
            startGame, pauseGame, resumeGame, endGame, resetGame, damagePlayer,
            startCharging, releaseAndFire, cancelCharging,
            manualUpdate: (dt = 0.016) => update(dt),
            triggerWallBump: (intensity, dirX, dirZ) => {
                PlayerSystem.wallBumpIntensity = intensity;
                PlayerSystem.wallBumpDirection = { x: dirX, z: dirZ };
            },
            // Object references
            scene, camera, renderer, playerCart, playerChild
        };

        updateCursor();

        // Set initial UI state (MENU)
        healthContainer.style.display = 'none';
        hud.style.display = 'none';

        // Start the game loop
        LoopSystem.start();
    </script>
</body>
</html>
