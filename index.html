<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mall Hell v3.0</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0a0f;
            overflow: hidden;
            font-family: 'Arial Black', Arial, sans-serif;
        }
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        canvas { display: block; }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        #crosshair {
            position: absolute;
            width: 40px;
            height: 40px;
            pointer-events: none;
            transform: translate(-50%, -50%);
        }
        #crosshair::before, #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.9);
            box-shadow: 0 0 10px rgba(233, 69, 96, 0.8);
        }
        #crosshair::before {
            top: 50%;
            left: 0;
            right: 0;
            height: 2px;
            transform: translateY(-50%);
        }
        #crosshair::after {
            left: 50%;
            top: 0;
            bottom: 0;
            width: 2px;
            transform: translateX(-50%);
        }
        #crosshair-dot {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 6px;
            height: 6px;
            background: #e94560;
            border-radius: 50%;
            box-shadow: 0 0 10px #e94560;
            transition: all 0.15s ease;
        }

        /* Aim-assist locked on */
        #crosshair.aim-assist-active::before,
        #crosshair.aim-assist-active::after {
            background: rgba(0, 255, 136, 0.95);
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.9);
        }
        #crosshair.aim-assist-active #crosshair-dot {
            background: #00ff88;
            box-shadow: 0 0 15px #00ff88, 0 0 30px #00ff88;
            width: 8px;
            height: 8px;
        }

        /* Tension Indicator */
        #tension-indicator {
            position: absolute;
            width: 80px;
            height: 80px;
            pointer-events: none;
            transform: translate(-50%, -50%);
            opacity: 0;
            transition: opacity 0.15s;
        }
        #tension-indicator.charging {
            opacity: 1;
        }
        #tension-indicator svg {
            width: 100%;
            height: 100%;
            transform: rotate(-90deg);
        }
        #tension-indicator .tension-bg {
            fill: none;
            stroke: rgba(255, 255, 255, 0.15);
            stroke-width: 6;
        }
        #tension-indicator .tension-fill {
            fill: none;
            stroke: #f1c40f;
            stroke-width: 6;
            stroke-linecap: round;
            stroke-dasharray: 283;
            stroke-dashoffset: 283;
            transition: stroke 0.1s, stroke-dashoffset 0.05s;
        }
        #tension-indicator.medium .tension-fill {
            stroke: #e67e22;
        }
        #tension-indicator.high .tension-fill {
            stroke: #e74c3c;
        }
        #tension-indicator.max .tension-fill {
            stroke: #e74c3c;
            filter: drop-shadow(0 0 8px #e74c3c);
        }
        #tension-text {
            position: absolute;
            bottom: -20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 12px;
            color: #fff;
            text-shadow: 0 0 5px #000;
            white-space: nowrap;
        }

        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 20px;
            display: none;
        }

        /* Glass morphism mixin for HUD elements */
        .glass-panel {
            background: rgba(10, 10, 20, 0.6);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3),
                        inset 0 1px 0 rgba(255, 255, 255, 0.05);
        }

        #score-container {
            background: rgba(10, 10, 20, 0.6);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            padding: 15px 25px;
            border-radius: 12px;
            border: 1px solid rgba(233, 69, 96, 0.4);
            border-top: 1px solid rgba(233, 69, 96, 0.6);
            display: inline-block;
            box-shadow: 0 8px 32px rgba(233, 69, 96, 0.15),
                        inset 0 1px 0 rgba(255, 255, 255, 0.05);
            transition: transform 0.1s ease-out, box-shadow 0.1s ease-out;
        }
        #score-container.bump {
            transform: scale(1.05);
            box-shadow: 0 12px 40px rgba(233, 69, 96, 0.3),
                        inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }
        #score-label {
            color: #e94560;
            font-size: 14px;
            letter-spacing: 2px;
            text-shadow: 0 0 10px rgba(233, 69, 96, 0.5);
        }
        #score {
            color: #f1c40f;
            font-size: 36px;
            text-shadow: 0 0 20px rgba(241, 196, 15, 0.6),
                         0 0 40px rgba(241, 196, 15, 0.3);
            transition: transform 0.15s ease-out, text-shadow 0.15s ease-out;
        }
        #score.bump {
            transform: scale(1.1);
            text-shadow: 0 0 30px rgba(241, 196, 15, 0.8),
                         0 0 60px rgba(241, 196, 15, 0.5);
        }

        #timer-container {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            background: rgba(10, 10, 20, 0.6);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            padding: 12px 20px;
            border-radius: 12px;
            border: 1px solid rgba(233, 69, 96, 0.4);
            border-top: 1px solid rgba(233, 69, 96, 0.6);
            box-shadow: 0 8px 32px rgba(233, 69, 96, 0.1),
                        inset 0 1px 0 rgba(255, 255, 255, 0.05);
            text-align: center;
        }
        #timer-label {
            color: #e94560;
            font-size: 12px;
            letter-spacing: 3px;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }
        #timer-display {
            color: #fff;
            font-size: 36px;
            text-shadow: 0 0 20px rgba(233, 69, 96, 0.6);
            margin: 5px 0;
        }
        #timer-bar {
            width: 100%;
            height: 8px;
            background: rgba(26, 26, 46, 0.8);
            border-radius: 4px;
            overflow: hidden;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        #timer-fill {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #e94560 0%, #f39c12 50%, #2ecc71 100%);
            border-radius: 4px;
            transition: width 0.15s ease-out;
        }

        #cooldown-indicator {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            width: 60px;
            height: 60px;
        }
        #cooldown-ring {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            border: 4px solid rgba(255, 255, 255, 0.15);
            position: relative;
            background: rgba(10, 10, 20, 0.4);
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
        }
        #cooldown-fill {
            position: absolute;
            top: -4px;
            left: -4px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: 4px solid transparent;
            border-top-color: #e94560;
            transform: rotate(0deg);
            transition: transform 0.05s linear;
            filter: drop-shadow(0 0 4px rgba(233, 69, 96, 0.5));
        }

        #ammo-display {
            position: absolute;
            bottom: 40px;
            right: 40px;
            color: #fff;
            font-size: 18px;
            background: rgba(10, 10, 20, 0.6);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            padding: 12px 20px;
            border-radius: 10px;
            border: 1px solid rgba(52, 152, 219, 0.4);
            border-top: 1px solid rgba(52, 152, 219, 0.6);
            box-shadow: 0 8px 32px rgba(52, 152, 219, 0.1),
                        inset 0 1px 0 rgba(255, 255, 255, 0.05);
            transition: border-color 0.2s, box-shadow 0.2s;
        }
        #ammo-display.ready {
            border-color: rgba(46, 204, 113, 0.5);
            box-shadow: 0 8px 32px rgba(46, 204, 113, 0.15),
                        inset 0 1px 0 rgba(255, 255, 255, 0.05);
        }

        /* ============================================
           MALL HELL - RETAIL APOCALYPSE MENU THEME
           ============================================ */

        /* Theme Colors */
        :root {
            --mall-magenta: #FF1744;
            --mall-yellow: #FFEA00;
            --mall-cyan: #00E5FF;
            --mall-dark: #0a0a12;
            --mall-purple: #7B1FA2;
        }

        /* Google Font Import - Distinctive display font */
        @import url('https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Oswald:wght@400;700&family=Share+Tech+Mono&display=swap');

        #menu-screen, #gameover-screen, #pause-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            background: var(--mall-dark);
            overflow: hidden;
        }

        /* Tiled floor pattern background */
        #menu-screen::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background:
                linear-gradient(90deg, rgba(255,255,255,0.02) 1px, transparent 1px),
                linear-gradient(rgba(255,255,255,0.02) 1px, transparent 1px);
            background-size: 60px 60px;
            transform: perspective(500px) rotateX(60deg);
            transform-origin: center top;
            pointer-events: none;
        }

        /* Neon glow overlay */
        #menu-screen::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background:
                radial-gradient(ellipse at 30% 20%, rgba(255, 23, 68, 0.15) 0%, transparent 50%),
                radial-gradient(ellipse at 70% 80%, rgba(0, 229, 255, 0.1) 0%, transparent 50%),
                radial-gradient(ellipse at 50% 50%, rgba(123, 31, 162, 0.08) 0%, transparent 60%);
            pointer-events: none;
            animation: neonPulse 4s ease-in-out infinite alternate;
        }

        @keyframes neonPulse {
            0% { opacity: 0.6; }
            100% { opacity: 1; }
        }

        /* Floating sale tags decoration */
        .menu-decor {
            position: absolute;
            pointer-events: none;
            z-index: 0;
        }
        .sale-tag {
            position: absolute;
            background: var(--mall-yellow);
            color: var(--mall-dark);
            font-family: 'Bebas Neue', sans-serif;
            font-size: 14px;
            padding: 4px 12px;
            transform: rotate(-12deg);
            box-shadow: 2px 2px 8px rgba(0,0,0,0.4);
            opacity: 0.6;
        }
        .sale-tag::before {
            content: '';
            position: absolute;
            top: -6px;
            left: 50%;
            width: 8px;
            height: 8px;
            background: var(--mall-dark);
            border-radius: 50%;
            transform: translateX(-50%);
        }

        #gameover-screen, #pause-screen { display: none; }

        .menu-container {
            position: relative;
            z-index: 1;
            text-align: center;
            padding: 40px;
        }

        /* ===== TITLE TREATMENT - "Crashed Sale Sign" ===== */
        .title-wrapper {
            position: relative;
            margin-bottom: 15px;
        }

        .title {
            font-family: 'Bebas Neue', Impact, sans-serif;
            font-size: clamp(72px, 15vw, 140px);
            color: var(--mall-yellow);
            text-transform: uppercase;
            letter-spacing: 8px;
            line-height: 0.85;
            position: relative;
            text-shadow:
                4px 4px 0 var(--mall-magenta),
                8px 8px 0 rgba(0,0,0,0.3),
                0 0 60px rgba(255, 234, 0, 0.5),
                0 0 120px rgba(255, 234, 0, 0.3);
            animation: titleSlam 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55) both,
                       titleGlow 2s ease-in-out infinite alternate 0.6s;
            transform-origin: center bottom;
        }

        @keyframes titleSlam {
            0% {
                opacity: 0;
                transform: translateY(-100px) scale(1.5) rotate(-5deg);
            }
            60% {
                transform: translateY(10px) scale(0.95) rotate(1deg);
            }
            100% {
                opacity: 1;
                transform: translateY(0) scale(1) rotate(0deg);
            }
        }

        @keyframes titleGlow {
            0% {
                text-shadow:
                    4px 4px 0 var(--mall-magenta),
                    8px 8px 0 rgba(0,0,0,0.3),
                    0 0 60px rgba(255, 234, 0, 0.5),
                    0 0 120px rgba(255, 234, 0, 0.3);
                filter: brightness(1);
            }
            100% {
                text-shadow:
                    4px 4px 0 var(--mall-magenta),
                    8px 8px 0 rgba(0,0,0,0.3),
                    0 0 80px rgba(255, 234, 0, 0.7),
                    0 0 160px rgba(255, 234, 0, 0.5);
                filter: brightness(1.1);
            }
        }

        /* Decorative strike-through on title */
        .title::after {
            content: '';
            position: absolute;
            left: -10%;
            top: 50%;
            width: 120%;
            height: 4px;
            background: var(--mall-magenta);
            transform: rotate(-3deg);
            box-shadow: 0 0 20px var(--mall-magenta);
            animation: strikeSlide 0.4s ease-out 0.5s both;
        }

        @keyframes strikeSlide {
            from { transform: scaleX(0) rotate(-3deg); }
            to { transform: scaleX(1) rotate(-3deg); }
        }

        /* Version badge - Price tag style */
        .version {
            display: inline-block;
            font-family: 'Share Tech Mono', monospace;
            font-size: 14px;
            color: var(--mall-dark);
            background: var(--mall-cyan);
            padding: 6px 20px;
            margin-bottom: 20px;
            position: relative;
            clip-path: polygon(10px 0, 100% 0, calc(100% - 10px) 100%, 0 100%);
            animation: tagDrop 0.4s ease-out 0.3s both;
            box-shadow: 0 4px 15px rgba(0, 229, 255, 0.4);
        }

        @keyframes tagDrop {
            from {
                opacity: 0;
                transform: translateY(-20px) rotate(10deg);
            }
            to {
                opacity: 1;
                transform: translateY(0) rotate(0deg);
            }
        }

        /* Subtitle - Receipt style */
        .subtitle {
            font-family: 'Share Tech Mono', monospace;
            font-size: 16px;
            color: rgba(255,255,255,0.7);
            letter-spacing: 4px;
            text-transform: uppercase;
            margin-bottom: 35px;
            position: relative;
            animation: typeIn 0.8s steps(25) 0.6s both;
            overflow: hidden;
            white-space: nowrap;
        }

        .subtitle::after {
            content: 'â–ˆ';
            animation: blink 0.8s infinite;
            margin-left: 4px;
            color: var(--mall-cyan);
        }

        @keyframes typeIn {
            from { width: 0; }
            to { width: 100%; }
        }

        @keyframes blink {
            50% { opacity: 0; }
        }

        /* ===== CONTROLS DISPLAY - Price Tag Cards ===== */
        .instructions {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 12px;
            margin-bottom: 30px;
            animation: fadeInUp 0.5s ease-out 0.7s both;
        }

        .control-item {
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.1);
            padding: 10px 16px;
            border-radius: 4px;
            transition: all 0.3s ease;
        }

        .control-item:hover {
            background: rgba(255,255,255,0.06);
            border-color: rgba(255, 234, 0, 0.3);
            transform: translateY(-2px);
        }

        .control-key {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 20px;
            color: var(--mall-dark);
            background: var(--mall-yellow);
            padding: 4px 12px;
            min-width: 32px;
            text-align: center;
            box-shadow:
                0 3px 0 #c4b200,
                0 4px 8px rgba(0,0,0,0.3);
            border-radius: 4px;
            transition: all 0.15s ease;
        }

        .control-item:hover .control-key {
            transform: translateY(2px);
            box-shadow:
                0 1px 0 #c4b200,
                0 2px 4px rgba(0,0,0,0.3);
        }

        .control-action {
            font-family: 'Oswald', sans-serif;
            font-size: 13px;
            color: rgba(255,255,255,0.6);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* How to play link */
        .how-to-play-btn {
            font-family: 'Share Tech Mono', monospace;
            color: var(--mall-cyan);
            font-size: 13px;
            cursor: pointer;
            text-decoration: none;
            letter-spacing: 2px;
            margin-bottom: 25px;
            display: inline-block;
            padding: 8px 16px;
            border: 1px solid transparent;
            transition: all 0.3s ease;
            animation: fadeInUp 0.5s ease-out 0.8s both;
            position: relative;
            z-index: 10;
        }

        .how-to-play-btn:hover {
            color: #fff;
            border-color: var(--mall-cyan);
            background: rgba(0, 229, 255, 0.1);
            text-shadow: 0 0 20px var(--mall-cyan);
            transform: scale(1.05);
        }

        .how-to-play-btn:active {
            transform: scale(0.95);
            background: rgba(0, 229, 255, 0.2);
        }

        /* ===== MAIN ACTION BUTTON - Shopping Cart Style ===== */
        .btn {
            font-family: 'Bebas Neue', Impact, sans-serif;
            font-size: 28px;
            letter-spacing: 6px;
            color: var(--mall-dark);
            background: linear-gradient(180deg, var(--mall-yellow) 0%, #e6d200 100%);
            border: none;
            padding: 18px 60px;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow:
                0 6px 0 #b8a600,
                0 8px 20px rgba(0,0,0,0.4),
                inset 0 2px 0 rgba(255,255,255,0.3);
            animation: buttonEntry 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275) 0.9s both;
            clip-path: polygon(
                0 10px, 10px 0, calc(100% - 10px) 0, 100% 10px,
                100% calc(100% - 10px), calc(100% - 10px) 100%, 10px 100%, 0 calc(100% - 10px)
            );
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 60%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
            transform: skewX(-20deg);
            transition: left 0.6s ease;
        }

        .btn::after {
            content: 'ðŸ›’';
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 24px;
            opacity: 0.8;
            transition: all 0.3s ease;
        }

        .btn:hover {
            transform: translateY(-4px);
            box-shadow:
                0 10px 0 #b8a600,
                0 15px 30px rgba(0,0,0,0.5),
                0 0 40px rgba(255, 234, 0, 0.3),
                inset 0 2px 0 rgba(255,255,255,0.3);
        }

        .btn:hover::before {
            left: 120%;
        }

        .btn:hover::after {
            transform: translateY(-50%) translateX(5px) rotate(10deg);
        }

        .btn:active {
            transform: translateY(2px);
            box-shadow:
                0 2px 0 #b8a600,
                0 4px 10px rgba(0,0,0,0.4),
                inset 0 2px 0 rgba(255,255,255,0.3);
        }

        @keyframes buttonEntry {
            0% {
                opacity: 0;
                transform: translateY(40px) scale(0.8);
            }
            60% {
                transform: translateY(-5px) scale(1.02);
            }
            100% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        /* Button idle animation */
        .btn {
            animation: buttonEntry 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275) 0.9s both,
                       buttonPulse 2s ease-in-out infinite 1.5s;
        }

        @keyframes buttonPulse {
            0%, 100% { box-shadow: 0 6px 0 #b8a600, 0 8px 20px rgba(0,0,0,0.4), inset 0 2px 0 rgba(255,255,255,0.3); }
            50% { box-shadow: 0 6px 0 #b8a600, 0 8px 30px rgba(255, 234, 0, 0.3), 0 0 40px rgba(255, 234, 0, 0.2), inset 0 2px 0 rgba(255,255,255,0.3); }
        }

        /* ===== HOW TO PLAY MODAL ===== */
        #how-to-play-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 2000;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(10px);
            pointer-events: auto;
        }
        #how-to-play-modal.visible {
            display: flex;
        }
        .modal-content {
            pointer-events: auto;
            background: linear-gradient(180deg, #1a1a2e 0%, #0d0d1a 100%);
            padding: 40px 50px;
            border-radius: 4px;
            max-width: 500px;
            border: 2px solid var(--mall-magenta);
            text-align: left;
            position: relative;
            box-shadow:
                0 0 60px rgba(255, 23, 68, 0.3),
                inset 0 1px 0 rgba(255,255,255,0.1);
        }
        .modal-content::before {
            content: 'HELP';
            position: absolute;
            top: -12px;
            left: 30px;
            background: var(--mall-magenta);
            color: white;
            font-family: 'Bebas Neue', sans-serif;
            font-size: 14px;
            padding: 4px 16px;
            letter-spacing: 3px;
            pointer-events: none;
        }
        .modal-content h2 {
            font-family: 'Bebas Neue', sans-serif;
            color: var(--mall-yellow);
            font-size: 32px;
            letter-spacing: 4px;
            margin-bottom: 25px;
            text-align: center;
        }
        .modal-content h3 {
            font-family: 'Oswald', sans-serif;
            color: var(--mall-cyan);
            margin: 25px 0 12px 0;
            font-size: 15px;
            letter-spacing: 2px;
            text-transform: uppercase;
        }
        .modal-content p {
            font-family: 'Share Tech Mono', monospace;
            color: rgba(255,255,255,0.7);
            line-height: 1.8;
            margin: 8px 0;
            font-size: 14px;
        }
        .modal-content .key {
            font-family: 'Bebas Neue', sans-serif;
            color: var(--mall-dark);
            background: var(--mall-yellow);
            padding: 2px 10px;
            border-radius: 3px;
            font-size: 14px;
            margin-right: 8px;
        }
        .modal-close {
            display: block;
            margin: 35px auto 0;
            padding: 12px 40px;
            background: var(--mall-magenta);
            color: white;
            border: none;
            cursor: pointer;
            font-family: 'Bebas Neue', sans-serif;
            font-size: 18px;
            letter-spacing: 3px;
            transition: all 0.3s ease;
            position: relative;
            z-index: 10;
        }
        .modal-close:hover {
            background: #ff4569;
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(255, 23, 68, 0.5);
        }
        .modal-close:active {
            transform: scale(0.95);
            background: #cc1144;
        }

        /* ===== GAME OVER SCREEN ===== */
        #final-score-container {
            margin: 30px 0;
            text-align: center;
            animation: fadeInUp 0.6s ease-out 0.1s both;
        }
        #final-score-label {
            font-family: 'Oswald', sans-serif;
            color: var(--mall-cyan);
            font-size: 20px;
            letter-spacing: 6px;
            text-transform: uppercase;
            margin-bottom: 10px;
        }
        #final-score {
            font-family: 'Bebas Neue', sans-serif;
            color: var(--mall-yellow);
            font-size: clamp(72px, 20vw, 120px);
            text-shadow:
                4px 4px 0 var(--mall-magenta),
                0 0 60px rgba(255, 234, 0, 0.5);
            animation: scoreReveal 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275) both;
        }

        @keyframes scoreReveal {
            0% {
                opacity: 0;
                transform: scale(0.5) rotate(-10deg);
            }
            60% {
                transform: scale(1.1) rotate(2deg);
            }
            100% {
                opacity: 1;
                transform: scale(1) rotate(0deg);
            }
        }

        #rating {
            font-family: 'Bebas Neue', sans-serif;
            color: var(--mall-magenta);
            font-size: 28px;
            letter-spacing: 4px;
            margin-top: 10px;
            text-shadow: 0 0 30px rgba(255, 23, 68, 0.5);
            animation: fadeInUp 0.6s ease-out 0.4s both;
        }

        /* ===== PAUSE SCREEN ===== */
        .pause-score {
            font-family: 'Share Tech Mono', monospace;
            color: rgba(255,255,255,0.6);
            font-size: 16px;
            letter-spacing: 2px;
            margin: 20px 0 30px;
        }
        .pause-score span {
            color: var(--mall-yellow);
            font-size: 24px;
        }
        .pause-buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .pause-btn {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 20px;
            letter-spacing: 4px;
            padding: 14px 50px;
            border: 2px solid rgba(255,255,255,0.2);
            background: rgba(255,255,255,0.05);
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            clip-path: polygon(8px 0, 100% 0, calc(100% - 8px) 100%, 0 100%);
        }
        .pause-btn:hover {
            background: rgba(255,255,255,0.1);
            border-color: var(--mall-cyan);
            color: var(--mall-cyan);
            transform: translateX(5px);
        }
        .pause-btn.primary {
            background: var(--mall-yellow);
            color: var(--mall-dark);
            border: none;
        }
        .pause-btn.primary:hover {
            background: #fff;
            box-shadow: 0 0 30px rgba(255, 234, 0, 0.5);
        }

        #final-score-container {
            margin: 30px 0;
            text-align: center;
            animation: slideInUp 0.6s ease-out 0.1s both;
        }
        #final-score-label {
            color: #f1c40f;
            font-size: 28px;
            letter-spacing: 5px;
            text-shadow: 0 0 20px rgba(241, 196, 15, 0.5);
        }
        #final-score {
            color: #fff;
            font-size: 96px;
            text-shadow: 0 0 40px rgba(255, 255, 255, 0.5),
                         0 0 80px rgba(255, 255, 255, 0.3);
            animation: glowPulse 2s ease-in-out infinite;
        }
        #rating {
            color: #e94560;
            font-size: 32px;
            margin-top: 10px;
            text-shadow: 0 0 20px rgba(233, 69, 96, 0.5);
            animation: slideInUp 0.6s ease-out 0.2s both;
        }

        #hit-marker {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            width: 30px;
            height: 30px;
            pointer-events: none;
            opacity: 0;
            transition: all 0.1s;
        }
        #hit-marker.show {
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
        }
        #hit-marker::before, #hit-marker::after {
            content: '';
            position: absolute;
            background: #f1c40f;
        }
        #hit-marker::before {
            top: 0; bottom: 0; left: 50%;
            width: 3px;
            transform: translateX(-50%) rotate(45deg);
        }
        #hit-marker::after {
            left: 0; right: 0; top: 50%;
            height: 3px;
            transform: translateY(-50%) rotate(45deg);
        }

        .score-popup {
            position: absolute;
            color: #f1c40f;
            font-size: 24px;
            font-weight: bold;
            pointer-events: none;
            text-shadow: 0 0 10px rgba(241, 196, 15, 0.8);
            animation: popupFloat 1s ease-out forwards;
        }
        @keyframes popupFloat {
            0% { opacity: 1; transform: translateY(0) scale(1); }
            100% { opacity: 0; transform: translateY(-50px) scale(1.5); }
        }

        .pause-score {
            color: #f1c40f;
            font-size: 28px;
            margin-bottom: 40px;
        }
        .pause-buttons {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .btn-secondary {
            background: linear-gradient(135deg, #34495e, #2c3e50);
            box-shadow: 0 10px 30px rgba(52, 73, 94, 0.4);
        }
        .btn-secondary:hover {
            box-shadow: 0 15px 40px rgba(52, 73, 94, 0.6);
        }
        .pause-hint {
            color: #666;
            font-size: 14px;
            margin-top: 30px;
            letter-spacing: 2px;
        }

        #pause-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            color: #888;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 15px;
            border-radius: 5px;
            letter-spacing: 1px;
        }

        #health-container {
            position: absolute;
            bottom: 40px;
            left: 40px;
            background: rgba(10, 10, 20, 0.6);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            padding: 12px 20px;
            border-radius: 12px;
            border: 1px solid rgba(231, 76, 60, 0.4);
            border-top: 1px solid rgba(231, 76, 60, 0.6);
            display: none;
            z-index: 100;
            box-shadow: 0 8px 32px rgba(231, 76, 60, 0.15),
                        inset 0 1px 0 rgba(255, 255, 255, 0.05);
            transition: border-color 0.3s, box-shadow 0.3s;
        }
        #health-container.low-health {
            border-color: rgba(231, 76, 60, 0.8);
            box-shadow: 0 8px 32px rgba(231, 76, 60, 0.4),
                        inset 0 1px 0 rgba(255, 255, 255, 0.05);
            animation: healthPulse 0.5s ease-in-out infinite;
        }
        @keyframes healthPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }
        #health-label {
            color: #e74c3c;
            font-size: 12px;
            letter-spacing: 2px;
            margin-bottom: 5px;
            text-shadow: 0 0 10px rgba(231, 76, 60, 0.5);
        }
        #health-bar {
            width: 150px;
            height: 20px;
            background: rgba(26, 26, 46, 0.8);
            border-radius: 10px;
            overflow: hidden;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        #health-fill {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg,
                #e74c3c 0%,
                #e67e22 30%,
                #f1c40f 60%,
                #2ecc71 100%);
            background-size: 200% 100%;
            border-radius: 10px;
            transition: width 0.2s ease-out;
            box-shadow: 0 0 10px rgba(46, 204, 113, 0.3);
        }
        #health-value {
            color: #fff;
            font-size: 14px;
            text-align: center;
            margin-top: 5px;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }

        #controls-hint {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #666;
            font-size: 12px;
            letter-spacing: 1px;
        }

        #damage-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: radial-gradient(ellipse at center, transparent 30%, rgba(231, 76, 60, 0.6) 100%);
            opacity: 0;
            transition: opacity 0.1s;
        }
        #damage-overlay.flash {
            opacity: 1;
        }

        .invulnerable {
            animation: invulnerableFlash 0.2s infinite;
        }
        @keyframes invulnerableFlash {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="ui-layer">
            <div id="crosshair"><div id="crosshair-dot"></div></div>

            <!-- Tension Indicator (ring around crosshair) -->
            <div id="tension-indicator">
                <svg viewBox="0 0 100 100">
                    <circle class="tension-bg" cx="50" cy="50" r="45"/>
                    <circle class="tension-fill" cx="50" cy="50" r="45"/>
                </svg>
                <div id="tension-text"></div>
            </div>

            <div id="hud">
                <div id="score-container">
                    <div id="score-label">CHAOS SCORE</div>
                    <div id="score">0</div>
                </div>

                <div id="timer-container">
                    <div id="timer-label">TIME REMAINING</div>
                    <div id="timer-display">3:00</div>
                    <div id="timer-bar">
                        <div id="timer-fill"></div>
                    </div>
                </div>

                <div id="ammo-display">SLINGSHOT READY</div>

                <div id="pause-indicator">ESC to Pause</div>

                <div id="controls-hint">WASD Drive | SPACE Fire | Auto-Aim</div>
            </div>

            <div id="health-container">
                <div id="health-label">HEALTH</div>
                <div id="health-bar">
                    <div id="health-fill"></div>
                </div>
                <div id="health-value">100</div>
            </div>

            <div id="cooldown-indicator">
                <div id="cooldown-ring">
                    <div id="cooldown-fill"></div>
                </div>
            </div>

            <div id="hit-marker"></div>
            <div id="damage-overlay"></div>

            <div id="menu-screen">
                <div class="menu-container">
                    <div class="title-wrapper">
                        <div class="title">MALL HELL</div>
                    </div>
                    <div class="version">VERSION 3.0</div>
                    <div class="subtitle">SUPERMARKET MAYHEM</div>
                    <div class="instructions" id="instructions">
                        <div class="control-item">
                            <span class="control-key">W</span>
                            <span class="control-action">Drive</span>
                        </div>
                        <div class="control-item">
                            <span class="control-key">S</span>
                            <span class="control-action">Reverse</span>
                        </div>
                        <div class="control-item">
                            <span class="control-key">A</span>
                            <span class="control-action">Turn Left</span>
                        </div>
                        <div class="control-item">
                            <span class="control-key">D</span>
                            <span class="control-action">Turn Right</span>
                        </div>
                        <div class="control-item">
                            <span class="control-key">SPACE</span>
                            <span class="control-action">Charge & Fire</span>
                        </div>
                    </div>
                    <div class="how-to-play-btn" id="how-to-play-btn">[ HOW TO PLAY ]</div>
                    <button class="btn" id="start-btn">START CHAOS</button>
                </div>
            </div>

            <div id="how-to-play-modal">
                <div class="modal-content">
                    <h2>HOW TO PLAY</h2>
                    <h3>YOU ARE A KID IN A SHOPPING CART</h3>
                    <p>Explore the mall and cause as much chaos as possible before time runs out!</p>
                    <h3>CONTROLS</h3>
                    <p><span class="key">W/S</span> Drive forward and reverse</p>
                    <p><span class="key">A/D</span> Turn left and right</p>
                    <p><span class="key">SPACE</span> Hold to charge your slingshot, release to fire</p>
                    <h3>SMART AIMING</h3>
                    <p>Your crosshair automatically tracks the most dangerous target. Focus on timing your shots!</p>
                    <h3>SCORING</h3>
                    <p>Hit enemies: +100 points<br>Destroy enemies: +300 points<br>Hit obstacles: +150 points</p>
                    <h3>TIP</h3>
                    <p>Explore all 16 mall sections to maximize your chaos score!</p>
                    <button class="modal-close" id="modal-close">GOT IT!</button>
                </div>
            </div>

            <div id="gameover-screen">
                <div class="menu-container">
                    <div class="title" id="gameover-title">CHECKOUT!</div>
                    <div id="final-score-container">
                        <div id="final-score-label">TOTAL CHAOS</div>
                        <div id="final-score">0</div>
                        <div id="rating">Mild Mischief</div>
                    </div>
                    <button class="btn" id="restart-btn">PLAY AGAIN</button>
                </div>
            </div>

            <div id="pause-screen">
                <div class="menu-container">
                    <div class="title">PAUSED</div>
                    <div class="pause-score">Current Chaos: <span id="pause-score-value">0</span></div>
                    <div class="pause-buttons">
                        <button class="pause-btn primary" id="resume-btn">RESUME</button>
                        <button class="pause-btn" id="quit-btn">QUIT TO MENU</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game Constants
        const ROOM_UNIT = 30;              // Each room is 30x30 units
        const DOOR_WIDTH = 8;              // Door opening width
        const GAME_DURATION = 180;         // 3 minutes
        const SHOOT_COOLDOWN = 300;        // Reduced cooldown (tension adds delay)
        const ENEMY_HEALTH = 3;

        // Slingshot Tension Constants
        const TENSION_MIN = 0.2;           // Minimum tension (quick tap)
        const TENSION_MAX = 1.0;           // Maximum tension (fully charged)
        const TENSION_CHARGE_RATE = 1.2;   // Tension gained per second
        const PROJECTILE_SPEED_MIN = 60;   // Speed at min tension
        const PROJECTILE_SPEED_MAX = 180;  // Speed at max tension

        // Player Movement Constants - WASD Driving
        const CART_SPEED = 8;              // Forward speed (was 25)
        const CART_TURN_SPEED = 2.5;       // Radians per second
        const CART_REVERSE_SPEED = 4;      // Backward speed
        const CART_ACCELERATION = 15;      // Speed gain per second
        const CART_DECELERATION = 20;      // Speed loss per second (braking)
        const CART_MAX_SPEED = 10;         // Maximum speed
        const CART_FRICTION = 8;           // Natural slowdown when not pressing W/S
        const CART_IDLE_DRIFT = 0.5;       // Small forward drift when idle (cart on slope)

        // Cart Visual Constants
        const CART_LEAN_ANGLE = 0.15;      // Lean when turning
        const CAMERA_ROLL_FACTOR = 0.1;

        // Crosshair Constants
        const CROSSHAIR_BOUNDS_MARGIN = 50;

        // Player Health Constants
        const PLAYER_MAX_HEALTH = 100;
        const ENEMY_COLLISION_DAMAGE = 20;
        const OBSTACLE_COLLISION_DAMAGE = 10;
        const INVULNERABILITY_DURATION = 1000;

        // Mall Theme Definitions (15 unique themes)
        const MALL_THEMES = {
            PRODUCE: {
                name: 'PRODUCE',
                shelfColor: 0x8B4513,
                productColors: [0x228B22, 0xFF6347, 0xFFD700, 0x32CD32, 0xFF8C00, 0x9ACD32],
                floorColor: '#c9b896',
                floorLineColor: '#a89878',
                signText: 'FRESH PRODUCE',
                signColor: 0x228B22,
                ambientColor: 0xfff8e8
            },
            DAIRY: {
                name: 'DAIRY',
                shelfColor: 0xE8E8E8,
                productColors: [0xFFFFFF, 0x87CEEB, 0xADD8E6, 0xF0F8FF, 0xE0FFFF, 0xB0E0E6],
                floorColor: '#d0d8e0',
                floorLineColor: '#a0b0c0',
                signText: 'DAIRY',
                signColor: 0x4169E1,
                ambientColor: 0xe8f0ff
            },
            FROZEN: {
                name: 'FROZEN',
                shelfColor: 0xB0C4DE,
                productColors: [0xE0FFFF, 0xAFEEEE, 0x87CEEB, 0xB0E0E6, 0xADD8E6, 0xF0FFFF],
                floorColor: '#d8e8f0',
                floorLineColor: '#b8d0e0',
                signText: 'FROZEN FOODS',
                signColor: 0x4682B4,
                ambientColor: 0xe0f0ff
            },
            SNACKS: {
                name: 'SNACKS',
                shelfColor: 0xDC143C,
                productColors: [0xFF4500, 0xFFD700, 0xFF69B4, 0x9400D3, 0x00CED1, 0xFF1493],
                floorColor: '#d4c4a8',
                floorLineColor: '#b4a488',
                signText: 'SNACKS & CANDY',
                signColor: 0xFF4500,
                ambientColor: 0xfff5f0
            },
            BEVERAGES: {
                name: 'BEVERAGES',
                shelfColor: 0x2E8B57,
                productColors: [0x8B4513, 0xFFD700, 0x00CED1, 0x32CD32, 0xFF6347, 0x4169E1],
                floorColor: '#c8d8c8',
                floorLineColor: '#a8b8a8',
                signText: 'BEVERAGES',
                signColor: 0x2E8B57,
                ambientColor: 0xf0fff0
            },
            ELECTRONICS: {
                name: 'ELECTRONICS',
                shelfColor: 0x2F4F4F,
                productColors: [0x1C1C1C, 0x4169E1, 0x00CED1, 0x696969, 0x708090, 0x00BFFF],
                floorColor: '#4a4a5a',
                floorLineColor: '#3a3a4a',
                signText: 'ELECTRONICS',
                signColor: 0x00BFFF,
                ambientColor: 0xe0e8ff
            },
            GAMING: {
                name: 'GAMING',
                shelfColor: 0x4B0082,
                productColors: [0xFF00FF, 0x00FF00, 0x00FFFF, 0xFF0000, 0xFFFF00, 0x9400D3],
                floorColor: '#3a2a4a',
                floorLineColor: '#2a1a3a',
                signText: 'GAMING',
                signColor: 0x9400D3,
                ambientColor: 0xe8d8ff
            },
            TOYS: {
                name: 'TOYS',
                shelfColor: 0xFFD700,
                productColors: [0xFF0000, 0x00FF00, 0x0000FF, 0xFF69B4, 0xFFA500, 0x9400D3],
                floorColor: '#f8e8d8',
                floorLineColor: '#e8d8c8',
                signText: 'TOYS & GAMES',
                signColor: 0xFF4500,
                ambientColor: 0xfff8e8
            },
            SPORTS: {
                name: 'SPORTS',
                shelfColor: 0x4169E1,
                productColors: [0xFF4500, 0x228B22, 0x1C1C1C, 0xFFFFFF, 0xFFD700, 0x4169E1],
                floorColor: '#c8d0e0',
                floorLineColor: '#a8b0c0',
                signText: 'SPORTS',
                signColor: 0x4169E1,
                ambientColor: 0xe8f0ff
            },
            CLOTHING: {
                name: 'CLOTHING',
                shelfColor: 0xD2B48C,
                productColors: [0x000080, 0x800000, 0x008000, 0x808080, 0xFFFFFF, 0x1C1C1C],
                floorColor: '#e8e0d8',
                floorLineColor: '#d0c8c0',
                signText: 'CLOTHING',
                signColor: 0x8B4513,
                ambientColor: 0xfff8f0
            },
            PHARMACY: {
                name: 'PHARMACY',
                shelfColor: 0xFFFFFF,
                productColors: [0xFF0000, 0x00FF00, 0x4169E1, 0xFFFFFF, 0x228B22, 0xFF69B4],
                floorColor: '#f0f0f0',
                floorLineColor: '#d0d0d0',
                signText: 'PHARMACY',
                signColor: 0xFF0000,
                ambientColor: 0xffffff
            },
            BAKERY: {
                name: 'BAKERY',
                shelfColor: 0xD2691E,
                productColors: [0xF5DEB3, 0xDEB887, 0xD2691E, 0x8B4513, 0xFFE4C4, 0xFFA07A],
                floorColor: '#e8d8c8',
                floorLineColor: '#d0c0b0',
                signText: 'BAKERY',
                signColor: 0xD2691E,
                ambientColor: 0xfff0e0
            },
            APPLIANCES: {
                name: 'APPLIANCES',
                shelfColor: 0x708090,
                productColors: [0xC0C0C0, 0x1C1C1C, 0xFFFFFF, 0x4169E1, 0x708090, 0x2F4F4F],
                floorColor: '#d0d0d8',
                floorLineColor: '#b0b0b8',
                signText: 'APPLIANCES',
                signColor: 0x4682B4,
                ambientColor: 0xf0f0f8
            },
            JUNCTION: {
                name: 'JUNCTION',
                shelfColor: 0x808080,
                productColors: [],
                floorColor: '#d8d8d8',
                floorLineColor: '#b8b8b8',
                signText: '',
                signColor: 0x808080,
                ambientColor: 0xf8f8f8,
                noShelves: true
            },
            ENTRANCE: {
                name: 'ENTRANCE',
                shelfColor: 0x808080,
                productColors: [],
                floorColor: '#e0e0e0',
                floorLineColor: '#c0c0c0',
                signText: 'WELCOME TO MALL HELL',
                signColor: 0xE94560,
                ambientColor: 0xffffff,
                noShelves: true
            }
        };

        // Mall Grid Layout (16 rooms)
        // Grid coordinates: x = column (0-4), z = row (0-4)
        // Each room is ROOM_UNIT x ROOM_UNIT (30x30)
        // World position: worldX = gridX * ROOM_UNIT, worldZ = gridZ * ROOM_UNIT
        const MALL_GRID = {
            // Row 0 (z=0)
            '0_0': { theme: 'ELECTRONICS', doors: ['south'] },
            '1_0': { theme: 'GAMING', doors: ['south', 'east'] },
            '2_0': { theme: 'TOYS', doors: ['south'] },
            // Row 1 (z=1)
            '0_1': { theme: 'APPLIANCES', doors: ['north', 'south', 'east'] },
            '1_1': { theme: 'JUNCTION', doors: ['north', 'south', 'east', 'west'] },
            '2_1': { theme: 'SPORTS', doors: ['north', 'south', 'west'] },
            // Row 2 (z=2) - Main corridor with ENTRANCE
            '-1_2': { theme: 'BAKERY', doors: ['east'] },
            '0_2': { theme: 'PRODUCE', doors: ['north', 'south', 'east', 'west'] },
            '1_2': { theme: 'ENTRANCE', doors: ['north', 'south', 'east', 'west'] },
            '2_2': { theme: 'DAIRY', doors: ['north', 'south', 'east', 'west'] },
            '3_2': { theme: 'FROZEN', doors: ['west'] },
            // Row 3 (z=3)
            '0_3': { theme: 'SNACKS', doors: ['north', 'south', 'east'] },
            '1_3': { theme: 'JUNCTION', doors: ['north', 'south', 'east', 'west'] },
            '2_3': { theme: 'BEVERAGES', doors: ['north', 'south', 'west'] },
            // Row 4 (z=4)
            '0_4': { theme: 'CLOTHING', doors: ['north', 'east'] },
            '1_4': { theme: 'PHARMACY', doors: ['north', 'west'] },
        };

        // Mall Grid Helper Functions
        const mallGrid = {
            getRoom(gridX, gridZ) {
                const key = `${gridX}_${gridZ}`;
                const roomDef = MALL_GRID[key];
                if (!roomDef) return null;
                return {
                    ...roomDef,
                    gridX,
                    gridZ,
                    worldX: gridX * ROOM_UNIT + ROOM_UNIT / 2,
                    worldZ: gridZ * ROOM_UNIT + ROOM_UNIT / 2,
                    themeData: MALL_THEMES[roomDef.theme]
                };
            },
            getRoomAtWorld(worldX, worldZ) {
                const gridX = Math.floor(worldX / ROOM_UNIT);
                const gridZ = Math.floor(worldZ / ROOM_UNIT);
                return this.getRoom(gridX, gridZ);
            },
            getGridFromWorld(worldX, worldZ) {
                return {
                    x: Math.floor(worldX / ROOM_UNIT),
                    z: Math.floor(worldZ / ROOM_UNIT)
                };
            }
        };

        // Legacy compatibility - get theme at world position
        function getSectionAtZ(z) {
            const room = mallGrid.getRoomAtWorld(playerPosition.x, z);
            return room ? room.themeData : MALL_THEMES.ENTRANCE;
        }

        // Game State
        let gameState = 'MENU';
        let score = 0;
        let gameTimer = GAME_DURATION;    // Countdown timer (replaces distance)
        let lastShootTime = 0;
        let cameraMode = 'hybrid-fps';    // v3.0 is FPS only

        // Three.js Setup
        let scene, camera, renderer;
        let projectiles = [];
        let enemies = [];
        let obstacles = [];
        let particles = [];
        let shelves = [];
        let floorTiles = [];
        let lights = [];
        let ambientLight; // Global reference for section-based color changes
        let currentSection = null; // Track current section for ambient transitions

        // Helper to get theme at a given position (for compatibility)

        // Player
        let playerCart;
        let playerChild; // Child model reference (to hide in FPS)
        let slingshotArm;
        let fpsWeapon; // Slingshot with hands visible in FPS mode
        let fpsHands;  // Hands group for animation
        let fpsBandL, fpsBandR, fpsPouch, fpsStone; // For pull animation
        let fpsFireAnim = 0; // Firing animation progress (0 = ready, >0 = animating)

        // Slingshot Tension State
        let slingshotTension = 0;        // Current tension (0 to TENSION_MAX)
        let isChargingSlingshot = false; // Is player holding to charge

        // Player Position & Movement (grid-based maze)
        // Start at center of ENTRANCE room (grid 1,2): world center = (1*30+15, 2*30+15) = (45, 75)
        let playerPosition = { x: 45, z: 75 };
        let playerRotation = 0;                  // Facing direction (radians, 0 = -Z)
        let playerSpeed = 0;                     // Current forward speed
        let currentTurnRate = 0;                 // Smooth turning
        let playerHealth = PLAYER_MAX_HEALTH;
        let lastDamageTime = 0;
        let isInvulnerable = false;

        // Cart visual state
        let currentLeanAngle = 0;

        // Wall bump effect
        let wallBumpIntensity = 0;       // Current bump animation intensity (0-1)
        let wallBumpDirection = { x: 0, z: 0 }; // Direction of bump pushback

        // Room tracking
        let currentRoom = null;
        let visitedRooms = new Set();

        // Crosshair state
        let crosshairX = window.innerWidth / 2;
        let crosshairY = window.innerHeight / 2;

        // Locked target for sticky aim (don't switch until target gone)
        let lockedTarget = null;

        // Keyboard input - WASD driving
        const keys = {
            forward: false,   // W key - drive forward
            backward: false,  // S key - reverse
            turnLeft: false,  // A key - turn left
            turnRight: false, // D key - turn right
        };

        // Clock
        const clock = new THREE.Clock();

        // === MATERIAL LIBRARY (Shared materials for performance) ===
        const Materials = {
            // Chrome for cart frames - MeshPhysicalMaterial for better reflections
            chrome: null,
            darkChrome: null,
            // Skin tones
            skin: null,
            skinDark: null,
            nail: null,
            // Environment
            wood: null,
            rubber: null,
            // Will be initialized after Three.js loads
        };

        function initMaterialLibrary() {
            Materials.chrome = new THREE.MeshPhysicalMaterial({
                color: 0xc0c0c0,
                metalness: 1.0,
                roughness: 0.15,
                clearcoat: 0.3,
                clearcoatRoughness: 0.2,
                reflectivity: 0.9
            });
            Materials.darkChrome = new THREE.MeshPhysicalMaterial({
                color: 0x606060,
                metalness: 0.9,
                roughness: 0.25,
                clearcoat: 0.2
            });
            Materials.skin = new THREE.MeshStandardMaterial({
                color: 0xf5d0c5,
                roughness: 0.7,
                metalness: 0.0
            });
            Materials.skinDark = new THREE.MeshStandardMaterial({
                color: 0xe8c4b8,
                roughness: 0.8,
                metalness: 0.0
            });
            Materials.nail = new THREE.MeshStandardMaterial({
                color: 0xfce4dc,
                roughness: 0.3,
                metalness: 0.1
            });
            Materials.wood = new THREE.MeshStandardMaterial({
                color: 0x8b4513,
                roughness: 0.7
            });
            Materials.rubber = new THREE.MeshStandardMaterial({
                color: 0xc0392b,
                roughness: 0.5,
                metalness: 0.1
            });
            Materials.redPlastic = new THREE.MeshStandardMaterial({
                color: 0xe74c3c,
                metalness: 0.1,
                roughness: 0.6
            });
            Materials.blackRubber = new THREE.MeshStandardMaterial({
                color: 0x1a1a1a,
                metalness: 0.0,
                roughness: 0.9
            });
            // Product colors for instanced rendering
            Materials.products = [
                new THREE.MeshStandardMaterial({ color: 0xe74c3c }),
                new THREE.MeshStandardMaterial({ color: 0x3498db }),
                new THREE.MeshStandardMaterial({ color: 0x2ecc71 }),
                new THREE.MeshStandardMaterial({ color: 0xf1c40f }),
                new THREE.MeshStandardMaterial({ color: 0x9b59b6 }),
                new THREE.MeshStandardMaterial({ color: 0xe67e22 })
            ];
        }

        // === SCENE HIERARCHY GROUPS ===
        const sceneGroups = {
            environment: null,  // floor, ceiling, walls, shelves
            gameplay: null,     // player, enemies, obstacles
            effects: null,      // particles, projectiles
            lighting: null      // all lights
        };

        function initSceneGroups() {
            sceneGroups.environment = new THREE.Group();
            sceneGroups.environment.name = 'environment';
            sceneGroups.gameplay = new THREE.Group();
            sceneGroups.gameplay.name = 'gameplay';
            sceneGroups.effects = new THREE.Group();
            sceneGroups.effects.name = 'effects';
            sceneGroups.lighting = new THREE.Group();
            sceneGroups.lighting.name = 'lighting';

            scene.add(sceneGroups.environment);
            scene.add(sceneGroups.gameplay);
            scene.add(sceneGroups.effects);
            scene.add(sceneGroups.lighting);
        }

        // === POST-PROCESSING (disabled - using direct rendering) ===
        let composer = null;
        let damageVignetteStrength = 0;

        // DOM Elements
        const container = document.getElementById('game-container');
        const scoreElement = document.getElementById('score');
        const timerDisplay = document.getElementById('timer-display');
        const timerFill = document.getElementById('timer-fill');
        const hud = document.getElementById('hud');
        const menuScreen = document.getElementById('menu-screen');
        const gameoverScreen = document.getElementById('gameover-screen');
        const finalScoreElement = document.getElementById('final-score');
        const ratingElement = document.getElementById('rating');
        const hitMarker = document.getElementById('hit-marker');
        const cooldownFill = document.getElementById('cooldown-fill');
        const ammoDisplay = document.getElementById('ammo-display');
        const pauseScreen = document.getElementById('pause-screen');
        const pauseScoreValue = document.getElementById('pause-score-value');
        const healthFill = document.getElementById('health-fill');
        const healthValue = document.getElementById('health-value');
        const healthContainer = document.getElementById('health-container');
        const damageOverlay = document.getElementById('damage-overlay');
        const gameoverTitle = document.getElementById('gameover-title');

        // Initialize Three.js
        function initThree() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);
            scene.fog = new THREE.Fog(0x1a1a2e, 50, 200);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 3, 0);
            camera.rotation.order = 'YXZ';
            scene.add(camera); // Required for camera children (FPS weapon) to render

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.insertBefore(renderer.domElement, container.firstChild);

            // Initialize material library
            initMaterialLibrary();

            // Initialize scene hierarchy groups
            initSceneGroups();

            // Lighting - stronger ambient to compensate for removed point lights
            ambientLight = new THREE.AmbientLight(0xfff8f0, 0.6);
            scene.add(ambientLight);

            // Main directional light
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(10, 20, 10);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            dirLight.shadow.camera.near = 0.5;
            dirLight.shadow.camera.far = 100;
            dirLight.shadow.camera.left = -30;
            dirLight.shadow.camera.right = 30;
            dirLight.shadow.camera.top = 30;
            dirLight.shadow.camera.bottom = -30;
            scene.add(dirLight);

            // Post-processing disabled (direct rendering used instead)

            // Create supermarket environment
            createEnvironment();
            createPlayerCart();
            createFPSWeapon();

            window.addEventListener('resize', onWindowResize);

            // Expose for testing
            window.scene = scene;
            window.camera = camera;
            window.renderer = renderer;
        }

        // === POST-PROCESSING SETUP ===
        function initPostProcessing() {
            // EffectComposer - inline implementation for r128 compatibility
            // Based on Three.js examples/jsm/postprocessing

            // RenderPass - renders scene to texture
            class RenderPass {
                constructor(scene, camera) {
                    this.scene = scene;
                    this.camera = camera;
                    this.clear = true;
                    this.clearDepth = false;
                    this.needsSwap = false;
                    this.enabled = true;
                }
                render(renderer, writeBuffer, readBuffer) {
                    renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);
                    if (this.clear) renderer.clear();
                    renderer.render(this.scene, this.camera);
                }
            }

            // ShaderPass - applies a shader to the scene
            class ShaderPass {
                constructor(shader) {
                    this.uniforms = THREE.UniformsUtils.clone(shader.uniforms);
                    this.material = new THREE.ShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: shader.vertexShader,
                        fragmentShader: shader.fragmentShader
                    });
                    this.fsQuad = new FullScreenQuad(this.material);
                    this.enabled = true;
                    this.needsSwap = true;
                    this.clear = false;
                    this.renderToScreen = false;
                }
                render(renderer, writeBuffer, readBuffer) {
                    this.uniforms.tDiffuse.value = readBuffer.texture;
                    renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);
                    if (this.clear) renderer.clear();
                    this.fsQuad.render(renderer);
                }
            }

            // FullScreenQuad helper
            class FullScreenQuad {
                constructor(material) {
                    const geo = new THREE.PlaneGeometry(2, 2);
                    this.mesh = new THREE.Mesh(geo, material);
                    this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
                    this.scene = new THREE.Scene();
                    this.scene.add(this.mesh);
                }
                render(renderer) {
                    renderer.render(this.scene, this.camera);
                }
                get material() { return this.mesh.material; }
                set material(v) { this.mesh.material = v; }
            }

            // EffectComposer
            class EffectComposer {
                constructor(renderer, renderTarget) {
                    this.renderer = renderer;
                    const size = renderer.getSize(new THREE.Vector2());
                    this.renderTarget1 = renderTarget || new THREE.WebGLRenderTarget(size.x, size.y, {
                        minFilter: THREE.LinearFilter,
                        magFilter: THREE.LinearFilter,
                        format: THREE.RGBAFormat
                    });
                    this.renderTarget2 = this.renderTarget1.clone();
                    this.writeBuffer = this.renderTarget1;
                    this.readBuffer = this.renderTarget2;
                    this.passes = [];
                }
                addPass(pass) {
                    this.passes.push(pass);
                    const size = this.renderer.getSize(new THREE.Vector2());
                    pass.setSize && pass.setSize(size.x, size.y);
                }
                render(deltaTime) {
                    let maskActive = false;
                    for (let i = 0; i < this.passes.length; i++) {
                        const pass = this.passes[i];
                        if (!pass.enabled) continue;
                        pass.renderToScreen = (i === this.passes.length - 1);
                        pass.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime, maskActive);
                        if (pass.needsSwap) {
                            const tmp = this.readBuffer;
                            this.readBuffer = this.writeBuffer;
                            this.writeBuffer = tmp;
                        }
                    }
                }
                setSize(width, height) {
                    this.renderTarget1.setSize(width, height);
                    this.renderTarget2.setSize(width, height);
                    this.passes.forEach(pass => pass.setSize && pass.setSize(width, height));
                }
            }

            // Bloom shader (simplified UnrealBloom)
            const BloomShader = {
                uniforms: {
                    tDiffuse: { value: null },
                    bloomStrength: { value: 0.5 },
                    bloomThreshold: { value: 0.85 }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform sampler2D tDiffuse;
                    uniform float bloomStrength;
                    uniform float bloomThreshold;
                    varying vec2 vUv;

                    void main() {
                        vec4 texel = texture2D(tDiffuse, vUv);
                        float brightness = dot(texel.rgb, vec3(0.2126, 0.7152, 0.0722));
                        vec3 bloom = vec3(0.0);
                        if (brightness > bloomThreshold) {
                            bloom = (texel.rgb - bloomThreshold) * bloomStrength;
                        }
                        // Simple box blur for bloom spread
                        vec2 texelSize = vec2(1.0 / 1920.0, 1.0 / 1080.0);
                        for (int x = -2; x <= 2; x++) {
                            for (int y = -2; y <= 2; y++) {
                                vec4 neighbor = texture2D(tDiffuse, vUv + vec2(float(x), float(y)) * texelSize * 2.0);
                                float nb = dot(neighbor.rgb, vec3(0.2126, 0.7152, 0.0722));
                                if (nb > bloomThreshold) {
                                    bloom += (neighbor.rgb - bloomThreshold) * bloomStrength * 0.04;
                                }
                            }
                        }
                        gl_FragColor = vec4(texel.rgb + bloom, texel.a);
                    }
                `
            };

            // Vignette + Color Grading shader
            const VignetteShader = {
                uniforms: {
                    tDiffuse: { value: null },
                    damageIntensity: { value: 0.0 },
                    saturation: { value: 1.1 },
                    contrast: { value: 1.05 }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform sampler2D tDiffuse;
                    uniform float damageIntensity;
                    uniform float saturation;
                    uniform float contrast;
                    varying vec2 vUv;

                    void main() {
                        vec4 texel = texture2D(tDiffuse, vUv);

                        // Subtle always-on vignette for atmosphere
                        float baseVignette = 1.0 - smoothstep(0.4, 1.0, length(vUv - 0.5) * 1.2);

                        // Damage vignette (red edges)
                        float damageVignette = smoothstep(0.3, 0.9, length(vUv - 0.5) * 1.5);
                        vec3 damageColor = vec3(0.9, 0.1, 0.05);

                        // Apply color grading
                        vec3 color = texel.rgb;

                        // Saturation
                        float gray = dot(color, vec3(0.2126, 0.7152, 0.0722));
                        color = mix(vec3(gray), color, saturation);

                        // Contrast
                        color = (color - 0.5) * contrast + 0.5;

                        // Apply vignettes
                        color *= baseVignette * 0.15 + 0.85;
                        color = mix(color, damageColor, damageVignette * damageIntensity);

                        gl_FragColor = vec4(color, texel.a);
                    }
                `
            };

            // Create composer
            composer = new EffectComposer(renderer);

            // Render pass
            const renderPass = new RenderPass(scene, camera);
            composer.addPass(renderPass);

            // Bloom pass
            bloomPass = new ShaderPass(BloomShader);
            bloomPass.uniforms.bloomStrength.value = 0.4;
            bloomPass.uniforms.bloomThreshold.value = 0.8;
            composer.addPass(bloomPass);

            // Vignette + color grading pass
            vignettePass = new ShaderPass(VignetteShader);
            vignettePass.uniforms.damageIntensity.value = 0.0;
            composer.addPass(vignettePass);

            // Store for resize
            window.composer = composer;
        }

        function createFPSWeapon() {
            // Create hands holding slingshot for FPS view
            // RIGHT hand holds slingshot frame, LEFT hand pulls back pouch
            fpsWeapon = new THREE.Group();
            fpsHands = new THREE.Group();

            // Materials - Clean stylized look
            const skinMat = new THREE.MeshStandardMaterial({
                color: 0xffd4c4,  // Warm peachy skin tone
                roughness: 0.4,   // Smoother, more stylized
                metalness: 0.0
            });
            const woodMat = new THREE.MeshStandardMaterial({
                color: 0x8b4513,
                roughness: 0.7
            });
            const rubberMat = new THREE.MeshStandardMaterial({
                color: 0xc0392b,
                roughness: 0.5,
                metalness: 0.1
            });

            // Helper: Create smooth stylized finger (single capsule shape)
            function createStylizedFinger(length, radius, isThumb = false) {
                const finger = new THREE.Group();

                // Single smooth capsule body
                const cylGeo = new THREE.CylinderGeometry(
                    radius * 0.85,   // Tip radius (tapered)
                    radius,          // Base radius
                    length * 0.85,   // Height
                    12               // Smooth segments
                );
                const cyl = new THREE.Mesh(cylGeo, skinMat);
                cyl.position.y = length * 0.4;
                finger.add(cyl);

                // Rounded tip
                const tipGeo = new THREE.SphereGeometry(radius * 0.85, 12, 8);
                const tip = new THREE.Mesh(tipGeo, skinMat);
                tip.position.y = length * 0.85;
                tip.scale.y = 0.7;
                finger.add(tip);

                // Rounded base
                const baseGeo = new THREE.SphereGeometry(radius, 12, 8);
                const base = new THREE.Mesh(baseGeo, skinMat);
                base.position.y = 0;
                base.scale.y = 0.6;
                finger.add(base);

                finger.castShadow = true;
                return finger;
            }

            // Helper: Create clean stylized hand
            function createHand(isRight) {
                const hand = new THREE.Group();
                const mirror = isRight ? 1 : -1;

                // Palm - smooth rounded rectangle shape
                const palmGeo = new THREE.BoxGeometry(0.065, 0.08, 0.022);
                const palm = new THREE.Mesh(palmGeo, skinMat);
                palm.position.set(0, 0, 0);
                hand.add(palm);

                // Round the palm edges with spheres at corners
                const cornerRadius = 0.012;
                const cornerPositions = [
                    { x: 0.028, y: 0.035 },
                    { x: -0.028, y: 0.035 },
                    { x: 0.028, y: -0.035 },
                    { x: -0.028, y: -0.035 }
                ];
                cornerPositions.forEach(pos => {
                    const corner = new THREE.Mesh(
                        new THREE.SphereGeometry(cornerRadius, 8, 6),
                        skinMat
                    );
                    corner.position.set(pos.x, pos.y, 0);
                    corner.scale.z = 0.9;
                    hand.add(corner);
                });

                // Simplified wrist
                const wristGeo = new THREE.CylinderGeometry(0.025, 0.028, 0.04, 12);
                const wrist = new THREE.Mesh(wristGeo, skinMat);
                wrist.position.set(0, -0.055, 0);
                hand.add(wrist);

                // Fingers - cleaner proportions (index, middle, ring, pinky)
                const fingerLengths = [0.055, 0.065, 0.06, 0.045];
                const fingerRadii = [0.008, 0.009, 0.008, 0.007];
                const fingerSpacing = [0.022, 0.008, -0.006, -0.020];

                hand.userData.fingers = [];
                for (let i = 0; i < 4; i++) {
                    const finger = createStylizedFinger(fingerLengths[i], fingerRadii[i]);
                    finger.position.set(mirror * fingerSpacing[i], 0.04, 0.003);
                    hand.add(finger);
                    hand.userData.fingers.push(finger);
                }

                // Thumb - shorter and rounder
                const thumb = createStylizedFinger(0.04, 0.01, true);
                thumb.position.set(mirror * 0.035, -0.01, 0.012);
                thumb.rotation.set(0.3, mirror * 0.7, mirror * 0.4);
                hand.add(thumb);
                hand.userData.thumb = thumb;

                return hand;
            }

            // === RIGHT HAND (holding slingshot frame) ===
            const rightHand = createHand(true);

            // Curl fingers around slingshot handle (grip pose)
            rightHand.userData.fingers.forEach((finger, i) => {
                finger.rotation.x = 1.2 + i * 0.1;  // Curl inward
                finger.rotation.z = -0.1 * (i - 1.5); // Slight spread
            });
            rightHand.userData.thumb.rotation.set(0.2, 0.5, 0.8);  // Thumb wraps around

            rightHand.position.set(0.12, -0.15, -0.35);
            rightHand.rotation.set(-0.3, -0.4, 0.2);  // Angled to hold handle
            fpsHands.add(rightHand);
            fpsHands.userData.rightHand = rightHand;

            // === LEFT HAND (pulling back pouch - pinch grip) ===
            const leftHand = createHand(false);

            // Pinch pose for holding pouch: index and thumb pinch, others curled
            leftHand.userData.fingers[0].rotation.x = 0.8;   // Index - extended for pinch
            leftHand.userData.fingers[0].rotation.z = 0.2;   // Slightly inward
            leftHand.userData.fingers[1].rotation.x = 1.5;   // Middle - curled
            leftHand.userData.fingers[2].rotation.x = 1.6;   // Ring - curled
            leftHand.userData.fingers[3].rotation.x = 1.7;   // Pinky - curled tight
            leftHand.userData.thumb.rotation.set(0.4, -0.9, -0.3);  // Thumb meets index

            leftHand.position.set(-0.05, -0.08, -0.15);  // Will be animated when pulling
            leftHand.rotation.set(0.2, 0.5, -0.3);
            fpsHands.add(leftHand);
            fpsHands.userData.leftHand = leftHand;  // Store for animation

            // === FOREARMS / SLEEVES (connect hands to body) ===
            const sleeveMat = new THREE.MeshStandardMaterial({
                color: 0x2980b9,  // Blue sleeve (kid's shirt)
                roughness: 0.9,
                metalness: 0.0
            });

            // Right forearm - connects right hand to lower right of screen
            const rightArmGeo = new THREE.CylinderGeometry(0.035, 0.045, 0.35, 8);
            const rightArm = new THREE.Mesh(rightArmGeo, sleeveMat);
            rightArm.position.set(0.18, -0.35, -0.2);
            rightArm.rotation.set(-0.8, 0.3, 0.4);
            fpsHands.add(rightArm);

            // Right wrist (skin connection between sleeve and hand)
            const rightWrist = new THREE.Mesh(
                new THREE.CylinderGeometry(0.028, 0.032, 0.06, 8),
                skinMat
            );
            rightWrist.position.set(0.13, -0.22, -0.3);
            rightWrist.rotation.set(-0.4, 0, 0.2);
            fpsHands.add(rightWrist);

            // Left forearm - connects left hand to lower left of screen
            const leftArmGeo = new THREE.CylinderGeometry(0.035, 0.045, 0.35, 8);
            const leftArm = new THREE.Mesh(leftArmGeo, sleeveMat);
            leftArm.position.set(-0.12, -0.32, -0.05);
            leftArm.rotation.set(-0.5, -0.4, -0.3);
            fpsHands.add(leftArm);
            fpsHands.userData.leftArm = leftArm; // Store for animation

            // Left wrist
            const leftWrist = new THREE.Mesh(
                new THREE.CylinderGeometry(0.028, 0.032, 0.06, 8),
                skinMat
            );
            leftWrist.position.set(-0.06, -0.15, -0.12);
            leftWrist.rotation.set(0.1, 0, -0.2);
            fpsHands.add(leftWrist);
            fpsHands.userData.leftWrist = leftWrist; // Store for animation

            // === SLINGSHOT (held by right hand) ===
            const slingshot = new THREE.Group();

            // Y-frame handle (held in right hand)
            const handleGeo = new THREE.CylinderGeometry(0.018, 0.022, 0.2, 12);
            const handle = new THREE.Mesh(handleGeo, woodMat);
            handle.position.set(0, -0.06, 0);
            handle.castShadow = true;
            slingshot.add(handle);

            // Handle grip texture (wrapped cord)
            for (let i = 0; i < 6; i++) {
                const wrapGeo = new THREE.TorusGeometry(0.022, 0.003, 4, 12);
                const wrap = new THREE.Mesh(wrapGeo, new THREE.MeshStandardMaterial({
                    color: 0x4a3520, roughness: 0.9
                }));
                wrap.position.set(0, -0.12 + i * 0.015, 0);
                wrap.rotation.x = Math.PI / 2;
                slingshot.add(wrap);
            }

            // Fork prongs (Y-shape)
            const forkGeo = new THREE.CylinderGeometry(0.012, 0.016, 0.12, 8);
            const forkL = new THREE.Mesh(forkGeo, woodMat);
            forkL.rotation.z = Math.PI / 5;
            forkL.position.set(-0.04, 0.04, 0);
            forkL.castShadow = true;
            slingshot.add(forkL);

            const forkR = new THREE.Mesh(forkGeo, woodMat);
            forkR.rotation.z = -Math.PI / 5;
            forkR.position.set(0.04, 0.04, 0);
            forkR.castShadow = true;
            slingshot.add(forkR);

            // Fork tips (where rubber bands attach)
            const tipGeo = new THREE.SphereGeometry(0.018, 12, 12);
            const tipL = new THREE.Mesh(tipGeo, woodMat);
            tipL.position.set(-0.065, 0.09, 0);
            slingshot.add(tipL);
            slingshot.userData.tipL = tipL;

            const tipR = new THREE.Mesh(tipGeo, woodMat);
            tipR.position.set(0.065, 0.09, 0);
            slingshot.add(tipR);
            slingshot.userData.tipR = tipR;

            // === RUBBER BANDS (dynamic - will stretch to pouch) ===
            // Create band geometry that can be updated
            const bandMat = rubberMat.clone();

            // Left rubber band
            fpsBandL = new THREE.Mesh(
                new THREE.CylinderGeometry(0.005, 0.005, 0.1, 8),
                bandMat
            );
            fpsBandL.position.set(-0.04, 0.05, 0.05);
            slingshot.add(fpsBandL);

            // Right rubber band
            fpsBandR = new THREE.Mesh(
                new THREE.CylinderGeometry(0.005, 0.005, 0.1, 8),
                bandMat
            );
            fpsBandR.position.set(0.04, 0.05, 0.05);
            slingshot.add(fpsBandR);

            // === POUCH (leather pocket that holds stone) ===
            const pouchMat = new THREE.MeshStandardMaterial({
                color: 0x5c4033,
                roughness: 0.95,
                metalness: 0.0
            });
            const pouchGeo = new THREE.SphereGeometry(0.022, 12, 8);
            fpsPouch = new THREE.Mesh(pouchGeo, pouchMat);
            fpsPouch.scale.set(1.4, 0.5, 1.2);
            fpsPouch.position.set(0, 0.02, 0.08);
            slingshot.add(fpsPouch);

            // Pouch edges (makes it look like leather strap)
            const pouchEdge1 = new THREE.Mesh(
                new THREE.BoxGeometry(0.008, 0.003, 0.04),
                pouchMat
            );
            pouchEdge1.position.set(-0.025, 0.02, 0.08);
            slingshot.add(pouchEdge1);

            const pouchEdge2 = new THREE.Mesh(
                new THREE.BoxGeometry(0.008, 0.003, 0.04),
                pouchMat
            );
            pouchEdge2.position.set(0.025, 0.02, 0.08);
            slingshot.add(pouchEdge2);

            // === STONE (ammo in pouch) ===
            const stoneMat = new THREE.MeshStandardMaterial({
                color: 0x707070,
                roughness: 0.8,
                metalness: 0.1
            });
            const stoneGeo = new THREE.SphereGeometry(0.016, 10, 10);
            fpsStone = new THREE.Mesh(stoneGeo, stoneMat);
            fpsStone.position.set(0, 0.025, 0.08);
            // Slightly irregular shape
            fpsStone.scale.set(1.1, 0.9, 1.0);
            slingshot.add(fpsStone);

            // Position slingshot in right hand grip
            slingshot.position.set(0.12, -0.02, -0.32);
            slingshot.rotation.set(0.1, -0.2, 0.1);  // Angled towards screen
            fpsHands.add(slingshot);
            fpsHands.userData.slingshot = slingshot;

            fpsWeapon.add(fpsHands);

            // Position whole weapon view - center-right, clearly visible
            fpsWeapon.position.set(0.15, -0.12, -0.45);
            fpsWeapon.rotation.set(0.05, -0.15, 0);

            // Add to camera so it moves with view
            camera.add(fpsWeapon);
            fpsWeapon.visible = false;
        }

        function createEnvironment() {
            // Create all rooms in the grid
            Object.keys(MALL_GRID).forEach(key => {
                const [gridX, gridZ] = key.split('_').map(Number);
                const room = mallGrid.getRoom(gridX, gridZ);
                if (room) {
                    createRoom(room);
                }
            });
        }

        // Create a single room
        function createRoom(room) {
            const theme = room.themeData;
            const worldX = room.gridX * ROOM_UNIT + ROOM_UNIT / 2;
            const worldZ = room.gridZ * ROOM_UNIT + ROOM_UNIT / 2;

            // Floor
            const floorGeo = new THREE.PlaneGeometry(ROOM_UNIT, ROOM_UNIT);
            const floorMat = new THREE.MeshStandardMaterial({
                color: new THREE.Color(theme.floorColor),
                roughness: 0.8
            });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.rotation.x = -Math.PI / 2;
            floor.position.set(worldX, 0, worldZ);
            floor.receiveShadow = true;
            scene.add(floor);

            // Floor tiles pattern
            const tileCanvas = document.createElement('canvas');
            tileCanvas.width = 512;
            tileCanvas.height = 512;
            const ctx = tileCanvas.getContext('2d');
            ctx.fillStyle = theme.floorColor;
            ctx.fillRect(0, 0, 512, 512);
            ctx.strokeStyle = theme.floorLineColor;
            ctx.lineWidth = 4;
            for (let y = 0; y < 512; y += 64) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(512, y);
                ctx.stroke();
            }
            for (let x = 0; x < 512; x += 64) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, 512);
                ctx.stroke();
            }
            const tileTex = new THREE.CanvasTexture(tileCanvas);
            tileTex.wrapS = THREE.RepeatWrapping;
            tileTex.wrapT = THREE.RepeatWrapping;
            tileTex.repeat.set(4, 4);
            const tileMat = new THREE.MeshStandardMaterial({ map: tileTex, roughness: 0.7 });
            const tiles = new THREE.Mesh(new THREE.PlaneGeometry(ROOM_UNIT - 1, ROOM_UNIT - 1), tileMat);
            tiles.rotation.x = -Math.PI / 2;
            tiles.position.set(worldX, 0.01, worldZ);
            tiles.receiveShadow = true;
            scene.add(tiles);

            // Ceiling
            const ceilingGeo = new THREE.PlaneGeometry(ROOM_UNIT, ROOM_UNIT);
            const ceilingMat = new THREE.MeshStandardMaterial({ color: 0x2c3e50, roughness: 0.9 });
            const ceiling = new THREE.Mesh(ceilingGeo, ceilingMat);
            ceiling.rotation.x = Math.PI / 2;
            ceiling.position.set(worldX, 12, worldZ);
            scene.add(ceiling);

            // Ceiling light
            const light = createCeilingLight();
            light.position.set(worldX, 11.5, worldZ);
            scene.add(light);

            // Walls
            createRoomWalls(room);

            // Section sign
            if (theme.signText) {
                const sign = createAisleSign(theme.signText, theme.signColor, worldZ);
                sign.position.x = worldX;
                sign.position.y = 9;
                scene.add(sign);
            }

            // Shelves (if theme has them)
            if (!theme.noShelves && theme.productColors.length > 0) {
                const doors = room.doors || [];
                const roomMinX = room.gridX * ROOM_UNIT;
                const roomMaxX = roomMinX + ROOM_UNIT;
                const roomMinZ = room.gridZ * ROOM_UNIT;
                const roomMaxZ = roomMinZ + ROOM_UNIT;

                // Shelves along all walls (avoiding doors)
                // West wall shelves
                if (!doors.includes('west')) {
                    createShelfUnitAt(roomMinX + 2.5, worldZ - 6, theme, false);
                    createShelfUnitAt(roomMinX + 2.5, worldZ, theme, false);
                    createShelfUnitAt(roomMinX + 2.5, worldZ + 6, theme, false);
                }
                // East wall shelves
                if (!doors.includes('east')) {
                    createShelfUnitAt(roomMaxX - 2.5, worldZ - 6, theme, true);
                    createShelfUnitAt(roomMaxX - 2.5, worldZ, theme, true);
                    createShelfUnitAt(roomMaxX - 2.5, worldZ + 6, theme, true);
                }
                // North wall shelves
                if (!doors.includes('north')) {
                    createWallShelfAt(worldX - 6, roomMinZ + 2.5, theme, 0);
                    createWallShelfAt(worldX + 6, roomMinZ + 2.5, theme, 0);
                }
                // South wall shelves
                if (!doors.includes('south')) {
                    createWallShelfAt(worldX - 6, roomMaxZ - 2.5, theme, Math.PI);
                    createWallShelfAt(worldX + 6, roomMaxZ - 2.5, theme, Math.PI);
                }

                // Center displays/islands (not in JUNCTION rooms)
                if (room.theme !== 'JUNCTION') {
                    createCenterDisplay(worldX, worldZ, theme);
                }
            }
        }

        // Create wall-mounted shelf (for north/south walls)
        function createWallShelfAt(x, z, theme, rotation) {
            const group = new THREE.Group();
            group.position.set(x, 0, z);
            group.rotation.y = rotation;

            // Frame
            const frameGeo = new THREE.BoxGeometry(4, 6, 0.8);
            const frameMat = new THREE.MeshStandardMaterial({ color: theme.shelfColor });
            const frame = new THREE.Mesh(frameGeo, frameMat);
            frame.position.y = 3;
            frame.castShadow = true;
            group.add(frame);

            // Shelves and products
            for (let i = 0; i < 3; i++) {
                const boardGeo = new THREE.BoxGeometry(3.8, 0.1, 0.9);
                const boardMat = new THREE.MeshStandardMaterial({ color: new THREE.Color(theme.shelfColor).multiplyScalar(0.7) });
                const board = new THREE.Mesh(boardGeo, boardMat);
                board.position.set(0, 0.5 + i * 2, 0);
                group.add(board);

                // Products
                if (theme.productColors.length > 0) {
                    for (let j = 0; j < 4; j++) {
                        const color = theme.productColors[Math.floor(Math.random() * theme.productColors.length)];
                        const productGeo = new THREE.BoxGeometry(0.5, 0.8 + Math.random() * 0.4, 0.4);
                        const productMat = new THREE.MeshStandardMaterial({ color });
                        const product = new THREE.Mesh(productGeo, productMat);
                        product.position.set(-1.2 + j * 0.8, 1 + i * 2, 0);
                        product.castShadow = true;
                        group.add(product);
                    }
                }
            }

            scene.add(group);
            shelves.push(group);
        }

        // Create center display island
        function createCenterDisplay(x, z, theme) {
            const group = new THREE.Group();
            group.position.set(x, 0, z);

            // Base platform
            const baseGeo = new THREE.BoxGeometry(5, 0.4, 5);
            const baseMat = new THREE.MeshStandardMaterial({
                color: new THREE.Color(theme.shelfColor).multiplyScalar(0.8)
            });
            const base = new THREE.Mesh(baseGeo, baseMat);
            base.position.y = 0.2;
            base.receiveShadow = true;
            base.castShadow = true;
            group.add(base);

            // Display shelving (lower than wall shelves)
            const shelfGeo = new THREE.BoxGeometry(4.5, 0.1, 4.5);
            const shelfMat = new THREE.MeshStandardMaterial({
                color: new THREE.Color(theme.shelfColor).multiplyScalar(0.6)
            });

            for (let level = 0; level < 2; level++) {
                const shelf = new THREE.Mesh(shelfGeo, shelfMat);
                shelf.position.y = 0.5 + level * 1.2;
                group.add(shelf);

                // Products on each level
                if (theme.productColors.length > 0) {
                    for (let i = 0; i < 9; i++) {
                        const row = Math.floor(i / 3);
                        const col = i % 3;
                        const color = theme.productColors[Math.floor(Math.random() * theme.productColors.length)];

                        // Varied product shapes
                        let productGeo;
                        const shapeType = Math.floor(Math.random() * 3);
                        if (shapeType === 0) {
                            productGeo = new THREE.BoxGeometry(0.6, 0.8 + Math.random() * 0.5, 0.6);
                        } else if (shapeType === 1) {
                            productGeo = new THREE.CylinderGeometry(0.25, 0.25, 0.9 + Math.random() * 0.4, 8);
                        } else {
                            productGeo = new THREE.BoxGeometry(0.5, 1.0 + Math.random() * 0.3, 0.3);
                        }

                        const productMat = new THREE.MeshStandardMaterial({ color });
                        const product = new THREE.Mesh(productGeo, productMat);
                        product.position.set(
                            -1.2 + col * 1.2,
                            0.9 + level * 1.2 + (shapeType === 1 ? 0.45 : 0.4),
                            -1.2 + row * 1.2
                        );
                        product.castShadow = true;
                        group.add(product);
                    }
                }
            }

            // Promotional sign on top (for some rooms)
            if (Math.random() > 0.5) {
                const signGeo = new THREE.PlaneGeometry(2.5, 1);
                const signCanvas = document.createElement('canvas');
                signCanvas.width = 256;
                signCanvas.height = 128;
                const ctx = signCanvas.getContext('2d');

                // Sign background
                ctx.fillStyle = '#e74c3c';
                ctx.fillRect(0, 0, 256, 128);

                // Sign border
                ctx.strokeStyle = '#c0392b';
                ctx.lineWidth = 8;
                ctx.strokeRect(4, 4, 248, 120);

                // Sign text
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 36px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('SALE!', 128, 55);
                ctx.font = '24px Arial';
                ctx.fillText('50% OFF', 128, 95);

                const signTex = new THREE.CanvasTexture(signCanvas);
                const signMat = new THREE.MeshBasicMaterial({ map: signTex, side: THREE.DoubleSide });
                const sign = new THREE.Mesh(signGeo, signMat);
                sign.position.y = 3.5;
                sign.rotation.y = Math.random() * Math.PI * 2;
                group.add(sign);
            }

            scene.add(group);
        }

        // Create walls for a room with door openings
        function createRoomWalls(room) {
            const wallMat = new THREE.MeshStandardMaterial({ color: 0x34495e });
            const wallHeight = 12;
            const doors = room.doors || [];

            const roomMinX = room.gridX * ROOM_UNIT;
            const roomMaxX = roomMinX + ROOM_UNIT;
            const roomMinZ = room.gridZ * ROOM_UNIT;
            const roomMaxZ = roomMinZ + ROOM_UNIT;
            const centerX = roomMinX + ROOM_UNIT / 2;
            const centerZ = roomMinZ + ROOM_UNIT / 2;

            const wallSegment = (ROOM_UNIT - DOOR_WIDTH) / 2;

            // North wall (z = roomMinZ)
            if (doors.includes('north')) {
                // Two wall segments with door in middle
                createWallSegment(roomMinX + wallSegment/2, wallHeight/2, roomMinZ, wallSegment, wallHeight, 1, wallMat);
                createWallSegment(roomMaxX - wallSegment/2, wallHeight/2, roomMinZ, wallSegment, wallHeight, 1, wallMat);
            } else {
                createWallSegment(centerX, wallHeight/2, roomMinZ, ROOM_UNIT, wallHeight, 1, wallMat);
            }

            // South wall (z = roomMaxZ)
            if (doors.includes('south')) {
                createWallSegment(roomMinX + wallSegment/2, wallHeight/2, roomMaxZ, wallSegment, wallHeight, 1, wallMat);
                createWallSegment(roomMaxX - wallSegment/2, wallHeight/2, roomMaxZ, wallSegment, wallHeight, 1, wallMat);
            } else {
                createWallSegment(centerX, wallHeight/2, roomMaxZ, ROOM_UNIT, wallHeight, 1, wallMat);
            }

            // West wall (x = roomMinX)
            if (doors.includes('west')) {
                createWallSegment(roomMinX, wallHeight/2, roomMinZ + wallSegment/2, 1, wallHeight, wallSegment, wallMat);
                createWallSegment(roomMinX, wallHeight/2, roomMaxZ - wallSegment/2, 1, wallHeight, wallSegment, wallMat);
            } else {
                createWallSegment(roomMinX, wallHeight/2, centerZ, 1, wallHeight, ROOM_UNIT, wallMat);
            }

            // East wall (x = roomMaxX)
            if (doors.includes('east')) {
                createWallSegment(roomMaxX, wallHeight/2, roomMinZ + wallSegment/2, 1, wallHeight, wallSegment, wallMat);
                createWallSegment(roomMaxX, wallHeight/2, roomMaxZ - wallSegment/2, 1, wallHeight, wallSegment, wallMat);
            } else {
                createWallSegment(roomMaxX, wallHeight/2, centerZ, 1, wallHeight, ROOM_UNIT, wallMat);
            }
        }

        function createWallSegment(x, y, z, width, height, depth, material) {
            const geo = new THREE.BoxGeometry(width, height, depth);
            const wall = new THREE.Mesh(geo, material);
            wall.position.set(x, y, z);
            wall.receiveShadow = true;
            scene.add(wall);
        }

        // Create shelf unit at specific position with theme
        function createShelfUnitAt(x, z, theme, facingLeft) {
            const group = new THREE.Group();
            group.position.set(x, 0, z);
            if (facingLeft) group.rotation.y = Math.PI;

            const frameGeo = new THREE.BoxGeometry(4, 8, 1.2);
            const frameMat = new THREE.MeshStandardMaterial({ color: theme.shelfColor });
            const frame = new THREE.Mesh(frameGeo, frameMat);
            frame.position.y = 4;
            frame.castShadow = true;
            group.add(frame);

            const boardGeo = new THREE.BoxGeometry(3.8, 0.15, 1.4);
            const boardMat = new THREE.MeshStandardMaterial({ color: new THREE.Color(theme.shelfColor).multiplyScalar(0.7) });
            const productGeo = new THREE.BoxGeometry(0.6, 1.2, 0.5);

            for (let i = 0; i < 3; i++) {
                const board = new THREE.Mesh(boardGeo, boardMat);
                board.position.set(0, 0.6 + i * 2.5, 0.2);
                group.add(board);

                if (theme.productColors.length > 0) {
                    for (let j = 0; j < 4; j++) {
                        const color = theme.productColors[Math.floor(Math.random() * theme.productColors.length)];
                        const prodMat = new THREE.MeshLambertMaterial({ color });
                        const product = new THREE.Mesh(productGeo, prodMat);
                        product.position.set(-1.2 + j * 0.8, 1.3 + i * 2.5, 0.2);
                        group.add(product);
                    }
                }
            }

            scene.add(group);
            shelves.push(group);
        }

        function createAisleSign(text, color, z) {
            const group = new THREE.Group();

            // Sign board with canvas texture
            const signCanvas = document.createElement('canvas');
            signCanvas.width = 512;
            signCanvas.height = 128;
            const ctx = signCanvas.getContext('2d');

            // Background
            const colorHex = '#' + color.toString(16).padStart(6, '0');
            ctx.fillStyle = colorHex;
            ctx.fillRect(0, 0, 512, 128);

            // Border
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 6;
            ctx.strokeRect(3, 3, 506, 122);

            // Text
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 42px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, 256, 64);

            const signTexture = new THREE.CanvasTexture(signCanvas);
            const signGeo = new THREE.BoxGeometry(10, 2, 0.3);
            const signMat = new THREE.MeshStandardMaterial({
                map: signTexture,
                emissive: new THREE.Color(color),
                emissiveIntensity: 0.2
            });
            const sign = new THREE.Mesh(signGeo, signMat);
            group.add(sign);

            // Back of sign (same texture)
            const signBack = new THREE.Mesh(signGeo, signMat);
            signBack.rotation.y = Math.PI;
            group.add(signBack);

            // Hanging chains/poles
            const poleGeo = new THREE.CylinderGeometry(0.05, 0.05, 2, 8);
            const poleMat = new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.8 });

            const poleL = new THREE.Mesh(poleGeo, poleMat);
            poleL.position.set(-4, 2, 0);
            group.add(poleL);

            const poleR = new THREE.Mesh(poleGeo, poleMat);
            poleR.position.set(4, 2, 0);
            group.add(poleR);

            // Position at ceiling height
            group.position.set(0, 13, z);

            return group;
        }

        function createCeilingLight() {
            const group = new THREE.Group();

            const fixtureGeo = new THREE.BoxGeometry(4, 0.3, 1);
            const fixtureMat = new THREE.MeshStandardMaterial({ color: 0x444444 });
            const fixture = new THREE.Mesh(fixtureGeo, fixtureMat);
            group.add(fixture);

            const lightGeo = new THREE.BoxGeometry(3.5, 0.1, 0.8);
            const lightMat = new THREE.MeshStandardMaterial({
                color: 0xffffee,
                emissive: 0xffffee,
                emissiveIntensity: 0.5
            });
            const light = new THREE.Mesh(lightGeo, lightMat);
            light.position.y = -0.2;
            group.add(light);

            return group;
        }

        function createPlayerCart() {
            playerCart = new THREE.Group();

            // Materials
            const chromeMat = new THREE.MeshStandardMaterial({
                color: 0xc0c0c0,
                metalness: 0.9,
                roughness: 0.2
            });
            const darkChromeMat = new THREE.MeshStandardMaterial({
                color: 0x606060,
                metalness: 0.8,
                roughness: 0.3
            });
            const redPlasticMat = new THREE.MeshStandardMaterial({
                color: 0xe74c3c,
                metalness: 0.1,
                roughness: 0.6
            });
            const blackRubberMat = new THREE.MeshStandardMaterial({
                color: 0x1a1a1a,
                metalness: 0.0,
                roughness: 0.9
            });

            // === CART FRAME ===
            const cartGroup = new THREE.Group();

            // Main basket frame - bottom
            const bottomFrameGeo = new THREE.BoxGeometry(1.8, 0.08, 2.6);
            const bottomFrame = new THREE.Mesh(bottomFrameGeo, chromeMat);
            bottomFrame.position.set(0, 0.5, 0);
            bottomFrame.castShadow = true;
            cartGroup.add(bottomFrame);

            // Wire mesh bottom (grid pattern)
            for (let x = -0.8; x <= 0.8; x += 0.2) {
                const wireGeo = new THREE.CylinderGeometry(0.015, 0.015, 2.5, 6);
                const wire = new THREE.Mesh(wireGeo, chromeMat);
                wire.rotation.x = Math.PI / 2;
                wire.position.set(x, 0.52, 0);
                cartGroup.add(wire);
            }
            for (let z = -1.2; z <= 1.2; z += 0.2) {
                const wireGeo = new THREE.CylinderGeometry(0.015, 0.015, 1.7, 6);
                const wire = new THREE.Mesh(wireGeo, chromeMat);
                wire.rotation.z = Math.PI / 2;
                wire.position.set(0, 0.52, z);
                cartGroup.add(wire);
            }

            // Cart sides - wire mesh walls
            const createWireSide = (width, height, posX, posZ, rotY) => {
                const sideGroup = new THREE.Group();
                // Vertical wires
                const wireCount = Math.floor(width / 0.15);
                for (let i = 0; i <= wireCount; i++) {
                    const wireGeo = new THREE.CylinderGeometry(0.02, 0.02, height, 6);
                    const wire = new THREE.Mesh(wireGeo, chromeMat);
                    wire.position.set(-width/2 + i * (width/wireCount), height/2, 0);
                    sideGroup.add(wire);
                }
                // Horizontal wires
                for (let y = 0.15; y < height; y += 0.2) {
                    const hWireGeo = new THREE.CylinderGeometry(0.015, 0.015, width, 6);
                    const hWire = new THREE.Mesh(hWireGeo, chromeMat);
                    hWire.rotation.z = Math.PI / 2;
                    hWire.position.set(0, y, 0);
                    sideGroup.add(hWire);
                }
                // Top rail
                const topRailGeo = new THREE.CylinderGeometry(0.03, 0.03, width + 0.1, 8);
                const topRail = new THREE.Mesh(topRailGeo, chromeMat);
                topRail.rotation.z = Math.PI / 2;
                topRail.position.set(0, height, 0);
                sideGroup.add(topRail);

                sideGroup.position.set(posX, 0.55, posZ);
                sideGroup.rotation.y = rotY;
                return sideGroup;
            };

            // Left side wall
            cartGroup.add(createWireSide(2.5, 1.0, -0.9, 0, Math.PI / 2));
            // Right side wall
            cartGroup.add(createWireSide(2.5, 1.0, 0.9, 0, Math.PI / 2));
            // Front wall
            cartGroup.add(createWireSide(1.7, 1.0, 0, -1.25, 0));
            // Back wall (shorter for child to sit)
            cartGroup.add(createWireSide(1.7, 0.6, 0, 1.25, 0));

            // Corner posts
            const cornerPositions = [[-0.85, -1.2], [0.85, -1.2], [-0.85, 1.2], [0.85, 1.2]];
            cornerPositions.forEach(([x, z]) => {
                const postGeo = new THREE.CylinderGeometry(0.04, 0.04, 1.1, 8);
                const post = new THREE.Mesh(postGeo, chromeMat);
                post.position.set(x, 1.05, z);
                cartGroup.add(post);
            });

            // === RED PLASTIC CHILD SEAT ===
            const seatGroup = new THREE.Group();
            // Seat back
            const seatBackGeo = new THREE.BoxGeometry(1.2, 0.6, 0.1);
            const seatBack = new THREE.Mesh(seatBackGeo, redPlasticMat);
            seatBack.position.set(0, 1.1, 0.9);
            seatGroup.add(seatBack);
            // Seat bottom
            const seatBottomGeo = new THREE.BoxGeometry(1.2, 0.08, 0.5);
            const seatBottom = new THREE.Mesh(seatBottomGeo, redPlasticMat);
            seatBottom.position.set(0, 0.75, 1.05);
            seatGroup.add(seatBottom);
            // Leg holes
            const legHoleGeo = new THREE.BoxGeometry(0.25, 0.08, 0.3);
            const legHole1 = new THREE.Mesh(legHoleGeo, darkChromeMat);
            legHole1.position.set(-0.3, 0.72, 1.2);
            seatGroup.add(legHole1);
            const legHole2 = new THREE.Mesh(legHoleGeo, darkChromeMat);
            legHole2.position.set(0.3, 0.72, 1.2);
            seatGroup.add(legHole2);
            cartGroup.add(seatGroup);

            // === HANDLE ===
            // Handle bar (curved would be ideal, using segments)
            const handleBarGeo = new THREE.CylinderGeometry(0.04, 0.04, 1.9, 8);
            const handleBar = new THREE.Mesh(handleBarGeo, darkChromeMat);
            handleBar.rotation.z = Math.PI / 2;
            handleBar.position.set(0, 2.0, 1.6);
            cartGroup.add(handleBar);
            // Handle grips (rubber)
            const gripGeo = new THREE.CylinderGeometry(0.06, 0.06, 0.4, 8);
            const gripL = new THREE.Mesh(gripGeo, blackRubberMat);
            gripL.rotation.z = Math.PI / 2;
            gripL.position.set(-0.75, 2.0, 1.6);
            cartGroup.add(gripL);
            const gripR = new THREE.Mesh(gripGeo, blackRubberMat);
            gripR.rotation.z = Math.PI / 2;
            gripR.position.set(0.75, 2.0, 1.6);
            cartGroup.add(gripR);
            // Handle supports
            const supportGeo = new THREE.CylinderGeometry(0.03, 0.03, 0.5, 8);
            const supportL = new THREE.Mesh(supportGeo, chromeMat);
            supportL.position.set(-0.85, 1.75, 1.45);
            supportL.rotation.x = -0.3;
            cartGroup.add(supportL);
            const supportR = new THREE.Mesh(supportGeo, chromeMat);
            supportR.position.set(0.85, 1.75, 1.45);
            supportR.rotation.x = -0.3;
            cartGroup.add(supportR);

            // === WHEELS WITH CASTERS ===
            const createWheel = (x, z, isFront) => {
                const wheelGroup = new THREE.Group();
                // Caster housing
                const casterGeo = new THREE.CylinderGeometry(0.08, 0.1, 0.15, 8);
                const caster = new THREE.Mesh(casterGeo, darkChromeMat);
                caster.position.y = 0.35;
                wheelGroup.add(caster);
                // Caster fork
                const forkGeo = new THREE.BoxGeometry(0.04, 0.2, 0.12);
                const fork = new THREE.Mesh(forkGeo, chromeMat);
                fork.position.set(0, 0.2, 0);
                wheelGroup.add(fork);
                // Wheel
                const wheelGeo = new THREE.CylinderGeometry(0.15, 0.15, 0.08, 16);
                const wheel = new THREE.Mesh(wheelGeo, blackRubberMat);
                wheel.rotation.z = Math.PI / 2;
                wheel.position.y = 0.15;
                wheelGroup.add(wheel);
                // Wheel hub
                const hubGeo = new THREE.CylinderGeometry(0.05, 0.05, 0.1, 12);
                const hub = new THREE.Mesh(hubGeo, chromeMat);
                hub.rotation.z = Math.PI / 2;
                hub.position.y = 0.15;
                wheelGroup.add(hub);

                wheelGroup.position.set(x, 0, z);
                return wheelGroup;
            };
            cartGroup.add(createWheel(-0.75, -1.0, true));
            cartGroup.add(createWheel(0.75, -1.0, true));
            cartGroup.add(createWheel(-0.75, 1.0, false));
            cartGroup.add(createWheel(0.75, 1.0, false));

            // === FRAME LEGS ===
            const legGeo = new THREE.CylinderGeometry(0.03, 0.035, 0.5, 8);
            const legPositions = [[-0.8, -1.0], [0.8, -1.0], [-0.8, 1.0], [0.8, 1.0]];
            legPositions.forEach(([x, z]) => {
                const leg = new THREE.Mesh(legGeo, chromeMat);
                leg.position.set(x, 0.4, z);
                cartGroup.add(leg);
            });

            playerCart.add(cartGroup);

            // === CHILD CHARACTER ===
            const childGroup = new THREE.Group();
            const skinMat = new THREE.MeshStandardMaterial({ color: 0xffdbac, roughness: 0.8 });
            const shirtMat = new THREE.MeshStandardMaterial({ color: 0x3498db, roughness: 0.7 });
            const pantsMat = new THREE.MeshStandardMaterial({ color: 0x2c3e50, roughness: 0.7 });
            const hairMat = new THREE.MeshStandardMaterial({ color: 0x4a3728, roughness: 0.9 });

            // Torso
            const torsoGeo = new THREE.CylinderGeometry(0.28, 0.32, 0.7, 12);
            const torso = new THREE.Mesh(torsoGeo, shirtMat);
            torso.position.y = 1.2;
            torso.castShadow = true;
            childGroup.add(torso);

            // Head
            const headGeo = new THREE.SphereGeometry(0.28, 16, 16);
            const head = new THREE.Mesh(headGeo, skinMat);
            head.position.y = 1.85;
            head.castShadow = true;
            childGroup.add(head);

            // Hair (spiky/messy)
            const hairBaseGeo = new THREE.SphereGeometry(0.3, 16, 12, 0, Math.PI * 2, 0, Math.PI / 2);
            const hairBase = new THREE.Mesh(hairBaseGeo, hairMat);
            hairBase.position.y = 1.9;
            childGroup.add(hairBase);
            // Hair spikes
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const spikeGeo = new THREE.ConeGeometry(0.06, 0.15, 6);
                const spike = new THREE.Mesh(spikeGeo, hairMat);
                spike.position.set(
                    Math.cos(angle) * 0.2,
                    2.1,
                    Math.sin(angle) * 0.2
                );
                spike.rotation.x = Math.sin(angle) * 0.3;
                spike.rotation.z = -Math.cos(angle) * 0.3;
                childGroup.add(spike);
            }

            // Eyes
            const eyeWhiteGeo = new THREE.SphereGeometry(0.06, 8, 8);
            const eyeWhiteMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
            const eyePupilGeo = new THREE.SphereGeometry(0.035, 8, 8);
            const eyePupilMat = new THREE.MeshStandardMaterial({ color: 0x2c3e50 });
            // Left eye
            const eyeWhiteL = new THREE.Mesh(eyeWhiteGeo, eyeWhiteMat);
            eyeWhiteL.position.set(-0.1, 1.88, -0.24);
            childGroup.add(eyeWhiteL);
            const eyePupilL = new THREE.Mesh(eyePupilGeo, eyePupilMat);
            eyePupilL.position.set(-0.1, 1.88, -0.28);
            childGroup.add(eyePupilL);
            // Right eye
            const eyeWhiteR = new THREE.Mesh(eyeWhiteGeo, eyeWhiteMat);
            eyeWhiteR.position.set(0.1, 1.88, -0.24);
            childGroup.add(eyeWhiteR);
            const eyePupilR = new THREE.Mesh(eyePupilGeo, eyePupilMat);
            eyePupilR.position.set(0.1, 1.88, -0.28);
            childGroup.add(eyePupilR);

            // Eyebrows (mischievous angle)
            const browGeo = new THREE.BoxGeometry(0.1, 0.02, 0.02);
            const browMat = new THREE.MeshStandardMaterial({ color: 0x3d2817 });
            const browL = new THREE.Mesh(browGeo, browMat);
            browL.position.set(-0.1, 1.96, -0.26);
            browL.rotation.z = 0.2;
            childGroup.add(browL);
            const browR = new THREE.Mesh(browGeo, browMat);
            browR.position.set(0.1, 1.96, -0.26);
            browR.rotation.z = -0.2;
            childGroup.add(browR);

            // Mouth (grin)
            const mouthGeo = new THREE.TorusGeometry(0.06, 0.015, 8, 12, Math.PI);
            const mouthMat = new THREE.MeshStandardMaterial({ color: 0xc0392b });
            const mouth = new THREE.Mesh(mouthGeo, mouthMat);
            mouth.position.set(0, 1.78, -0.25);
            mouth.rotation.x = Math.PI;
            childGroup.add(mouth);

            // Nose
            const noseGeo = new THREE.SphereGeometry(0.04, 8, 8);
            const nose = new THREE.Mesh(noseGeo, skinMat);
            nose.position.set(0, 1.84, -0.28);
            childGroup.add(nose);

            // Arms
            const armGeo = new THREE.CylinderGeometry(0.08, 0.07, 0.45, 8);
            // Left arm (extended forward for slingshot)
            const leftArm = new THREE.Mesh(armGeo, shirtMat);
            leftArm.rotation.x = -Math.PI / 3;
            leftArm.rotation.z = Math.PI / 6;
            leftArm.position.set(-0.35, 1.35, -0.25);
            childGroup.add(leftArm);
            // Right arm (pulling back slingshot)
            const rightArm = new THREE.Mesh(armGeo, shirtMat);
            rightArm.rotation.x = -Math.PI / 4;
            rightArm.rotation.z = -Math.PI / 6;
            rightArm.position.set(0.35, 1.35, -0.15);
            childGroup.add(rightArm);

            // Hands
            const handGeo = new THREE.SphereGeometry(0.07, 8, 8);
            const handL = new THREE.Mesh(handGeo, skinMat);
            handL.position.set(-0.45, 1.15, -0.5);
            childGroup.add(handL);
            const handR = new THREE.Mesh(handGeo, skinMat);
            handR.position.set(0.4, 1.2, -0.35);
            childGroup.add(handR);

            // Legs (in seat holes)
            const legGeoChild = new THREE.CylinderGeometry(0.1, 0.08, 0.4, 8);
            const legL = new THREE.Mesh(legGeoChild, pantsMat);
            legL.position.set(-0.2, 0.65, 1.15);
            childGroup.add(legL);
            const legR = new THREE.Mesh(legGeoChild, pantsMat);
            legR.position.set(0.2, 0.65, 1.15);
            childGroup.add(legR);

            // Feet
            const footGeo = new THREE.BoxGeometry(0.12, 0.08, 0.18);
            const footMat = new THREE.MeshStandardMaterial({ color: 0x2ecc71 }); // Green sneakers
            const footL = new THREE.Mesh(footGeo, footMat);
            footL.position.set(-0.2, 0.45, 1.2);
            childGroup.add(footL);
            const footR = new THREE.Mesh(footGeo, footMat);
            footR.position.set(0.2, 0.45, 1.2);
            childGroup.add(footR);

            childGroup.position.z = 0.3;
            playerCart.add(childGroup);
            playerChild = childGroup; // Store reference for FPS mode visibility

            // === SLINGSHOT ===
            slingshotArm = new THREE.Group();
            const woodMat = new THREE.MeshStandardMaterial({
                color: 0x8b4513,
                roughness: 0.8
            });
            const rubberMat = new THREE.MeshStandardMaterial({
                color: 0xc0392b,
                roughness: 0.6
            });

            // Y-frame handle
            const handleGeo = new THREE.CylinderGeometry(0.04, 0.05, 0.5, 8);
            const slHandle = new THREE.Mesh(handleGeo, woodMat);
            slHandle.rotation.x = Math.PI / 2;
            slHandle.position.z = -0.25;
            slingshotArm.add(slHandle);

            // Fork prongs
            const forkGeo = new THREE.CylinderGeometry(0.03, 0.035, 0.25, 8);
            const forkL = new THREE.Mesh(forkGeo, woodMat);
            forkL.rotation.z = Math.PI / 5;
            forkL.position.set(-0.1, 0.1, -0.5);
            slingshotArm.add(forkL);
            const forkR = new THREE.Mesh(forkGeo, woodMat);
            forkR.rotation.z = -Math.PI / 5;
            forkR.position.set(0.1, 0.1, -0.5);
            slingshotArm.add(forkR);

            // Fork tips (rounded)
            const tipGeo = new THREE.SphereGeometry(0.04, 8, 8);
            const tipL = new THREE.Mesh(tipGeo, woodMat);
            tipL.position.set(-0.15, 0.2, -0.5);
            slingshotArm.add(tipL);
            const tipR = new THREE.Mesh(tipGeo, woodMat);
            tipR.position.set(0.15, 0.2, -0.5);
            slingshotArm.add(tipR);

            // Rubber bands
            const bandGeo = new THREE.CylinderGeometry(0.015, 0.015, 0.25, 6);
            const bandL = new THREE.Mesh(bandGeo, rubberMat);
            bandL.rotation.x = Math.PI / 3;
            bandL.rotation.z = Math.PI / 8;
            bandL.position.set(-0.1, 0.1, -0.38);
            slingshotArm.add(bandL);
            const bandR = new THREE.Mesh(bandGeo, rubberMat);
            bandR.rotation.x = Math.PI / 3;
            bandR.rotation.z = -Math.PI / 8;
            bandR.position.set(0.1, 0.1, -0.38);
            slingshotArm.add(bandR);

            // Pouch
            const pouchGeo = new THREE.SphereGeometry(0.06, 8, 8);
            pouchGeo.scale(1, 0.5, 1);
            const pouchMat = new THREE.MeshStandardMaterial({ color: 0x8b4513, roughness: 0.9 });
            const pouch = new THREE.Mesh(pouchGeo, pouchMat);
            pouch.position.set(0, 0.02, -0.25);
            slingshotArm.add(pouch);

            slingshotArm.position.set(-0.45, 1.15, -0.2);
            slingshotArm.rotation.x = -0.3;
            playerCart.add(slingshotArm);

            playerCart.position.set(0, 0, -5);
            scene.add(playerCart);
        }

        function createEnemyCart(x, z) {
            const group = new THREE.Group();
            group.userData = {
                health: ENEMY_HEALTH,
                active: true,
                driftSpeed: (Math.random() - 0.5) * 3,
                driftTimer: 0,
                hitFlash: 0
            };

            // Cart body
            const cartGeo = new THREE.BoxGeometry(2, 1.5, 2.5);
            const cartMat = new THREE.MeshStandardMaterial({ color: 0xe94560 });
            const cart = new THREE.Mesh(cartGeo, cartMat);
            cart.position.y = 1;
            cart.castShadow = true;
            group.add(cart);

            // Wire mesh effect
            const wireGeo = new THREE.EdgesGeometry(cartGeo);
            const wireMat = new THREE.LineBasicMaterial({ color: 0xc0392b });
            const wire = new THREE.LineSegments(wireGeo, wireMat);
            wire.position.y = 1;
            group.add(wire);

            // Wheels
            const wheelGeo = new THREE.CylinderGeometry(0.25, 0.25, 0.15, 16);
            const wheelMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
            [[-0.7, 0.25, -1], [0.7, 0.25, -1], [-0.7, 0.25, 1], [0.7, 0.25, 1]].forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeo, wheelMat);
                wheel.rotation.z = Math.PI / 2;
                wheel.position.set(...pos);
                group.add(wheel);
            });

            // Evil face
            const eyeGeo = new THREE.SphereGeometry(0.15, 8, 8);
            const eyeMat = new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xffff00, emissiveIntensity: 0.5 });
            const eyeL = new THREE.Mesh(eyeGeo, eyeMat);
            eyeL.position.set(-0.4, 1.3, -1.3);
            group.add(eyeL);
            const eyeR = new THREE.Mesh(eyeGeo, eyeMat);
            eyeR.position.set(0.4, 1.3, -1.3);
            group.add(eyeR);

            // Pupils
            const pupilGeo = new THREE.SphereGeometry(0.08, 8, 8);
            const pupilMat = new THREE.MeshStandardMaterial({ color: 0x000000 });
            const pupilL = new THREE.Mesh(pupilGeo, pupilMat);
            pupilL.position.set(-0.4, 1.3, -1.42);
            group.add(pupilL);
            const pupilR = new THREE.Mesh(pupilGeo, pupilMat);
            pupilR.position.set(0.4, 1.3, -1.42);
            group.add(pupilR);

            // Health bar
            const healthBarBg = new THREE.Mesh(
                new THREE.BoxGeometry(2, 0.2, 0.1),
                new THREE.MeshBasicMaterial({ color: 0x333333 })
            );
            healthBarBg.position.set(0, 2.5, 0);
            healthBarBg.name = 'healthBarBg';
            group.add(healthBarBg);

            const healthBar = new THREE.Mesh(
                new THREE.BoxGeometry(2, 0.18, 0.12),
                new THREE.MeshBasicMaterial({ color: 0x2ecc71 })
            );
            healthBar.position.set(0, 2.5, 0);
            healthBar.name = 'healthBar';
            group.add(healthBar);

            group.position.set(x, 0, z);
            scene.add(group);
            enemies.push(group);
            return group;
        }

        function createObstacle(x, z, type) {
            const group = new THREE.Group();
            group.userData = {
                type: type,
                active: true,
                hit: false,
                fallAngle: 0,
                fallSpeed: 0
            };

            if (type === 'stack') {
                const colors = [0xe74c3c, 0x3498db, 0x2ecc71, 0xf1c40f, 0x9b59b6];
                const color = colors[Math.floor(Math.random() * colors.length)];

                // Pyramid of boxes
                for (let row = 0; row < 3; row++) {
                    const boxesInRow = 3 - row;
                    for (let col = 0; col < boxesInRow; col++) {
                        const boxGeo = new THREE.BoxGeometry(1, 0.8, 1);
                        const boxMat = new THREE.MeshStandardMaterial({ color: color });
                        const box = new THREE.Mesh(boxGeo, boxMat);
                        box.position.set(
                            (col - (boxesInRow - 1) / 2) * 1.1,
                            0.4 + row * 0.85,
                            0
                        );
                        box.castShadow = true;
                        group.add(box);
                    }
                }
                group.userData.width = 3;
                group.userData.height = 3;
            } else if (type === 'barrel') {
                const barrelGeo = new THREE.CylinderGeometry(0.6, 0.6, 1.5, 16);
                const barrelMat = new THREE.MeshStandardMaterial({ color: 0x2980b9 });
                const barrel = new THREE.Mesh(barrelGeo, barrelMat);
                barrel.position.y = 0.75;
                barrel.castShadow = true;
                group.add(barrel);

                // Bands
                const bandGeo = new THREE.TorusGeometry(0.62, 0.05, 8, 32);
                const bandMat = new THREE.MeshStandardMaterial({ color: 0x1a5276 });
                [-0.4, 0.4].forEach(y => {
                    const band = new THREE.Mesh(bandGeo, bandMat);
                    band.rotation.x = Math.PI / 2;
                    band.position.y = 0.75 + y;
                    group.add(band);
                });

                group.userData.width = 1.5;
                group.userData.height = 2;
            } else if (type === 'display') {
                // Promotional display stand
                const standGeo = new THREE.BoxGeometry(2, 3, 1.5);
                const standMat = new THREE.MeshStandardMaterial({ color: 0xf39c12 });
                const stand = new THREE.Mesh(standGeo, standMat);
                stand.position.y = 1.5;
                stand.castShadow = true;
                group.add(stand);

                // Sale sign
                const signGeo = new THREE.BoxGeometry(1.8, 0.8, 0.1);
                const signCanvas = document.createElement('canvas');
                signCanvas.width = 256;
                signCanvas.height = 128;
                const ctx = signCanvas.getContext('2d');
                ctx.fillStyle = '#e74c3c';
                ctx.fillRect(0, 0, 256, 128);
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 48px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('SALE!', 128, 80);
                const signTex = new THREE.CanvasTexture(signCanvas);
                const signMat = new THREE.MeshStandardMaterial({ map: signTex });
                const sign = new THREE.Mesh(signGeo, signMat);
                sign.position.set(0, 3.5, 0);
                group.add(sign);

                group.userData.width = 2.5;
                group.userData.height = 4;
            }

            group.position.set(x, 0, z);
            scene.add(group);
            obstacles.push(group);
            return group;
        }

        function createProjectile(direction, spawnPos, speed = PROJECTILE_SPEED_MAX) {
            const group = new THREE.Group();

            // Stone/ball projectile - size scales slightly with power
            const sizeScale = 0.8 + (speed / PROJECTILE_SPEED_MAX) * 0.4;
            const stoneGeo = new THREE.SphereGeometry(0.2 * sizeScale, 12, 12);
            const stoneMat = new THREE.MeshStandardMaterial({
                color: 0xf39c12,
                emissive: 0xf39c12,
                emissiveIntensity: 0.2 + (speed / PROJECTILE_SPEED_MAX) * 0.4
            });
            const stone = new THREE.Mesh(stoneGeo, stoneMat);
            group.add(stone);

            // Glow - brighter for faster projectiles
            const glowGeo = new THREE.SphereGeometry(0.3 * sizeScale, 12, 12);
            const glowMat = new THREE.MeshBasicMaterial({
                color: 0xf39c12,
                transparent: true,
                opacity: 0.2 + (speed / PROJECTILE_SPEED_MAX) * 0.3
            });
            const glow = new THREE.Mesh(glowGeo, glowMat);
            group.add(glow);

            // Use provided spawn position (slingshot) or fallback to camera
            if (spawnPos) {
                group.position.copy(spawnPos);
            } else {
                group.position.copy(camera.position);
                group.position.y -= 0.5;
            }

            // Calculate power (0-1) based on speed
            const power = (speed - PROJECTILE_SPEED_MIN) / (PROJECTILE_SPEED_MAX - PROJECTILE_SPEED_MIN);

            group.userData = {
                velocity: direction.clone().multiplyScalar(speed),
                active: true,
                prevPosition: group.position.clone(), // For sweep collision detection
                power: Math.max(0, Math.min(1, power)) // Clamped 0-1
            };

            scene.add(group);
            projectiles.push(group);
            return group;
        }

        // Shared particle geometry for performance
        const particleGeo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
        const MAX_PARTICLES = 50;  // Limit particle count

        function createParticle(position, color) {
            // Enforce particle limit
            if (particles.length >= MAX_PARTICLES) return;

            const mat = new THREE.MeshBasicMaterial({ color: color });
            const particle = new THREE.Mesh(particleGeo, mat);
            particle.position.copy(position);
            particle.userData = {
                velocity: new THREE.Vector3(
                    (Math.random() - 0.5) * 10,
                    Math.random() * 8 + 2,
                    (Math.random() - 0.5) * 10
                ),
                life: 0.8  // Shorter life
            };
            scene.add(particle);
            particles.push(particle);
        }

        function spawnParticles(position, color, count) {
            // Limit particles based on current count
            const available = MAX_PARTICLES - particles.length;
            const toSpawn = Math.min(count, available);
            for (let i = 0; i < toSpawn; i++) {
                createParticle(position, color);
            }
        }

        function showScorePopup(points, screenX, screenY) {
            const popup = document.createElement('div');
            popup.className = 'score-popup';
            popup.textContent = '+' + points;
            popup.style.left = screenX + 'px';
            popup.style.top = screenY + 'px';
            document.getElementById('ui-layer').appendChild(popup);
            setTimeout(() => popup.remove(), 1000);
        }

        function showHitMarker() {
            hitMarker.classList.add('show');
            setTimeout(() => hitMarker.classList.remove('show'), 150);
        }

        function addScore(points, position) {
            score += points;
            scoreElement.textContent = score;

            // Trigger score bump animation
            const scoreContainer = document.getElementById('score-container');
            scoreElement.classList.add('bump');
            scoreContainer.classList.add('bump');
            setTimeout(() => {
                scoreElement.classList.remove('bump');
                scoreContainer.classList.remove('bump');
            }, 150);

            // Convert 3D position to screen position
            const screenPos = position.clone().project(camera);
            const x = (screenPos.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-screenPos.y * 0.5 + 0.5) * window.innerHeight;
            showScorePopup(points, x, y);
        }

        // Convert world position to screen coordinates for crosshair
        function worldToScreen(worldPos) {
            const vector = worldPos.clone().project(camera);
            return {
                x: (vector.x * 0.5 + 0.5) * window.innerWidth,
                y: (-vector.y * 0.5 + 0.5) * window.innerHeight
            };
        }

        // Slingshot Charging Functions
        function startCharging() {
            if (!isChargingSlingshot && gameState === 'PLAYING') {
                const now = Date.now();
                if (now - lastShootTime < SHOOT_COOLDOWN) return; // Still on cooldown

                isChargingSlingshot = true;
                slingshotTension = TENSION_MIN;
            }
        }

        function updateCharging(dt) {
            if (isChargingSlingshot && slingshotTension < TENSION_MAX) {
                slingshotTension += TENSION_CHARGE_RATE * dt;
                if (slingshotTension > TENSION_MAX) {
                    slingshotTension = TENSION_MAX;
                }
            }
        }

        function cancelCharging() {
            isChargingSlingshot = false;
            slingshotTension = 0;
        }

        function releaseAndFire() {
            if (!isChargingSlingshot) return;

            const tension = slingshotTension;
            isChargingSlingshot = false;
            slingshotTension = 0;

            // Calculate speed based on tension
            const speed = PROJECTILE_SPEED_MIN +
                (PROJECTILE_SPEED_MAX - PROJECTILE_SPEED_MIN) * tension;

            shoot(speed);
        }

        function shoot(speed = PROJECTILE_SPEED_MAX) {
            const now = Date.now();
            lastShootTime = now;

            // Trigger FPS firing animation
            if (cameraMode === 'hybrid-fps') {
                fpsFireAnim = 1.0; // Start animation
            }

            // Get spawn position (FPS mode only)
            const spawnPos = camera.position.clone();
            const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
            spawnPos.add(forward.multiplyScalar(0.5));
            spawnPos.y -= 0.3;

            // Get direction from crosshair using raycaster
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2(
                (crosshairX / window.innerWidth) * 2 - 1,
                -(crosshairY / window.innerHeight) * 2 + 1
            );
            raycaster.setFromCamera(mouse, camera);

            // Shoot toward where crosshair is pointing (auto-aim keeps it on target)
            const farPoint = new THREE.Vector3();
            farPoint.copy(raycaster.ray.direction).multiplyScalar(100).add(raycaster.ray.origin);

            const direction = new THREE.Vector3();
            direction.subVectors(farPoint, spawnPos);
            direction.normalize();

            createProjectile(direction, spawnPos, speed);

            // Visual feedback
            ammoDisplay.textContent = 'RELOADING...';
            ammoDisplay.style.borderColor = '#e94560';
            setTimeout(() => {
                ammoDisplay.textContent = 'SLINGSHOT READY';
                ammoDisplay.style.borderColor = '#3498db';
            }, SHOOT_COOLDOWN);
        }

        function resetGame() {
            score = 0;
            gameTimer = GAME_DURATION;
            lastShootTime = 0;
            scoreElement.textContent = '0';
            updateTimerDisplay();

            // Reset player position and movement (start at center of ENTRANCE room)
            playerPosition = { x: 45, z: 75 };  // Grid (1,2) center
            playerRotation = 0;
            playerSpeed = 0;
            currentTurnRate = 0;
            playerHealth = PLAYER_MAX_HEALTH;
            lastDamageTime = 0;
            isInvulnerable = false;

            // Reset WASD keys
            keys.forward = false;
            keys.backward = false;
            keys.turnLeft = false;
            keys.turnRight = false;

            // Reset cart visual state
            currentLeanAngle = 0;
            fpsFireAnim = 0;

            // Reset room tracking
            currentRoom = null;
            visitedRooms.clear();

            // Reset slingshot tension
            slingshotTension = 0;
            isChargingSlingshot = false;

            // Reset crosshair to center
            crosshairX = window.innerWidth / 2;
            crosshairY = window.innerHeight / 2;
            lockedTarget = null;

            // Reset health UI
            healthFill.style.width = '100%';
            healthValue.textContent = '100';
            damageOverlay.classList.remove('flash');

            // Clear all game objects
            projectiles.forEach(p => scene.remove(p));
            enemies.forEach(e => scene.remove(e));
            obstacles.forEach(o => scene.remove(o));
            particles.forEach(p => scene.remove(p));

            projectiles = [];
            enemies = [];
            obstacles = [];
            particles = [];

            // Reset cart position
            playerCart.position.set(playerPosition.x, 0, playerPosition.z);
            playerCart.rotation.set(0, playerRotation, 0);

            // Reset camera for FPS view
            camera.position.set(playerPosition.x, 2.2, playerPosition.z);
            camera.rotation.set(-0.12, playerRotation, 0);
        }

        function updateCursor() {
            // Hide cursor during gameplay (we have a crosshair overlay)
            const canvas = renderer.domElement;
            if (gameState === 'PLAYING') {
                canvas.style.cursor = 'none';
                document.body.style.cursor = 'none';
            } else {
                canvas.style.cursor = 'default';
                document.body.style.cursor = 'default';
            }
        }

        function startGame() {
            resetGame();
            gameState = 'PLAYING';
            menuScreen.style.display = 'none';
            gameoverScreen.style.display = 'none';
            hud.style.display = 'block';
            healthContainer.style.display = 'block';
            // Center crosshair on start
            crosshairX = window.innerWidth / 2;
            crosshairY = window.innerHeight / 2;
            updateCursor();

            spawnInitialObjects();
        }

        function endGame(died = false) {
            gameState = 'GAME_OVER';
            hud.style.display = 'none';
            healthContainer.style.display = 'none';
            gameoverScreen.style.display = 'flex';
            finalScoreElement.textContent = score;

            // Set title based on how game ended
            gameoverTitle.textContent = died ? 'WRECKED!' : "TIME'S UP!";

            let rating = 'Mild Mischief';
            if (score > 10000) rating = 'LEGENDARY CHAOS!';
            else if (score > 7000) rating = 'Total Mayhem!';
            else if (score > 4000) rating = 'Chaos Master';
            else if (score > 2000) rating = 'Troublemaker';
            else if (score > 800) rating = 'Rowdy Kid';
            ratingElement.textContent = rating;
            updateCursor();
        }

        function damagePlayer(amount) {
            if (isInvulnerable || gameState !== 'PLAYING') return;

            playerHealth = Math.max(0, playerHealth - amount);
            const healthPercent = playerHealth / PLAYER_MAX_HEALTH * 100;
            healthFill.style.width = healthPercent + '%';
            healthValue.textContent = playerHealth;

            // Update health bar gradient position (shows color based on health)
            healthFill.style.backgroundPosition = (100 - healthPercent) + '% 0';

            // Low health pulsing indicator
            if (playerHealth <= 30) {
                healthContainer.classList.add('low-health');
            } else {
                healthContainer.classList.remove('low-health');
            }

            // Trigger GPU-based damage vignette (scales with damage)
            damageVignetteStrength = Math.min(1.0, damageVignetteStrength + amount / 50);

            // Also flash CSS overlay for immediate feedback
            damageOverlay.classList.add('flash');
            setTimeout(() => damageOverlay.classList.remove('flash'), 200);

            // Start invulnerability
            isInvulnerable = true;
            lastDamageTime = Date.now();

            // Check for death
            if (playerHealth <= 0) {
                endGame(true);
            }
        }

        function updateInvulnerability() {
            if (isInvulnerable && Date.now() - lastDamageTime >= INVULNERABILITY_DURATION) {
                isInvulnerable = false;
            }
        }

        function pauseGame() {
            if (gameState !== 'PLAYING') return;
            gameState = 'PAUSED';
            cancelCharging(); // Cancel any charging in progress
            pauseScoreValue.textContent = score;
            pauseScreen.style.display = 'flex';
            hud.style.display = 'none';
            healthContainer.style.display = 'none';
            updateCursor();
        }

        function resumeGame() {
            if (gameState !== 'PAUSED') return;
            gameState = 'PLAYING';
            pauseScreen.style.display = 'none';
            hud.style.display = 'block';
            healthContainer.style.display = 'block';
            clock.getDelta(); // Reset delta to avoid jump
            updateCursor();
        }

        function quitToMenu() {
            gameState = 'MENU';
            pauseScreen.style.display = 'none';
            healthContainer.style.display = 'none';
            menuScreen.style.display = 'flex';
            resetGame();
            updateCursor();
        }

        function togglePause() {
            if (gameState === 'PLAYING') {
                pauseGame();
            } else if (gameState === 'PAUSED') {
                resumeGame();
            }
        }

        function spawnInitialObjects() {
            // Room-based spawning - trigger initial room spawn
            updateCurrentRoom();
        }

        function spawnObjects() {
            // Room-based spawning handles this now
            // Objects spawn when entering new rooms via updateCurrentRoom()
        }

        // Wall collision detection for grid-based maze
        function checkWallCollision(newX, newZ, oldX, oldZ) {
            const result = { blocked: false, blockedX: false, blockedZ: false };
            const margin = 1.2; // Player collision radius

            // Get current room
            const room = mallGrid.getRoomAtWorld(newX, newZ);
            if (!room) {
                // Outside grid - block movement
                return { blocked: true, blockedX: true, blockedZ: true };
            }

            // Calculate local position within room
            const roomMinX = room.gridX * ROOM_UNIT;
            const roomMaxX = roomMinX + ROOM_UNIT;
            const roomMinZ = room.gridZ * ROOM_UNIT;
            const roomMaxZ = roomMinZ + ROOM_UNIT;

            // Door center positions
            const doorCenterX = roomMinX + ROOM_UNIT / 2;
            const doorCenterZ = roomMinZ + ROOM_UNIT / 2;
            const doorHalf = DOOR_WIDTH / 2;

            // Check each wall
            const doors = room.doors || [];

            // West wall (x min)
            if (newX < roomMinX + margin) {
                if (doors.includes('west') && newZ > doorCenterZ - doorHalf && newZ < doorCenterZ + doorHalf) {
                    // In doorway - allow
                } else {
                    result.blockedX = true;
                }
            }

            // East wall (x max)
            if (newX > roomMaxX - margin) {
                if (doors.includes('east') && newZ > doorCenterZ - doorHalf && newZ < doorCenterZ + doorHalf) {
                    // In doorway - allow
                } else {
                    result.blockedX = true;
                }
            }

            // North wall (z min)
            if (newZ < roomMinZ + margin) {
                if (doors.includes('north') && newX > doorCenterX - doorHalf && newX < doorCenterX + doorHalf) {
                    // In doorway - allow
                } else {
                    result.blockedZ = true;
                }
            }

            // South wall (z max)
            if (newZ > roomMaxZ - margin) {
                if (doors.includes('south') && newX > doorCenterX - doorHalf && newX < doorCenterX + doorHalf) {
                    // In doorway - allow
                } else {
                    result.blockedZ = true;
                }
            }

            result.blocked = result.blockedX || result.blockedZ;
            return result;
        }

        // Timer display update
        function updateTimerDisplay() {
            const minutes = Math.floor(gameTimer / 60);
            const seconds = Math.floor(gameTimer % 60);
            const timerText = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            if (timerDisplay) {
                timerDisplay.textContent = timerText;
            }
            // Update timer bar fill
            const progress = gameTimer / GAME_DURATION;
            if (timerFill) {
                timerFill.style.width = `${progress * 100}%`;
            }
        }

        // Room tracking and spawning
        function updateCurrentRoom() {
            const room = mallGrid.getRoomAtWorld(playerPosition.x, playerPosition.z);
            if (room && room !== currentRoom) {
                const roomKey = `${room.gridX}_${room.gridZ}`;
                currentRoom = room;

                // Spawn contents if not visited
                if (!visitedRooms.has(roomKey)) {
                    visitedRooms.add(roomKey);
                    spawnRoomContents(room);
                }
            }
        }

        // Line-of-sight check for aim-assist (respects room walls)
        function hasLineOfSight(fromX, fromZ, toX, toZ) {
            // Get rooms for both positions
            const fromRoom = mallGrid.getRoomAtWorld(fromX, fromZ);
            const toRoom = mallGrid.getRoomAtWorld(toX, toZ);

            // If either position is outside the grid, no line of sight
            if (!fromRoom || !toRoom) return false;

            // Same room - always has line of sight
            if (fromRoom.gridX === toRoom.gridX && fromRoom.gridZ === toRoom.gridZ) {
                return true;
            }

            // Different rooms - ray march to check for wall intersections
            const dx = toX - fromX;
            const dz = toZ - fromZ;
            const dist = Math.sqrt(dx * dx + dz * dz);

            // Step size - check every 2 units
            const stepSize = 2;
            const steps = Math.ceil(dist / stepSize);

            let prevRoom = fromRoom;

            for (let i = 1; i <= steps; i++) {
                const t = i / steps;
                const checkX = fromX + dx * t;
                const checkZ = fromZ + dz * t;

                const checkRoom = mallGrid.getRoomAtWorld(checkX, checkZ);
                if (!checkRoom) return false; // Outside grid

                // Check if we crossed into a different room
                if (checkRoom.gridX !== prevRoom.gridX || checkRoom.gridZ !== prevRoom.gridZ) {
                    // Determine which wall we crossed
                    const wallDir = getWallDirection(prevRoom, checkRoom);

                    // Check if there's a door connecting these rooms
                    if (!wallDir || !prevRoom.doors.includes(wallDir)) {
                        return false; // No door - wall blocks line of sight
                    }

                    // Check if we're actually going through the door opening
                    const doorCenterX = prevRoom.gridX * ROOM_UNIT + ROOM_UNIT / 2;
                    const doorCenterZ = prevRoom.gridZ * ROOM_UNIT + ROOM_UNIT / 2;
                    const doorHalf = DOOR_WIDTH / 2 + 1; // Slightly wider for tolerance

                    if (wallDir === 'east' || wallDir === 'west') {
                        // Horizontal door - check Z alignment
                        if (checkZ < doorCenterZ - doorHalf || checkZ > doorCenterZ + doorHalf) {
                            return false; // Not going through door
                        }
                    } else {
                        // Vertical door - check X alignment
                        if (checkX < doorCenterX - doorHalf || checkX > doorCenterX + doorHalf) {
                            return false; // Not going through door
                        }
                    }

                    prevRoom = checkRoom;
                }
            }

            return true;
        }

        // Helper to determine wall direction between adjacent rooms
        function getWallDirection(fromRoom, toRoom) {
            const dx = toRoom.gridX - fromRoom.gridX;
            const dz = toRoom.gridZ - fromRoom.gridZ;

            if (dx === 1 && dz === 0) return 'east';
            if (dx === -1 && dz === 0) return 'west';
            if (dx === 0 && dz === 1) return 'south';
            if (dx === 0 && dz === -1) return 'north';

            return null; // Not adjacent
        }

        // Spawn enemies and obstacles for a room
        function spawnRoomContents(room) {
            // Don't spawn in entrance room
            if (room.theme === 'ENTRANCE') return;

            const roomCenterX = room.worldX;
            const roomCenterZ = room.worldZ;
            const spawnedPositions = []; // Track spawned positions to avoid overlap

            // Check if position is valid (not too close to walls, doors, or other spawns)
            function isValidSpawnPosition(x, z, minDist = 3) {
                // Check distance from room center (leave space for player navigation)
                const centerDist = Math.sqrt(Math.pow(x - roomCenterX, 2) + Math.pow(z - roomCenterZ, 2));
                if (centerDist < 4) return false; // Too close to center path

                // Check distance from walls (room boundary)
                const roomMinX = room.gridX * ROOM_UNIT;
                const roomMaxX = roomMinX + ROOM_UNIT;
                const roomMinZ = room.gridZ * ROOM_UNIT;
                const roomMaxZ = roomMinZ + ROOM_UNIT;
                const wallMargin = 4; // Distance from walls

                if (x < roomMinX + wallMargin || x > roomMaxX - wallMargin) return false;
                if (z < roomMinZ + wallMargin || z > roomMaxZ - wallMargin) return false;

                // Check distance from doors (leave doorways clear)
                const doors = room.doors || [];
                const doorHalf = DOOR_WIDTH / 2 + 2;
                if (doors.includes('north') && z < roomMinZ + 5 && Math.abs(x - roomCenterX) < doorHalf) return false;
                if (doors.includes('south') && z > roomMaxZ - 5 && Math.abs(x - roomCenterX) < doorHalf) return false;
                if (doors.includes('west') && x < roomMinX + 5 && Math.abs(z - roomCenterZ) < doorHalf) return false;
                if (doors.includes('east') && x > roomMaxX - 5 && Math.abs(z - roomCenterZ) < doorHalf) return false;

                // Check distance from other spawned objects
                for (const pos of spawnedPositions) {
                    const dist = Math.sqrt(Math.pow(x - pos.x, 2) + Math.pow(z - pos.z, 2));
                    if (dist < minDist) return false;
                }

                return true;
            }

            // Try to find a valid spawn position
            function findValidPosition(minDist = 3, maxAttempts = 20) {
                for (let attempt = 0; attempt < maxAttempts; attempt++) {
                    const x = roomCenterX + (Math.random() - 0.5) * 20;
                    const z = roomCenterZ + (Math.random() - 0.5) * 20;
                    if (isValidSpawnPosition(x, z, minDist)) {
                        return { x, z };
                    }
                }
                return null; // No valid position found
            }

            // Spawn 2-3 enemies with collision checking
            const numEnemies = 2 + Math.floor(Math.random() * 2);
            for (let i = 0; i < numEnemies; i++) {
                const pos = findValidPosition(4); // Enemies need more space
                if (pos) {
                    createEnemyCart(pos.x, pos.z);
                    spawnedPositions.push(pos);
                }
            }

            // Spawn 3-5 obstacles with collision checking
            const numObstacles = 3 + Math.floor(Math.random() * 3);
            const types = ['stack', 'barrel', 'display'];
            for (let i = 0; i < numObstacles; i++) {
                const pos = findValidPosition(3); // Obstacles can be closer
                if (pos) {
                    const type = types[Math.floor(Math.random() * types.length)];
                    createObstacle(pos.x, pos.z, type);
                    spawnedPositions.push(pos);
                }
            }
        }

        function updateCooldownIndicator() {
            const elapsed = Date.now() - lastShootTime;
            const progress = Math.min(elapsed / SHOOT_COOLDOWN, 1);
            const degrees = progress * 360;
            cooldownFill.style.transform = `rotate(${degrees}deg)`;
            cooldownFill.style.borderTopColor = progress >= 1 ? '#2ecc71' : '#e94560';
        }

        function update(dt) {
            if (gameState !== 'PLAYING') return;

            // Update invulnerability
            updateInvulnerability();

            // Update game timer
            gameTimer -= dt;
            if (gameTimer <= 0) {
                gameTimer = 0;
                endGame(false); // Time's up - not died
                return;
            }
            updateTimerDisplay();

            // Update room-based ambient lighting
            const room = mallGrid.getRoomAtWorld(playerPosition.x, playerPosition.z);
            if (room && room.themeData) {
                const targetColor = new THREE.Color(room.themeData.ambientColor);
                ambientLight.color.lerp(targetColor, 0.02);
            }

            // === WASD DRIVING MOVEMENT ===
            // Handle turning (A/D)
            const targetTurnRate = (keys.turnLeft ? 1 : 0) - (keys.turnRight ? 1 : 0);
            currentTurnRate += (targetTurnRate * CART_TURN_SPEED - currentTurnRate) * 8 * dt;
            playerRotation += currentTurnRate * dt;

            // Handle acceleration/deceleration (W/S)
            if (keys.forward) {
                playerSpeed += CART_ACCELERATION * dt;
            } else if (keys.backward) {
                playerSpeed -= CART_ACCELERATION * dt;
            } else {
                // Apply friction when no input, but maintain small idle drift
                if (playerSpeed > CART_IDLE_DRIFT) {
                    playerSpeed = Math.max(CART_IDLE_DRIFT, playerSpeed - CART_FRICTION * dt);
                } else if (playerSpeed < CART_IDLE_DRIFT) {
                    // Accelerate towards idle drift speed
                    playerSpeed = Math.min(CART_IDLE_DRIFT, playerSpeed + CART_FRICTION * 0.5 * dt);
                }
            }

            // Clamp speed
            playerSpeed = Math.max(-CART_REVERSE_SPEED, Math.min(CART_MAX_SPEED, playerSpeed));

            // Calculate velocity from rotation + speed
            const velocityX = -Math.sin(playerRotation) * playerSpeed;
            const velocityZ = -Math.cos(playerRotation) * playerSpeed;

            // Calculate new position
            let newX = playerPosition.x + velocityX * dt;
            let newZ = playerPosition.z + velocityZ * dt;

            // Wall collision detection
            const collision = checkWallCollision(newX, newZ, playerPosition.x, playerPosition.z);

            // Trigger wall bump effect on collision
            if (collision.blocked && playerSpeed > 1) {
                wallBumpIntensity = Math.min(1, playerSpeed / CART_MAX_SPEED);
                wallBumpDirection = {
                    x: collision.blockedX ? -Math.sign(velocityX) : 0,
                    z: collision.blockedZ ? -Math.sign(velocityZ) : 0
                };
                // Reduce speed on impact
                playerSpeed *= 0.3;
            }

            if (!collision.blockedX) playerPosition.x = newX;
            if (!collision.blockedZ) playerPosition.z = newZ;

            // Decay wall bump effect
            wallBumpIntensity *= 0.85;
            if (wallBumpIntensity < 0.01) wallBumpIntensity = 0;

            // Update cart position and rotation
            playerCart.position.x = playerPosition.x;
            playerCart.position.z = playerPosition.z;
            playerCart.rotation.y = playerRotation;

            // Cart leaning based on turn rate
            const targetLeanAngle = -currentTurnRate * CART_LEAN_ANGLE;
            currentLeanAngle += (targetLeanAngle - currentLeanAngle) * 8 * dt;
            playerCart.rotation.z = currentLeanAngle;

            // === FPS CAMERA (follows player rotation) ===
            // Apply wall bump offset to camera
            const bumpOffsetX = wallBumpDirection.x * wallBumpIntensity * 0.3;
            const bumpOffsetZ = wallBumpDirection.z * wallBumpIntensity * 0.3;
            const bumpShake = wallBumpIntensity * (Math.random() - 0.5) * 0.1;

            camera.position.x = playerPosition.x + bumpOffsetX;
            camera.position.y = 2.2 + bumpShake;
            camera.position.z = playerPosition.z + bumpOffsetZ;

            // Camera follows player rotation
            camera.rotation.set(0, 0, 0);
            camera.rotation.y = playerRotation;
            camera.rotation.x = -0.12 + wallBumpIntensity * 0.05; // Tilt on bump

            // Subtle roll for immersion + bump roll
            camera.rotation.z = currentLeanAngle * CAMERA_ROLL_FACTOR * 0.5 + bumpShake * 2;

            // FPS mode: hide child, show hands
            playerCart.visible = true;
            if (playerChild) playerChild.visible = false;
            if (slingshotArm) slingshotArm.visible = false;
            if (fpsWeapon) {
                fpsWeapon.visible = true;

                // Weapon lean when turning (matches cart lean for immersion)
                const weaponLeanAngle = -currentTurnRate * 0.15; // Subtle lean
                const weaponSway = currentTurnRate * 0.03;       // Horizontal sway

                // Smoothly interpolate weapon lean
                fpsWeapon.rotation.z = fpsWeapon.rotation.z * 0.85 + weaponLeanAngle * 0.15;
                fpsWeapon.position.x = 0.15 + fpsWeapon.position.x * 0.9 + weaponSway * 0.1;

                // Clamp position to prevent drift
                fpsWeapon.position.x = Math.max(0.1, Math.min(0.2, fpsWeapon.position.x));
            }

            // Update charging
            updateCharging(dt);

            // Animate FPS slingshot - LEFT hand pulls back pouch
            if (isChargingSlingshot) {
                // CHARGING: Left hand pulls back based on tension
                const pullBack = slingshotTension; // 0 to 1
                const pullZ = pullBack * 0.2;  // Pull back distance
                const pullY = pullBack * 0.03; // Slight upward pull

                // Move pouch and stone back with left hand
                if (fpsPouch) {
                    fpsPouch.position.z = 0.08 + pullZ;
                    fpsPouch.position.y = 0.02 + pullY;
                }
                if (fpsStone) {
                    fpsStone.position.z = 0.08 + pullZ;
                    fpsStone.position.y = 0.025 + pullY;
                    fpsStone.visible = true;
                }

                // Rubber bands stretch and thin out with tension
                const bandStretch = 1 + pullBack * 1.8;  // Length multiplier
                const bandThin = 1 - pullBack * 0.3;     // Thinner when stretched
                const bandAngle = pullBack * 0.6;        // Angle toward pull point

                if (fpsBandL) {
                    fpsBandL.scale.set(bandThin, bandStretch, bandThin);
                    fpsBandL.position.z = 0.04 + pullZ * 0.5;
                    fpsBandL.rotation.x = 0.3 + bandAngle;
                    fpsBandL.rotation.z = 0.1 - pullBack * 0.05;
                }
                if (fpsBandR) {
                    fpsBandR.scale.set(bandThin, bandStretch, bandThin);
                    fpsBandR.position.z = 0.04 + pullZ * 0.5;
                    fpsBandR.rotation.x = 0.3 + bandAngle;
                    fpsBandR.rotation.z = -0.1 + pullBack * 0.05;
                }

                // Pull LEFT hand back with pouch (pinching gesture)
                if (fpsHands && fpsHands.userData.leftHand) {
                    const leftHand = fpsHands.userData.leftHand;
                    leftHand.position.z = -0.15 + pullZ;
                    leftHand.position.y = -0.08 + pullY;
                    // Tighten pinch as tension increases
                    if (leftHand.userData.fingers) {
                        leftHand.userData.fingers[0].rotation.x = 0.8 + pullBack * 0.3; // Index curls more
                    }
                    if (leftHand.userData.thumb) {
                        leftHand.userData.thumb.rotation.x = 0.4 + pullBack * 0.2;
                    }
                }
            } else if (fpsFireAnim > 0) {
                // FIRING: Quick release animation - bands snap back
                fpsFireAnim -= dt * 8; // Fast snap
                if (fpsFireAnim < 0) fpsFireAnim = 0;

                const snapProgress = 1 - fpsFireAnim; // 0 to 1
                const snapZ = (1 - snapProgress) * 0.08;
                const snapY = (1 - snapProgress) * 0.02;

                // Pouch snaps forward
                if (fpsPouch) {
                    fpsPouch.position.z = 0.08 + snapZ;
                    fpsPouch.position.y = 0.02 + snapY;
                }
                if (fpsStone) {
                    fpsStone.position.z = 0.08 + snapZ;
                    fpsStone.position.y = 0.025 + snapY;
                    fpsStone.visible = fpsFireAnim > 0.7; // Stone disappears quickly (fired)
                }

                // Bands snap back with slight overshoot
                const bandSnap = 1 + (1 - snapProgress) * 0.4;
                const overshoot = snapProgress > 0.8 ? Math.sin((snapProgress - 0.8) * Math.PI * 5) * 0.1 : 0;

                if (fpsBandL) {
                    fpsBandL.scale.set(1, bandSnap + overshoot, 1);
                    fpsBandL.position.z = 0.04 + snapZ * 0.3;
                    fpsBandL.rotation.x = 0.3 + (1 - snapProgress) * 0.3;
                }
                if (fpsBandR) {
                    fpsBandR.scale.set(1, bandSnap + overshoot, 1);
                    fpsBandR.position.z = 0.04 + snapZ * 0.3;
                    fpsBandR.rotation.x = 0.3 + (1 - snapProgress) * 0.3;
                }

                // Left hand follows release
                if (fpsHands && fpsHands.userData.leftHand) {
                    const leftHand = fpsHands.userData.leftHand;
                    leftHand.position.z = -0.15 + snapZ;
                    leftHand.position.y = -0.08 + snapY;
                    // Open fingers after release
                    if (leftHand.userData.fingers) {
                        leftHand.userData.fingers[0].rotation.x = 0.8 + (1 - snapProgress) * 0.3;
                    }
                }
            } else {
                // READY: Reset to ready position
                if (fpsPouch) {
                    fpsPouch.position.set(0, 0.02, 0.08);
                }
                if (fpsStone) {
                    fpsStone.position.set(0, 0.025, 0.08);
                    fpsStone.visible = true;
                }
                if (fpsBandL) {
                    fpsBandL.scale.set(1, 1, 1);
                    fpsBandL.position.z = 0.04;
                    fpsBandL.rotation.set(0.3, 0, 0.1);
                }
                if (fpsBandR) {
                    fpsBandR.scale.set(1, 1, 1);
                    fpsBandR.position.z = 0.04;
                    fpsBandR.rotation.set(0.3, 0, -0.1);
                }
                if (fpsHands && fpsHands.userData.leftHand) {
                    const leftHand = fpsHands.userData.leftHand;
                    leftHand.position.set(-0.05, -0.08, -0.15);
                    if (leftHand.userData.fingers) {
                        leftHand.userData.fingers[0].rotation.x = 0.8;
                    }
                    if (leftHand.userData.thumb) {
                        leftHand.userData.thumb.rotation.x = 0.4;
                    }
                }
            }

            // Update current room for spawning
            updateCurrentRoom();

            // Smart Auto-Aim with Sticky Targeting
            let aimAssistActive = false;

            // Helper to check if a target object is still valid
            function isTargetValid(obj) {
                if (!obj || !obj.userData?.active) return false;
                if (obj.userData.hit) return false; // Obstacle already hit

                // Check if in front of camera
                const pos = obj.position.clone();
                pos.project(camera);
                if (pos.z >= 1 || pos.z <= 0) return false;

                // Check if passed behind player
                const zDist = camera.position.z - obj.position.z;
                if (zDist < -10) return false; // Too far behind

                // Check line-of-sight (no walls blocking)
                if (!hasLineOfSight(playerPosition.x, playerPosition.z, obj.position.x, obj.position.z)) {
                    return false; // Wall blocks view
                }

                return true;
            }

            // Helper to get screen position of target
            function getTargetScreenPos(obj, yOffset = 0) {
                const pos = obj.position.clone();
                pos.y += yOffset;
                pos.project(camera);
                return {
                    x: (pos.x * 0.5 + 0.5) * window.innerWidth,
                    y: (-pos.y * 0.5 + 0.5) * window.innerHeight
                };
            }

            // Check if current locked target is still valid
            if (lockedTarget && isTargetValid(lockedTarget)) {
                // Keep tracking current target
                aimAssistActive = true;
                const yOffset = lockedTarget.userData.height ? lockedTarget.userData.height * 0.4 : 1.5;
                const screenPos = getTargetScreenPos(lockedTarget, yOffset);
                crosshairX = screenPos.x;
                crosshairY = screenPos.y;
            } else {
                // Find new best target
                lockedTarget = null;
                let bestTarget = null;
                let bestScore = -Infinity;

                // Evaluate enemies
                enemies.forEach(enemy => {
                    if (!isTargetValid(enemy)) return;

                    const zDist = camera.position.z - enemy.position.z;
                    const xDist = Math.abs(enemy.position.x - playerPosition.x);
                    const isAhead = zDist > 0 && zDist < 100;
                    const inPath = xDist < 4;

                    let score = 0;
                    if (isAhead && inPath) {
                        score = 1000 - zDist * 5 - xDist * 20;
                    } else if (isAhead) {
                        score = 500 - zDist * 2 - xDist * 5;
                    } else {
                        score = 100 - enemy.position.distanceTo(camera.position);
                    }

                    if (score > bestScore) {
                        bestScore = score;
                        bestTarget = enemy;
                    }
                });

                // Evaluate obstacles
                obstacles.forEach(obs => {
                    if (!isTargetValid(obs)) return;

                    const zDist = camera.position.z - obs.position.z;
                    const xDist = Math.abs(obs.position.x - playerPosition.x);
                    const isAhead = zDist > 0 && zDist < 80;
                    const inPath = xDist < 3;

                    let score = 0;
                    if (isAhead && inPath) {
                        score = 800 - zDist * 4 - xDist * 15;
                    } else if (isAhead) {
                        score = 300 - zDist * 2 - xDist * 5;
                    }

                    if (score > bestScore) {
                        bestScore = score;
                        bestTarget = obs;
                    }
                });

                // Lock onto new target
                if (bestTarget) {
                    lockedTarget = bestTarget;
                    aimAssistActive = true;
                    const yOffset = bestTarget.userData.height ? bestTarget.userData.height * 0.4 : 1.5;
                    const screenPos = getTargetScreenPos(bestTarget, yOffset);
                    crosshairX = screenPos.x;
                    crosshairY = screenPos.y;
                }
            }

            // Keep crosshair within screen bounds
            crosshairX = Math.max(CROSSHAIR_BOUNDS_MARGIN, Math.min(window.innerWidth - CROSSHAIR_BOUNDS_MARGIN, crosshairX));
            crosshairY = Math.max(CROSSHAIR_BOUNDS_MARGIN, Math.min(window.innerHeight - CROSSHAIR_BOUNDS_MARGIN, crosshairY));

            // Update crosshair DOM position and aim-assist visual feedback
            const crosshairEl = document.getElementById('crosshair');
            if (aimAssistActive) {
                crosshairEl.classList.add('aim-assist-active');
            } else {
                crosshairEl.classList.remove('aim-assist-active');
            }
            crosshairEl.style.left = crosshairX + 'px';
            crosshairEl.style.top = crosshairY + 'px';

            // Update tension indicator
            const tensionEl = document.getElementById('tension-indicator');
            if (tensionEl) {
                tensionEl.style.left = crosshairX + 'px';
                tensionEl.style.top = crosshairY + 'px';

                if (isChargingSlingshot) {
                    tensionEl.classList.add('charging');

                    // Update tension class for color
                    tensionEl.classList.remove('medium', 'high', 'max');
                    if (slingshotTension >= TENSION_MAX) {
                        tensionEl.classList.add('max');
                    } else if (slingshotTension >= 0.7) {
                        tensionEl.classList.add('high');
                    } else if (slingshotTension >= 0.4) {
                        tensionEl.classList.add('medium');
                    }

                    // Update arc fill (283 = circumference of r=45 circle)
                    const fillEl = tensionEl.querySelector('.tension-fill');
                    if (fillEl) {
                        const dashOffset = 283 * (1 - slingshotTension);
                        fillEl.style.strokeDashoffset = dashOffset;
                    }

                    // Update text
                    const textEl = document.getElementById('tension-text');
                    if (textEl) {
                        const power = Math.round(slingshotTension * 100);
                        textEl.textContent = power >= 100 ? 'MAX POWER!' : power + '%';
                    }
                } else {
                    tensionEl.classList.remove('charging', 'medium', 'high', 'max');
                }
            }

            // Spawn new objects (room-based)
            spawnObjects();

            // Update projectiles
            projectiles.forEach(proj => {
                if (!proj.userData.active) return;
                proj.position.add(proj.userData.velocity.clone().multiplyScalar(dt));

                // Check if out of bounds (relative to camera position)
                const distFromCamera = proj.position.distanceTo(camera.position);
                if (distFromCamera > 150 ||
                    proj.position.y < 0 || proj.position.y > 15) {
                    proj.userData.active = false;
                }
            });

            // Update enemies
            enemies.forEach(enemy => {
                if (!enemy.userData.active) return;

                // Move towards player (v3 maze behavior)
                const toPlayer = new THREE.Vector3(
                    playerPosition.x - enemy.position.x,
                    0,
                    playerPosition.z - enemy.position.z
                );
                const distToPlayer = toPlayer.length();

                if (distToPlayer > 3) {
                    toPlayer.normalize();
                    const enemySpeed = CART_SPEED * 0.4;
                    enemy.position.x += toPlayer.x * enemySpeed * dt;
                    enemy.position.z += toPlayer.z * enemySpeed * dt;
                }

                // Random drift (adds unpredictability)
                enemy.userData.driftTimer += dt;
                if (enemy.userData.driftTimer > 1.5) {
                    enemy.userData.driftSpeed = (Math.random() - 0.5) * 3;
                    enemy.userData.driftTimer = 0;
                }
                enemy.position.x += enemy.userData.driftSpeed * dt;

                // Face player
                const lookDir = Math.atan2(
                    playerPosition.x - enemy.position.x,
                    playerPosition.z - enemy.position.z
                );
                enemy.rotation.y = lookDir;

                // Hit flash
                if (enemy.userData.hitFlash > 0) {
                    enemy.userData.hitFlash -= dt * 5;
                    enemy.children.forEach(child => {
                        if (child.material && child.material.emissive) {
                            child.material.emissiveIntensity = enemy.userData.hitFlash;
                        }
                    });
                }

                // Remove if too far from player (outside current room area)
                if (distToPlayer > 60) {
                    enemy.userData.active = false;
                }

                // Player collision with enemy (use cart position, not camera)
                if (enemy.userData.active && !isInvulnerable) {
                    const distToPlayer = Math.sqrt(
                        Math.pow(enemy.position.x - playerCart.position.x, 2) +
                        Math.pow(enemy.position.z - playerCart.position.z, 2)
                    );
                    if (distToPlayer < 3.5) {
                        damagePlayer(ENEMY_COLLISION_DAMAGE);
                    }
                }
            });

            // Update obstacles
            obstacles.forEach(obs => {
                if (!obs.userData.active) return;

                if (obs.userData.hit) {
                    obs.userData.fallSpeed += 5 * dt;
                    obs.userData.fallAngle += obs.userData.fallSpeed * dt;
                    obs.rotation.x = obs.userData.fallAngle;
                    obs.position.y -= obs.userData.fallSpeed * dt * 0.5;

                    if (obs.userData.fallAngle > Math.PI / 2) {
                        obs.userData.active = false;
                    }
                }

                // Remove if too far from player
                const distToPlayer = obs.position.distanceTo(playerCart.position);
                if (distToPlayer > 60) {
                    obs.userData.active = false;
                }

                // Player collision with obstacle (use cart position, not camera)
                if (obs.userData.active && !obs.userData.hit && !isInvulnerable) {
                    const distToPlayer = Math.sqrt(
                        Math.pow(obs.position.x - playerCart.position.x, 2) +
                        Math.pow(obs.position.z - playerCart.position.z, 2)
                    );
                    const hitDist = (obs.userData.width || 2) * 0.6;
                    if (distToPlayer < hitDist + 1.5) {
                        damagePlayer(OBSTACLE_COLLISION_DAMAGE);
                        obs.userData.hit = true; // Knock it over too
                    }
                }
            });

            // Update particles
            particles.forEach(particle => {
                particle.userData.velocity.y -= 15 * dt;
                particle.position.add(particle.userData.velocity.clone().multiplyScalar(dt));
                particle.userData.life -= dt * 2;
                particle.material.opacity = particle.userData.life;
                particle.material.transparent = true;
            });

            // Collision detection with improved accuracy
            projectiles.forEach(proj => {
                if (!proj.userData.active) return;

                // Store previous position for sweep check
                const prevPos = proj.userData.prevPosition || proj.position.clone();
                const currPos = proj.position;

                // Check enemy collisions - optimized with early exit and reused vectors
                const projDir = currPos.clone().sub(prevPos);
                const projLen = projDir.length();
                if (projLen > 0) {
                    projDir.normalize();
                }

                for (let i = 0; i < enemies.length && proj.userData.active; i++) {
                    const enemy = enemies[i];
                    if (!enemy.userData.active) continue;

                    // Quick distance check first (cheaper than full calculation)
                    const dx = enemy.position.x - currPos.x;
                    const dz = enemy.position.z - currPos.z;
                    if (dx * dx + dz * dz > 100) continue;  // Skip if > 10 units away

                    // Enemy hitbox center
                    const enemyCenter = enemy.position.clone();
                    enemyCenter.y += 1.2;

                    const hitRadius = 2.5;
                    const toEnemy = enemyCenter.sub(prevPos);  // Reuse enemyCenter vector

                    if (projLen > 0) {
                        const dot = toEnemy.dot(projDir);
                        const clampedDot = Math.max(0, Math.min(projLen, dot));
                        const closestPoint = prevPos.clone().addScaledVector(projDir, clampedDot);
                        enemyCenter.copy(enemy.position).y += 1.2;  // Restore for distance check
                        const dist = closestPoint.distanceTo(enemyCenter);

                        if (dist < hitRadius) {
                            proj.userData.active = false;
                            const damage = 1 + Math.round((proj.userData.power || 0) * 2);
                            enemy.userData.health -= damage;
                            enemy.userData.hitFlash = 1;
                            showHitMarker();

                            const healthBar = enemy.getObjectByName('healthBar');
                            if (healthBar) {
                                healthBar.scale.x = enemy.userData.health / ENEMY_HEALTH;
                                healthBar.position.x = -(1 - healthBar.scale.x);
                            }

                            if (enemy.userData.health <= 0) {
                                enemy.userData.active = false;
                                addScore(300, enemy.position);
                                spawnParticles(enemy.position, 0xe94560, 15);  // Fewer particles
                            } else {
                                addScore(100, enemy.position);
                                spawnParticles(closestPoint, 0xf39c12, 3);  // Fewer particles
                            }
                        }
                    }
                }

                // Check obstacle collisions - optimized
                for (let i = 0; i < obstacles.length && proj.userData.active; i++) {
                    const obs = obstacles[i];
                    if (!obs.userData.active || obs.userData.hit) continue;

                    // Quick distance check
                    const dx = obs.position.x - currPos.x;
                    const dz = obs.position.z - currPos.z;
                    if (dx * dx + dz * dz > 64) continue;  // Skip if > 8 units away

                    const obsCenter = obs.position.clone();
                    obsCenter.y += (obs.userData.height || 2) * 0.4;
                    const hitRadius = (obs.userData.width || 2) * 0.8;

                    const toObs = obsCenter.sub(prevPos);

                    if (projLen > 0) {
                        const dot = toObs.dot(projDir);
                        const clampedDot = Math.max(0, Math.min(projLen, dot));
                        const closestPoint = prevPos.clone().addScaledVector(projDir, clampedDot);
                        obsCenter.copy(obs.position).y += (obs.userData.height || 2) * 0.4;
                        const dist = closestPoint.distanceTo(obsCenter);

                        if (dist < hitRadius) {
                            proj.userData.active = false;
                            obs.userData.hit = true;
                            showHitMarker();
                            addScore(150, obs.position);
                            spawnParticles(obs.position, 0xf1c40f, 10);  // Fewer particles
                        }
                    }
                }

                // Store current position for next frame's sweep check
                proj.userData.prevPosition = proj.position.clone();
            });

            // Clean up inactive objects
            projectiles = projectiles.filter(p => {
                if (!p.userData.active) {
                    scene.remove(p);
                    return false;
                }
                return true;
            });

            enemies = enemies.filter(e => {
                if (!e.userData.active) {
                    scene.remove(e);
                    return false;
                }
                return true;
            });

            obstacles = obstacles.filter(o => {
                if (!o.userData.active) {
                    scene.remove(o);
                    return false;
                }
                return true;
            });

            particles = particles.filter(p => {
                if (p.userData.life <= 0) {
                    scene.remove(p);
                    return false;
                }
                return true;
            });

            updateCooldownIndicator();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            if (composer) composer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            const dt = Math.min(clock.getDelta(), 0.1);
            update(dt);

            // Decay damage vignette (for CSS overlay)
            damageVignetteStrength *= 0.95;

            // Render with post-processing
            if (composer) {
                composer.render(dt);
            } else {
                renderer.render(scene, camera);
            }
        }

        // Event Listeners
        document.getElementById('start-btn').addEventListener('click', startGame);
        document.getElementById('restart-btn').addEventListener('click', startGame);
        document.getElementById('resume-btn').addEventListener('click', resumeGame);
        document.getElementById('quit-btn').addEventListener('click', quitToMenu);

        // How to Play modal
        const howToPlayModal = document.getElementById('how-to-play-modal');
        const modalCloseBtn = document.getElementById('modal-close');

        document.getElementById('how-to-play-btn').addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            howToPlayModal.classList.add('visible');
        });

        modalCloseBtn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            howToPlayModal.classList.remove('visible');
        });

        // Also handle touch for mobile
        modalCloseBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            howToPlayModal.classList.remove('visible');
        });

        // Close on backdrop click
        howToPlayModal.addEventListener('click', (e) => {
            if (e.target === howToPlayModal) {
                howToPlayModal.classList.remove('visible');
            }
        });

        // Close on ESC key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && howToPlayModal.classList.contains('visible')) {
                howToPlayModal.classList.remove('visible');
                e.stopPropagation();
            }
        }, true);

        // Keyboard controls - WASD driving
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                e.preventDefault();
                togglePause();
                return;
            }

            // Controls only during gameplay
            if (gameState === 'PLAYING') {
                const key = e.key.toLowerCase();
                const code = e.code || '';

                // WASD driving controls (support both e.key and e.code for test compatibility)
                // Tests may pass 'KeyW' as e.key, so check for that too
                if (key === 'w' || code === 'KeyW' || e.key === 'KeyW' || e.key === 'ArrowUp') keys.forward = true;
                if (key === 's' || code === 'KeyS' || e.key === 'KeyS' || e.key === 'ArrowDown') keys.backward = true;
                if (key === 'a' || code === 'KeyA' || e.key === 'KeyA' || e.key === 'ArrowLeft') keys.turnLeft = true;
                if (key === 'd' || code === 'KeyD' || e.key === 'KeyD' || e.key === 'ArrowRight') keys.turnRight = true;

                // Space: Start charging
                if (key === ' ' || e.key === ' ' || code === 'Space') {
                    e.preventDefault();
                    startCharging();
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            const code = e.code || '';

            // WASD driving controls (support both e.key and e.code for test compatibility)
            // Tests may pass 'KeyW' as e.key, so check for that too
            if (key === 'w' || code === 'KeyW' || e.key === 'KeyW' || e.key === 'ArrowUp') keys.forward = false;
            if (key === 's' || code === 'KeyS' || e.key === 'KeyS' || e.key === 'ArrowDown') keys.backward = false;
            if (key === 'a' || code === 'KeyA' || e.key === 'KeyA' || e.key === 'ArrowLeft') keys.turnLeft = false;
            if (key === 'd' || code === 'KeyD' || e.key === 'KeyD' || e.key === 'ArrowRight') keys.turnRight = false;

            // Space: Release and fire
            if ((key === ' ' || e.key === ' ' || code === 'Space') && gameState === 'PLAYING') {
                releaseAndFire();
            }
        });

        // Expose game state and functions for testing
        Object.defineProperty(window, 'gameState', {
            get: () => gameState,
            set: (v) => { gameState = v; }
        });
        Object.defineProperty(window, 'score', {
            get: () => score,
            set: (v) => { score = v; }
        });
        Object.defineProperty(window, 'gameTimer', {
            get: () => gameTimer,
            set: (v) => { gameTimer = v; }
        });
        // Legacy compatibility - distance now returns timer-based progress
        Object.defineProperty(window, 'distance', {
            get: () => (GAME_DURATION - gameTimer) * (CART_SPEED / 3),
            set: (v) => { }
        });
        // playerX returns offset from starting position for legacy test compatibility
        // (v2 tests expected lateral strafe bounded to Â±10)
        const PLAYER_START_X = 45; // Center of ENTRANCE room
        Object.defineProperty(window, 'playerX', {
            get: () => playerPosition.x - PLAYER_START_X,
            set: (v) => { playerPosition.x = v + PLAYER_START_X; }
        });
        Object.defineProperty(window, 'playerPosition', {
            get: () => playerPosition,
            set: (v) => { playerPosition = v; }
        });
        Object.defineProperty(window, 'playerRotation', {
            get: () => playerRotation,
            set: (v) => { playerRotation = v; }
        });
        Object.defineProperty(window, 'playerHealth', {
            get: () => playerHealth,
            set: (v) => { playerHealth = v; }
        });
        Object.defineProperty(window, 'health', {
            get: () => playerHealth,
            set: (v) => { playerHealth = v; }
        });
        window.startGame = startGame;
        window.pauseGame = pauseGame;
        window.resumeGame = resumeGame;
        window.endGame = endGame;
        window.damagePlayer = damagePlayer;
        window.takeDamage = damagePlayer;
        window.keys = keys;
        window.enemies = enemies;
        window.obstacles = obstacles;

        // Expose 3D objects for testing
        Object.defineProperty(window, 'fpsWeapon', {
            get: () => fpsWeapon
        });
        Object.defineProperty(window, 'playerChild', {
            get: () => playerChild
        });
        Object.defineProperty(window, 'playerCart', {
            get: () => playerCart
        });

        // Expose slingshot tension for testing
        Object.defineProperty(window, 'slingshotTension', {
            get: () => slingshotTension,
            set: (v) => { slingshotTension = v; }
        });
        Object.defineProperty(window, 'isChargingSlingshot', {
            get: () => isChargingSlingshot,
            set: (v) => { isChargingSlingshot = v; }
        });
        window.startCharging = startCharging;
        window.releaseAndFire = releaseAndFire;
        window.cancelCharging = cancelCharging;
        window.resetGame = resetGame;
        // Manual update function for test compatibility (RAF may not run in backgrounded iframes)
        window.manualUpdate = (dt = 0.016) => update(dt);
        // Wall bump effect exposure for testing
        Object.defineProperty(window, 'wallBumpIntensity', {
            get: () => wallBumpIntensity,
            set: (v) => { wallBumpIntensity = v; }
        });
        window.triggerWallBump = (intensity, dirX, dirZ) => {
            wallBumpIntensity = intensity;
            wallBumpDirection = { x: dirX, z: dirZ };
        };
        Object.defineProperty(window, 'cameraMode', {
            get: () => cameraMode,
            set: (v) => { cameraMode = v; }
        });
        // Expose lastShootTime for test to reset cooldown
        Object.defineProperty(window, 'lastShootTime', {
            get: () => lastShootTime,
            set: (v) => { lastShootTime = v; }
        });
        Object.defineProperty(window, 'camera', {
            get: () => camera
        });
        Object.defineProperty(window, 'projectiles', {
            get: () => projectiles
        });

        // Initialize and start
        initThree();
        updateCursor();

        // Set initial UI state (MENU)
        healthContainer.style.display = 'none';
        hud.style.display = 'none';

        animate();
    </script>
</body>
</html>
